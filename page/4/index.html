<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Andeper的个人博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="欢迎来到我的技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Andeper的个人博客">
<meta property="og:url" content="http://andeper.cn/page/4/index.html">
<meta property="og:site_name" content="Andeper的个人博客">
<meta property="og:description" content="欢迎来到我的技术博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Andeper的个人博客">
<meta name="twitter:description" content="欢迎来到我的技术博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://andeper.cn/page/4/"/>





  <title> Andeper的个人博客 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
<!-- hexo-inject:begin --><!-- hexo-inject:end --><script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '',
      xfbml      : true,
      version    : 'v2.6'
    });
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "//connect.facebook.net/zh_Hans/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>




	<div id="vk_api_transport"></div>
	<script type="text/javascript">
		window.vkAsyncInit = function() {
			VK.init({
				apiId: 
			});

			

			
		};
		setTimeout(function() {
			var el = document.createElement("script");
			el.type = "text/javascript";
			el.src = "//vk.com/js/api/openapi.js";
			el.async = true;
			document.getElementById("vk_api_transport").appendChild(el);
		}, 0);
	</script>





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8aabc26c969f399d0abe524a29699f13";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Andeper的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/14/Android面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/Android面试题/" itemprop="url">
                  Android面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T20:15:00+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/Android面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/Android面试题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AIDL, Binder，AMS， 启动流程， view绘制， 消息队列，Binder open(), map(),</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p><a href="http://blog.csdn.net/chenrushui/article/details/51724506" target="_blank" rel="noopener">http://blog.csdn.net/chenrushui/article/details/51724506</a></p>
<h4 id="对Android系统了解多少"><a href="#对Android系统了解多少" class="headerlink" title="对Android系统了解多少"></a>对Android系统了解多少</h4><p>我说知道Binder机制和Android系统启动过程<br>答主牛皮，忘这两个方面扯</p>
<h4 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h4><p>类比TCP协议，从应用层说到了Linux内核驱动<br>Binder通信的四个角色：<br>Client进程：使用服务的进程。<br>Server进程：提供服务的进程。<br>ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。<br>Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。<br>初次接触这些概念可能会觉得难于理解，读者可以把四个角色和熟悉的互联网进行类比：Server是服务器，Client是客户终端，ServiceManager是域名服务器（DNS），驱动是路由器。这样类比，你很容易就能理解下图：<br><img src="http://omjy3y3o5.bkt.clouddn.com/3426a4d163ae99a9f31836e8c7325dd5.png" alt="binder"><br>Binder的运行机制就很好理解了，Server进程向Service Manager进程注册服务（可访问的方法接口），Client进程通过Binder驱动可以访问到Server进程提供的服务。Binder驱动管理着Binder之间的数据传递，这个数据的具体格式由Binder协议定义（可以类比为网络传输的TCP协议）。并且Binder驱动持有每个Server在内核中的Binder实体，并给Client进程提供Binder的引用。<br>Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。</p>
<ol>
<li>Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中</li>
<li>Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server</li>
<li>Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信</li>
<li>Client和Server之间的进程间通信通过Binder驱动程序间接实现</li>
<li>Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力</li>
</ol>
<h4 id="Linux中进程A能否直接访问进行进程B？为什么？"><a href="#Linux中进程A能否直接访问进行进程B？为什么？" class="headerlink" title="Linux中进程A能否直接访问进行进程B？为什么？"></a>Linux中进程A能否直接访问进行进程B？为什么？</h4><p>我说不能，因为内存独立。面试官问两个进程会不会内存重叠？然后我就沉默了</p>
<h4 id="一个应用为什么要开多个进程？"><a href="#一个应用为什么要开多个进程？" class="headerlink" title="一个应用为什么要开多个进程？"></a>一个应用为什么要开多个进程？</h4><p>我说有的应用是流氓，进程间相互保活，有的是处于业务考虑，有的是解决65535方法数问题。</p>
<h4 id="一个应用中Activity启动另一个Activity和一个应用中Activity启动另一个应用中Acvtivity的差别大吗？"><a href="#一个应用中Activity启动另一个Activity和一个应用中Activity启动另一个应用中Acvtivity的差别大吗？" class="headerlink" title="一个应用中Activity启动另一个Activity和一个应用中Activity启动另一个应用中Acvtivity的差别大吗？"></a>一个应用中Activity启动另一个Activity和一个应用中Activity启动另一个应用中Acvtivity的差别大吗？</h4><p>扯到了Binder机制，任务栈应用的创建以及Activity的创建。</p>
<h4 id="view，SurfaceView，GLSurfaceView的关系和区别"><a href="#view，SurfaceView，GLSurfaceView的关系和区别" class="headerlink" title="view，SurfaceView，GLSurfaceView的关系和区别"></a>view，SurfaceView，GLSurfaceView的关系和区别</h4><p>SurfaceView和View最本质的区别在于，surfaceView是在一个新起的单独线程中可以重新绘制画面而View必须在UI的主线程中更新画面。<br>那么在UI的主线程中更新画面 可能会引发问题，比如你更新画面的时间过长，那么你的主UI线程会被你正在画的函数阻塞。那么将无法响应按键，触屏等消息。<br>当使用surfaceView 由于是在新的线程中更新画面所以不会阻塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要surfaceView中 thread处理，一般就需要有一个event queue的设计来保存touch event，这会稍稍复杂一点，因为涉及到线程同步。<br>所以基于以上，根据游戏特点，一般分成两类。</p>
<ol>
<li>被动更新画面的。比如棋类，这种用view就好了。因为画面的更新是依赖于 onTouch 来更新，可以直接使用 invalidate。 因为这种情况下，这一次Touch和下一次的Touch需要的时间比较长些，不会产生影响。</li>
<li>主动更新。比如一个人在一直跑动。这就需要一个单独的thread不停的重绘人的状态，避免阻塞main UI thread。所以显然view不合适，需要surfaceView来控制。<br>GLSurfaceView（Android中3D游戏专用画布）中渲染图片的对比中发现GLSurfaceView的效率高于SurfaceView的30倍；GLSurfaceView的效率主要是因为机器硬件的GPU加速，现在flash技术也有了GPU加速技术；<br>下面总结一下：<br>一般2D游戏使用SurfaceView足够，所以不要认为什么都要使用GLSurfaceView（openGL），而且 GLSurfaceView的弊端在于适配能力差，因为很多机型中是没有GPU加速的。<h4 id="各种动画的区别，500张图片怎么使用帧动画实现，怎样避免OOM，平时用什么动画，属性动画和补间动画的区别"><a href="#各种动画的区别，500张图片怎么使用帧动画实现，怎样避免OOM，平时用什么动画，属性动画和补间动画的区别" class="headerlink" title="各种动画的区别，500张图片怎么使用帧动画实现，怎样避免OOM，平时用什么动画，属性动画和补间动画的区别"></a>各种动画的区别，500张图片怎么使用帧动画实现，怎样避免OOM，平时用什么动画，属性动画和补间动画的区别</h4>View动画，帧动画和属性动画<h4 id="对懒加载的理解"><a href="#对懒加载的理解" class="headerlink" title="对懒加载的理解"></a>对懒加载的理解</h4><h4 id="开发过程中整体怎么考虑，注意什么方面"><a href="#开发过程中整体怎么考虑，注意什么方面" class="headerlink" title="开发过程中整体怎么考虑，注意什么方面"></a>开发过程中整体怎么考虑，注意什么方面</h4><h4 id="横竖屏切换生命周期的调用，怎么配置"><a href="#横竖屏切换生命周期的调用，怎么配置" class="headerlink" title="横竖屏切换生命周期的调用，怎么配置"></a>横竖屏切换生命周期的调用，怎么配置</h4><h4 id="有几种广播，怎么配置，有什么区别，自己对粘性广播的理解，系统中有什么用到了粘性广播"><a href="#有几种广播，怎么配置，有什么区别，自己对粘性广播的理解，系统中有什么用到了粘性广播" class="headerlink" title="有几种广播，怎么配置，有什么区别，自己对粘性广播的理解，系统中有什么用到了粘性广播"></a>有几种广播，怎么配置，有什么区别，自己对粘性广播的理解，系统中有什么用到了粘性广播</h4><h4 id="系统异常退出怎么保存数据，调用什么方法，怎么恢复数据，在哪里恢复数据"><a href="#系统异常退出怎么保存数据，调用什么方法，怎么恢复数据，在哪里恢复数据" class="headerlink" title="系统异常退出怎么保存数据，调用什么方法，怎么恢复数据，在哪里恢复数据"></a>系统异常退出怎么保存数据，调用什么方法，怎么恢复数据，在哪里恢复数据</h4><h4 id="fragment-和-fragmentPagerAdapter使用-fragment在哪个方法中初始化的"><a href="#fragment-和-fragmentPagerAdapter使用-fragment在哪个方法中初始化的" class="headerlink" title="fragment 和 fragmentPagerAdapter使用,fragment在哪个方法中初始化的"></a>fragment 和 fragmentPagerAdapter使用,fragment在哪个方法中初始化的</h4><h4 id="什么情况会造成内存泄露，怎么避免，handler为什么会内存泄露，怎么解决，为什么要用弱引用"><a href="#什么情况会造成内存泄露，怎么避免，handler为什么会内存泄露，怎么解决，为什么要用弱引用" class="headerlink" title="什么情况会造成内存泄露，怎么避免，handler为什么会内存泄露，怎么解决，为什么要用弱引用"></a>什么情况会造成内存泄露，怎么避免，handler为什么会内存泄露，怎么解决，为什么要用弱引用</h4><h4 id="各种情况的优化，比如listview加载数据怎么优化，有几种优化的方案，LRCache原理"><a href="#各种情况的优化，比如listview加载数据怎么优化，有几种优化的方案，LRCache原理" class="headerlink" title="各种情况的优化，比如listview加载数据怎么优化，有几种优化的方案，LRCache原理"></a>各种情况的优化，比如listview加载数据怎么优化，有几种优化的方案，LRCache原理</h4><h4 id="如何防止Service被kill"><a href="#如何防止Service被kill" class="headerlink" title="如何防止Service被kill"></a>如何防止Service被kill</h4><h4 id="AIDL使用，源码"><a href="#AIDL使用，源码" class="headerlink" title="AIDL使用，源码"></a>AIDL使用，源码</h4><h4 id="对进程守护的理解"><a href="#对进程守护的理解" class="headerlink" title="对进程守护的理解"></a>对进程守护的理解</h4><h4 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h4><h4 id="滑动冲突解决，事件分发机制"><a href="#滑动冲突解决，事件分发机制" class="headerlink" title="滑动冲突解决，事件分发机制"></a>滑动冲突解决，事件分发机制</h4><h4 id="adapter-和-listview-的工作流程，转换流程，内部原理"><a href="#adapter-和-listview-的工作流程，转换流程，内部原理" class="headerlink" title="adapter 和 listview 的工作流程，转换流程，内部原理"></a>adapter 和 listview 的工作流程，转换流程，内部原理</h4><h4 id="自定义view流程，onMeasure三种模式的区别和应用，对MeasureSpec的理解"><a href="#自定义view流程，onMeasure三种模式的区别和应用，对MeasureSpec的理解" class="headerlink" title="自定义view流程，onMeasure三种模式的区别和应用，对MeasureSpec的理解"></a>自定义view流程，onMeasure三种模式的区别和应用，对MeasureSpec的理解</h4><h4 id="继承ViewGroup，在纸上写出，如何自定义-LinearLayout-和-Relativelayout"><a href="#继承ViewGroup，在纸上写出，如何自定义-LinearLayout-和-Relativelayout" class="headerlink" title="继承ViewGroup，在纸上写出，如何自定义 LinearLayout 和  Relativelayout"></a>继承ViewGroup，在纸上写出，如何自定义 LinearLayout 和  Relativelayout</h4><h4 id="打开手机随便指出一个界面，怎么自定义View实现，流程"><a href="#打开手机随便指出一个界面，怎么自定义View实现，流程" class="headerlink" title="打开手机随便指出一个界面，怎么自定义View实现，流程"></a>打开手机随便指出一个界面，怎么自定义View实现，流程</h4></li>
</ol>
<p>1.singleTask是否了解，举一个它的使用场景，后续问到会调用的方法。<br>各个模式的出入栈我能说出，但是singleTask的使用场景一时懵逼，举了个更适合singleTop的场景，果然问我觉得这种使用singleTask是不是最佳选择，自己觉得不是最佳，做了解释。</p>
<p>2.listView与recycleView常用哪个？(常用listView)问一下listView复用的问题。<br>a.说一下listView是怎么复用view的。<br>描述了listView重新使用已经移出屏幕的view。<br>b.怎么复用view。<br>这个肯定熟悉的，但是自己一来没经验二来太紧张，描述起来乱七八糟。<br>c.不使用viewHolder能不能进行view的复用。<br>这一个我一时也没能想出，大家能不能提供一个思路？还是根本就不行呢？<br>d.描述了一个场景，一个listView共有200项，10项可以占满屏幕，从顶部一直滑到底部，期间不向上滑，使用了复用的情况下，getView方法调用调用多少次，convertView初始化了几次。<br>自己回答gatView是每次都要的，convertView我们使用复用应该是10次。面试官人很好，说提示一下初始化了11或者12次，思考下为什么，我表示懵逼(其实此时大脑早已短路，对这次也没再抱有多大希望)。面试官告诉我，当我们最下方未完全滑入上方为完全滑出，这时也是要初始化的。我再次在心里感叹了自己智商掉线。</p>
<p>3.考虑这样一个布局怎么实现，就是常见的浏览器搜索框输入的时候，下方会出现搜索热词，各个热词排满一行后进入下一行。<br>我的思维已经完全僵化，也是没get他实际想问的知识，自己思考了使用各种布局利用各种wrapcontent、gravity，但是没有想到。面试官说其实这个比较难了，需要用到自定义viewGroup，我不肯放过机会机会表示自定义viewGroup我是写过的，实现这一个的话可以在layout方法操作，超过一行后布局到下一行。面试官紧接着问layout方法是什么作用，我只回答了确定各个子view的位置，此处需要大家帮助解答。</p>
<p>4.说一下view和viewGroup的事件传递机制吧，dispatchTouchEvent、onTouch和onTouchEvent先后先后顺序，还有onInterceptTouchEvent。<br>这一个自己其实当天还是仔细看过的，但是太紧张了，说的乱七八糟，尤其是拦截的部分，表述太差，也的确是了解不够，面试官表示了解的比较浅显。</p>
<p>5.contentprovider是否只能是数据库的数据，别的程序怎样读取。<br>自己只说出了contentResolver和uri，定义权限没说清楚。</p>
<p>6.描述了一个场景，微博中点击一个淘宝的链接，打开了淘宝应用，这是怎么完成的。</p>
<p>7.说一下fragment和activity的通信。<br>自己说到自定义接口，在fragment初始化时判定是否实现了接口，面试官紧接着问在哪个生命周期函数可以判断，我回答onAttach是双方绑定，onActivityCreated是activity的onCreate已经返回，我都是在onActivityCreated里判断的。面试官没有评价，此处求解。</p>
<p>8.fragment内部怎样嵌套fragment。<br>这个地方的好多函数我忘记了，所以自然说不出……事后自己查看是getChildFragmentManger，但是记成了getChildFragmentContext。面试官紧接着问，内层frag调用getContext获取的是哪一个context，自己之前就已经记错，回答是获取外层的，面试官无奈说回去自己写一下代码试下。</p>
<p>8.java的问题<br>a.静态内部类与非静态内部类区别。<br>b.因为前一个问题提到了内存泄漏，紧接着问你是怎么理解内存泄漏的。<br>c.什么样的对象是应该回收的呢？<br>bc两个问题自己答的乱七八糟，应该说我是懂得基本的道理的，但是叙述太差，说不准确也说不到要点。<br>d.匿名内部类有没有构造方法。<br>e.匿名内部类使用局部变量的要求。为什么要是final的。<br>为什么是final的表示不知道，其实自己查过多次，但是好像这里处理的很模糊？</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/14/Android开发艺术探索-事件分发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/Android开发艺术探索-事件分发/" itemprop="url">
                  Android开发艺术探索-事件分发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T13:00:00+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/Android开发艺术探索-事件分发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/Android开发艺术探索-事件分发/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h3><h4 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h4><h5 id="public-boolean-dispatchTouchEvent-MotionEvent-event"><a href="#public-boolean-dispatchTouchEvent-MotionEvent-event" class="headerlink" title="public boolean dispatchTouchEvent(MotionEvent event)"></a>public boolean dispatchTouchEvent(MotionEvent event)</h5><p>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗此事件</p>
<h5 id="public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="public boolean onInterceptTouchEvent(MotionEvent ev)"></a>public boolean onInterceptTouchEvent(MotionEvent ev)</h5><p>用来判断是否拦截某个时间，如果事件能够传递给当前View，那么此方法一定会被调用，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件</p>
<h5 id="public-boolean-onTouchEvent-MotionEvent-event"><a href="#public-boolean-onTouchEvent-MotionEvent-event" class="headerlink" title="public boolean onTouchEvent(MotionEvent event)"></a>public boolean onTouchEvent(MotionEvent event)</h5><p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接受到事件<br>这三个方法的关系可以用下面伪代码来表示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;</span><br><span class="line">      consume = onTouchEvent(event);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      consume = child.dispatchTouchEvent(event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> consume;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p>
<p>对一个ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，如果过这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用。如果onInterceptTouchEvent方法返回false就表示他不拦截当前事件，此时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用<br>当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTo uchListener中的onTouch方法会被回调。此时事件如何处理还要看onTouch的返回值，如果返回false，则当前onTouchEvent方法会被调用，返回true那么onTouchEvent方法不会被调用<br>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View，即事件总是先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View。如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，如果所有元素都不处理这个事件，那么这个事件最终传递给Activity</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="Activity对点击事件的分发过程"><a href="#Activity对点击事件的分发过程" class="headerlink" title="Activity对点击事件的分发过程"></a>Activity对点击事件的分发过程</h4><p>源码Activity#dispatchTouchEvent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>事件开始首先交给Activity所附属的Window进行分发，如果返回true,整个事件循环就结束了，如果返回了false，那么Activity的onTouchEvent就会被调用<br>接下来看Window是如何将事件传递给ViewGroup的，Window的superDispatchTouchEvent方法也是个抽象方法<br>Window类可以控制顶级View的外观和行为策略，它的实现类是PhoneWindow<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递给decorView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>点击事件直接传递到了DecorView，DecorView继承自FrameLayout且是父View，我们通过setContentView设置的View就是它的一个子View</p>
<h4 id="顶级View的分发过程"><a href="#顶级View的分发过程" class="headerlink" title="顶级View的分发过程"></a>顶级View的分发过程</h4><p>直接上ViewGroup的dispatchTouchEvent方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于辅助功能事件的处理</span></span><br><span class="line">    <span class="comment">// If the event targets the accessibility focused view and this is it, start</span></span><br><span class="line">    <span class="comment">// normal event dispatch. Maybe a descendant is what will handle the click.</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">        <span class="comment">//处理原始的down事件</span></span><br><span class="line">        <span class="comment">// Handle an initial down.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">//在新事件开始时处理完上一个事件</span></span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            <span class="comment">//这个方法会重置FLAG_DISALLOW_INTERCEPT</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查事件拦截</span></span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//ViewGroup在如下两种情况会判断是否拦截当前事件，事件类型为Down或者mFirstTouchTarget!=null</span></span><br><span class="line">            <span class="comment">//当事件由ViewGroup的子元素成功处理时，mFirstTouchTarget会被赋值并指向子元素</span></span><br><span class="line">            <span class="comment">//View调用request——DisallowInterceptTouchEvent并不能影响ViewGroup对ACTION_DOWN的处理，</span></span><br><span class="line">            <span class="comment">//而且onInterceptTouchEvent不是每次事件都会被调用</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed，恢复事件防止其改变</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If intercepted, start normal event dispatch. Also if there is already</span></span><br><span class="line">        <span class="comment">// a view that is handling the gesture, do normal event dispatch.</span></span><br><span class="line">        <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查事件是否取消</span></span><br><span class="line">        <span class="comment">// Check for cancelation.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="comment">//如果有必要的话，为所有down事件检查所有的目标对象</span></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果事件未被取消未被拦截</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">//如果有辅助功能的参与，则直接将事件投递到对应的View，否则事件分发给所有的子View</span></span><br><span class="line">            <span class="comment">// If the event is targeting accessiiblity focus we give it to the</span></span><br><span class="line">            <span class="comment">// view that has accessibility focus and if it does not handle it</span></span><br><span class="line">            <span class="comment">// we clear the flag and dispatch the event to all children as usual.</span></span><br><span class="line">            <span class="comment">// We are looking up the accessibility focused host to avoid keeping</span></span><br><span class="line">            <span class="comment">// state since these events are very rare.</span></span><br><span class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                    ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果事件为起始事件</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line">                <span class="comment">//如果TouchTarget为空且子元素不为0</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">//自上而下去寻找一个可以就收该事件的子View</span></span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="comment">//遍历子元素</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">                        <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">                        <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">                        <span class="comment">// safer given the timeframe.</span></span><br><span class="line">                        <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">//实际上是调用子元素的dispatchTouchEvent</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看看dispatchTransformedTouchEvent是如何调度子元素dispatchTouchEvent<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">        <span class="comment">//如果事件被取消</span></span><br><span class="line">        <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></span><br><span class="line">        <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            <span class="comment">//如果没有子元素</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//调用父类的dispatchTouchEvent</span></span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果有子元素传递cancel事件</span></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算将被传递的点的数量</span></span><br><span class="line">        <span class="comment">// Calculate the number of pointers to deliver.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line">        <span class="comment">//如果没有相应的点，那么就丢弃该事件</span></span><br><span class="line">        <span class="comment">// If for some reason we ended up in an inconsistent state where it looks like we</span></span><br><span class="line">        <span class="comment">// might produce a motion event with no pointers in it, then drop the event.</span></span><br><span class="line">        <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//声明临时变量保存坐标转换后的MotionEvent</span></span><br><span class="line">        <span class="comment">// If the number of pointers is the same and we don't need to perform any fancy</span></span><br><span class="line">        <span class="comment">// irreversible transformations, then we can reuse the motion event for this</span></span><br><span class="line">        <span class="comment">// dispatch as long as we are careful to revert any changes we make.</span></span><br><span class="line">        <span class="comment">// Otherwise we need to make a copy.</span></span><br><span class="line">        <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">        <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//尝试获取xy方向上的偏移量</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                    <span class="comment">//将MotionEvent进行坐标变换</span></span><br><span class="line">                    event.offsetLocation(offsetX, offsetY);</span><br><span class="line">                    <span class="comment">//将变换后的MotionEvent传递给子元素</span></span><br><span class="line">                    handled = child.dispatchTouchEvent(event);</span><br><span class="line">                    <span class="comment">//复位MotionEvent之后再次使用</span></span><br><span class="line">                    event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handled;</span><br><span class="line">            &#125;</span><br><span class="line">            transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">            transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">            <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">                transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Done.</span></span><br><span class="line">        transformedEvent.recycle();</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/13/Android开发艺术探索-IPC机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/Android开发艺术探索-IPC机制/" itemprop="url">
                  Android开发艺术探索-IPC机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T14:23:00+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/13/Android开发艺术探索-IPC机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/13/Android开发艺术探索-IPC机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Android-IPC简介"><a href="#Android-IPC简介" class="headerlink" title="Android IPC简介"></a>Android IPC简介</h3><p>IPC是Inter-Process Communication的缩写，含义为进程间通信</p>
<h3 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h3><h4 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h4><p>在Android中只能在AndroidMenifest中指定android:process属性，除此之外就是通过JNI在native层去fork一个新的进程<br>在指定进程时，“:”的含义是指要在当前进程名前面附加上当前的包名，而且“:”开头的进程属于私有进程，其他应用的组建不能和他泡在同一个进程里，不以“:”开头的属于全局进程，其他应用可以通过ShareUID方式和它泡在同一个进程里<br>Android系统会为每个应用分配唯一一个UID，具有相同UID的应用才能共享数据</p>
<h4 id="多进程模式的运行机制"><a href="#多进程模式的运行机制" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h4><p>Android为每个应用分配了一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间，导致在不同虚拟机访问同一个类的对象会产生多份副本。<br>使用多进程会造成如下几个方面的问题<br>（1）静态成员和单例模式完全失效<br>（2）线程同步机制完全失效<br>（3）SharePreferences可靠性下降<br>（4）Application会多次创建<br><strong>SharePreferences底层通过读写xml来实现</strong></p>
<h3 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h3><h4 id="Serializable接"><a href="#Serializable接" class="headerlink" title="Serializable接"></a>Serializable接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.text"</span>));</span><br><span class="line">User user1 = (User) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>
<h4 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>标记位</th>
</tr>
</thead>
<tbody>
<tr>
<td>createFromParcel(Parcel in)</td>
<td>从序列化的对象中创建原始对象</td>
<td></td>
</tr>
<tr>
<td>newArray(int size)</td>
<td>创建指定长度的原始对象爱那个数组</td>
<td></td>
</tr>
<tr>
<td>User(Parcel in)</td>
<td>从序列化后的对象中创建原始对象</td>
<td></td>
</tr>
<tr>
<td>writeToParcel(Paecel out,int flag)</td>
<td>将当前对象写入序列化结构中，其中flags标识由两种值：0或者1.为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0</td>
<td>PARCEABLE_WRITE_RETURN_VALUE</td>
</tr>
<tr>
<td>describeContents</td>
<td>返回当前对象的内容描述，如果含有文件描述符，返回1，否则返回0，几乎所有情况都返回0</td>
<td>CONTENTS_FILE_DESCRIPTOR</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line">    <span class="keyword">public</span> Book book;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String username, <span class="keyword">boolean</span> isMale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.isMale = isMale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        userId = in.readInt();</span><br><span class="line">        username = in.readString();</span><br><span class="line">        isMale = in.readByte() != <span class="number">0</span>;</span><br><span class="line">        book = in.readParcelable(Book.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Creator&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel parcel, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        parcel.writeInt(userId);</span><br><span class="line">        parcel.writeString(username);</span><br><span class="line">        parcel.writeByte((<span class="keyword">byte</span>) (isMale ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">        parcel.writeParcelable(book, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Serializable使用简单但io开销大，Parcelable使用麻烦但效率很高，无所谓反正实际都不会用到</p>
<h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>Binder是一种跨进程通信的方式<br>Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁<br>Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端就返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务或者基于AIDL的服务<br>我们写好三个文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Book.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel parcel, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        parcel.writeInt(bookId);</span><br><span class="line">        parcel.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                <span class="string">"bookId="</span> + bookId +</span><br><span class="line">                <span class="string">", bookName='"</span> + bookName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.project.andeper.aidl;</span><br><span class="line">parcelable Book;</span><br><span class="line"><span class="comment">//IBookManager</span></span><br><span class="line"><span class="keyword">package</span> com.project.andeper.aidl;</span><br><span class="line"><span class="keyword">import</span> com.project.andeper.aidl.Book;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span></span>&#123;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>.aidl文件要放在aidl文件夹下<br>然后系统就生成下面这个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有可以在Binder中传输的接口都需要继承IInterface接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">project</span>.<span class="title">andeper</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Binder的唯一标识，一般由当前类名表示</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.project.andeper.aidl.IBookManager"</span>;</span><br><span class="line">        <span class="comment">//Stub是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，当两者位于不同进程，方法调用需要走transact过程，这个逻辑由Stub的内部代理类Proxy来完成，这个接口的核心实现就是它的内部类Stub和Stub的代理类Proxy</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，如果客户端与服务端位于同一进程，那么此方法返回的是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.project.andeper.aidl.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.project.andeper.aidl.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.project.andeper.aidl.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.project.andeper.aidl.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回当前Binder对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个方法运行在Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数，然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值，onTransace方法的执行过程就是这样的，需要注意的是，如果此方法返回false，那么客户端的请求就会失败，因此可以利用这个特性来做权限验证</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    java.util.List&lt;com.project.andeper.aidl.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    com.project.andeper.aidl.Book _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.project.andeper.aidl.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">project</span>.<span class="title">andeper</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//aidl中申明的方法</span></span><br><span class="line">            <span class="comment">//这个方法运行在客户端，当客户端远程调用此方法时，它的内部实现是这样的，首先创建该方法所需要的输入型Parcel对象_data、输出型Parcel对象_reply和返回值对象list；然后把该方法的参数信息写入_data中；接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，知道RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果；最后返回_reply中的数据</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.project.andeper.aidl.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.project.andeper.aidl.Book&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.project.andeper.aidl.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//aidl中申明的方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.project.andeper.aidl.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.project.andeper.aidl.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.project.andeper.aidl.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Android中的IPC方式"><a href="#Android中的IPC方式" class="headerlink" title="Android中的IPC方式"></a>Android中的IPC方式</h3><h4 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h4><h4 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h4><h4 id="使用Messenger"><a href="#使用Messenger" class="headerlink" title="使用Messenger"></a>使用Messenger</h4><h4 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，降暴露给客户端的接口在这个AIDL文件中声明。最后在Service中实现这个AIDL接口即可</p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>首先绑定服务端的Service，绑定成功后，把服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法</p>
<h5 id="AIDL接口的创建"><a href="#AIDL接口的创建" class="headerlink" title="AIDL接口的创建"></a>AIDL接口的创建</h5><p>在AIDL文件中，只能使用指定的数据类型，基本数据类型，String和CharSequence、List只支持ArrayList、Map只支持HashMap，和所有实现了Parcelable接口的对象、AIDL.<br>除此之外，AIDL中除了基本数据类型其他类型的参数必须标上方向</p>
<h5 id="远程服务端Service的实现"><a href="#远程服务端Service的实现" class="headerlink" title="远程服务端Service的实现"></a>远程服务端Service的实现</h5><h5 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h5><h4 id="使用ContentProvider"><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h4><h4 id="使用Socket"><a href="#使用Socket" class="headerlink" title="使用Socket"></a>使用Socket</h4><h3 id="Binder连接池"><a href="#Binder连接池" class="headerlink" title="Binder连接池"></a>Binder连接池</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/11/OkHttp框架解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/11/OkHttp框架解析/" itemprop="url">
                  OkHttp框架解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T20:29:00+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架解析/" itemprop="url" rel="index">
                    <span itemprop="name">框架解析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/11/OkHttp框架解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/11/OkHttp框架解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文基本出自<a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="noopener">BlackSwift的简书</a><br>OkHttp是一个高效的Http客户端，有如下的特点：</p>
<ol>
<li>支持HTTP2/SPDY黑科技</li>
<li>socket自动选择最好路线，并支持自动重连</li>
<li>拥有自动维护的socket连接池，减少握手次数</li>
<li>拥有队列线程池，轻松写并发</li>
<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）</li>
<li>基于Headers的缓存策略</li>
</ol>
<h4 id="主要对象"><a href="#主要对象" class="headerlink" title="主要对象"></a>主要对象</h4><p>Connections: 对JDK中的socket进行了引用计数封装，用来控制socket连接<br>Streams: 维护HTTP的流，用来对Requset/Response进行IO操作<br>Calls: HTTP请求任务封装<br>StreamAllocation: 用来控制Connections/Streams的资源分配与释放</p>
<h4 id="工作流程概述"><a href="#工作流程概述" class="headerlink" title="工作流程概述"></a>工作流程概述</h4><p>当我们用OkHttpClient.newCall(request)进行execute/enenqueue时，实际是将请求Call放到了Dispatcher中，okhttp使用Dispatcher进行线程分发，它有两种方法，一个是普通的同步单线程；另一种是使用了队列进行并发任务的分发(Dispatch)与回调，我们下面主要分析第二种，也就是队列这种情况，这也是okhttp能够竞争过其它库的核心功能之一</p>
<h4 id="Dispatcher结构"><a href="#Dispatcher结构" class="headerlink" title="Dispatcher结构"></a>Dispatcher结构</h4><p>Dispatcher维护了如下变量，用于控制并发的请求</p>
<h6 id="maxRequests-64-最大并发请求数为64"><a href="#maxRequests-64-最大并发请求数为64" class="headerlink" title="maxRequests = 64: 最大并发请求数为64"></a>maxRequests = 64: 最大并发请求数为64</h6><h6 id="maxRequestsPerHost-5-每个主机最大请求数为5"><a href="#maxRequestsPerHost-5-每个主机最大请求数为5" class="headerlink" title="maxRequestsPerHost = 5: 每个主机最大请求数为5"></a>maxRequestsPerHost = 5: 每个主机最大请求数为5</h6><h6 id="Dispatcher-分发者，也就是生产者（默认在主线程）"><a href="#Dispatcher-分发者，也就是生产者（默认在主线程）" class="headerlink" title="Dispatcher: 分发者，也就是生产者（默认在主线程）"></a>Dispatcher: 分发者，也就是生产者（默认在主线程）</h6><h6 id="AsyncCall-队列中需要处理的Runnable（包装了异步回调接口）"><a href="#AsyncCall-队列中需要处理的Runnable（包装了异步回调接口）" class="headerlink" title="AsyncCall: 队列中需要处理的Runnable（包装了异步回调接口）"></a>AsyncCall: 队列中需要处理的Runnable（包装了异步回调接口）</h6><h6 id="ExecutorService：消费者池（也就是线程池）"><a href="#ExecutorService：消费者池（也就是线程池）" class="headerlink" title="ExecutorService：消费者池（也就是线程池）"></a>ExecutorService：消费者池（也就是线程池）</h6><h6 id="Deque：缓存（用数组实现，可自动扩容，无大小限制）"><a href="#Deque：缓存（用数组实现，可自动扩容，无大小限制）" class="headerlink" title="Deque：缓存（用数组实现，可自动扩容，无大小限制）"></a>Deque<readyasynccalls>：缓存（用数组实现，可自动扩容，无大小限制）</readyasynccalls></h6><h6 id="Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存"><a href="#Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存" class="headerlink" title="Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存"></a>Deque<runningasynccalls>：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存</runningasynccalls></h6><p>在下面的的代码中我们能看到线程池的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<h6 id="int-corePoolSize-最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。"><a href="#int-corePoolSize-最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。" class="headerlink" title="int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。"></a>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。</h6><h6 id="int-maximumPoolSize-最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理"><a href="#int-maximumPoolSize-最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理" class="headerlink" title="int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理"></a>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</h6><h6 id="long-keepAliveTime-当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive"><a href="#long-keepAliveTime-当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive" class="headerlink" title="long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive"></a>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</h6><h6 id="TimeUnit-unit-时间单位，一般用秒"><a href="#TimeUnit-unit-时间单位，一般用秒" class="headerlink" title="TimeUnit unit: 时间单位，一般用秒"></a>TimeUnit unit: 时间单位，一般用秒</h6><h6 id="BlockingQueue-workQueue-工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。"><a href="#BlockingQueue-workQueue-工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。" class="headerlink" title="BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。"></a>BlockingQueue<runnable> workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。</runnable></h6><h6 id="ThreadFactory-threadFactory-单个线程的工厂，可以打Log，设置Daemon-即当JVM退出时，线程自动结束-等"><a href="#ThreadFactory-threadFactory-单个线程的工厂，可以打Log，设置Daemon-即当JVM退出时，线程自动结束-等" class="headerlink" title="ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等"></a>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</h6><h5 id="反向代理模式"><a href="#反向代理模式" class="headerlink" title="反向代理模式"></a>反向代理模式</h5><p>在Nginx中，用户通过Http访问前置的服务器，服务器也会添加Header并自动转发请求给后端集群，接着返回数据结果给用户。通过将工作分配给多个后台服务器并共享Session，可以提高服务的负载均衡，实现<strong>非阻塞、高可用、高并发连接</strong>。<br>在OkHttp中，使用Dispatcher作为任务的派发器，线程池对应多台后置服务器，用AsyncCall对应Socket请求，用Deque<readyasynccalls>对应Socket内部缓存<br><img src="http://omjy3y3o5.bkt.clouddn.com/a150a71fea0f337dea91ba2ae1a209b9.png" alt="Dispatcher"><br>当我们用OkHttp的异步请求时，实际上是Dispather进行了入队操作</readyasynccalls></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果正在进行的异步操作小于最大并发请求数并且请求某个主机的请求书小雨每个主机最大请求数<br>那么把请求添加到正在运行的任务队列<br>否则添加到缓存队列</p>
<p>当任务执行完之后，会在finally代码块中调用Dispatcher的finish函数，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!runningAsyncCalls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"AsyncCall wasn't running!"</span>);</span><br><span class="line">    promoteCalls();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        i.remove();</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的作用在一个任务完成之后，把缓存等待区的最后一个移动到运行区中并执行</p>
<h4 id="Socket管理-StreamAllocation"><a href="#Socket管理-StreamAllocation" class="headerlink" title="Socket管理(StreamAllocation)"></a>Socket管理(StreamAllocation)</h4><p>经过上一步的分配，我们现在需要进行连接了。我们目前有封装好的Request，而进行HTTP连接需要进行Socket握手，Socket握手的前提是根据域名或代理确定Socket的ip与端口。这个环节主要讲了http的握手过程与连接池的管理，分析的对象主要是StreamAllocation</p>
<h5 id="选择路线与自动重连-RouteSelector"><a href="#选择路线与自动重连-RouteSelector" class="headerlink" title="选择路线与自动重连(RouteSelector)"></a>选择路线与自动重连(RouteSelector)</h5><p>此步骤用于获取socket的ip与端口,各位请欣赏源码中next()的迷之缩进与递归，代码进行了如下事情：<br>如果Proxy为null:<br>在构造函数中设置代理为Proxy.NO_PROXY<br>如果缓存中的lastInetSocketAddress为空，就通过DNS（默认是Dns.SYSTEM，包装了jdk自带的lookup函数）查询，并保存结果，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源<br>如果还没有查询到就递归调用next查询，直到查到为止<br>一切next都没有枚举到，抛出NoSuchElementException，退出(这个几乎见不到)<br>如果Proxy为HTTP&#x3A;<br>设置socket的ip为代理地址的ip<br>设置socket的端口为代理地址的端口<br>一切next都没有枚举到，抛出NoSuchElementException，退出<br>HTTP代理是不安全的，本文附录有介绍<br>HTTP代理会帮你在远程服务器进行DNS查询<br>至于socket代理这里就不分析了，它已经不属于应用层了</p>
<h5 id="连接socket链路-RealConnection"><a href="#连接socket链路-RealConnection" class="headerlink" title="连接socket链路(RealConnection)"></a>连接socket链路(RealConnection)</h5><p>当地址，端口准备好了，就可以进行TCP连接了（也就是我们常说的TCP三次握手），步骤如下：</p>
<p>如果连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步<br>根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手<br>将建立成功的RealConnection放入(put)连接池缓存<br>如果存在TLS，就根据SSL版本与证书进行安全握手<br>构造HttpStream并维护刚刚的socket连接，管道建立完成</p>
<h5 id="释放socket链路-release"><a href="#释放socket链路-release" class="headerlink" title="释放socket链路(release)"></a>释放socket链路(release)</h5><p>如果不再需要（比如通信完成，连接失败等）此链路后，释放连接（也就是TCP断开的握手）<br>尝试从缓存的连接池中删除(remove)<br>如果没有命中缓存,就直接调用jdk的socket关闭</p>
<h4 id="复用连接池"><a href="#复用连接池" class="headerlink" title="复用连接池"></a>复用连接池</h4><p>在进行http连接时，首先进行tcp握手，然后传输数据，最后释放，但是在复杂的网络中，创建Socket需要进行三次五首，释放socket需要2次握手或者4次，在http中有一种叫做keeplive connection的机制，它可以在传输数据后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手<br>Okhttp支持5个并发的keepAlive,默认链路生命为5分钟。</p>
<h5 id="keepAlive的缺点"><a href="#keepAlive的缺点" class="headerlink" title="keepAlive的缺点"></a>keepAlive的缺点</h5><p>1.根据TCP的拥塞机制，当总水管大小固定时，如果存在大量空闲的keepalive connections（我们可以称作僵尸连接或者泄漏连接），其它客户端们的正常连接速度也会受到影响，这也是运营商为何限制P2P连接数的道理<br>2.服务器/防火墙上有并发限制，比如apache服务器对每个请求都开线程，导致只支持150个并发连接（数据来源于nginx官网），不过这个瓶颈随着高并发server软硬件的发展（golang/分布式/IO多路复用）将会越来越少<br>3.大量的DDOS产生的僵尸连接可能被用于恶意攻击服务器，耗尽资源</p>
<h5 id="连接池关键对象"><a href="#连接池关键对象" class="headerlink" title="连接池关键对象"></a>连接池关键对象</h5><h6 id="Call-对http的请求封装，属于程序员能够接触的上层高级代码"><a href="#Call-对http的请求封装，属于程序员能够接触的上层高级代码" class="headerlink" title="Call: 对http的请求封装，属于程序员能够接触的上层高级代码"></a>Call: 对http的请求封装，属于程序员能够接触的上层高级代码</h6><h6 id="Connection-对jdk的socket物理连接的包装，它内部有List-lt-WeakReference-gt-的引用"><a href="#Connection-对jdk的socket物理连接的包装，它内部有List-lt-WeakReference-gt-的引用" class="headerlink" title="Connection: 对jdk的socket物理连接的包装，它内部有List&lt;WeakReference&gt;的引用"></a>Connection: 对jdk的socket物理连接的包装，它内部有List&lt;WeakReference<streamallocation>&gt;的引用</streamallocation></h6><h6 id="StreamAllocation-表示Connection被上层高级代码的引用次数"><a href="#StreamAllocation-表示Connection被上层高级代码的引用次数" class="headerlink" title="StreamAllocation: 表示Connection被上层高级代码的引用次数"></a>StreamAllocation: 表示Connection被上层高级代码的引用次数</h6><h6 id="ConnectionPool-Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计"><a href="#ConnectionPool-Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计" class="headerlink" title="ConnectionPool: Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计"></a>ConnectionPool: Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计</h6><h6 id="Deque-Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础"><a href="#Deque-Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础" class="headerlink" title="Deque: Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础"></a>Deque: Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础</h6><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><p>在源码中，我们先找ConnectionPool实例化的位置，它是直接new出来的，而它的各种操作却在OkHttpClient的static区实现了Internal.instance接口作为ConnectionPool的包装。<br>至于为什么需要这么多此一举的分层包装，主要是为了让外部包的成员访问非public方法</p>
<h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><p>1.连接池内部维护了一个叫做OkHttp ConnectionPool的ThreadPool，专门用来淘汰末位的socket，当满足以下条件时，就会进行末位淘汰，非常像GC<br>并发socket空闲连接超过5个<br>某个socket的keepalive时间大于5分钟<br>2.维护着一个Deque<connection>，提供get/put/remove等数据结构的功能<br>3.维护着一个RouteDatabase，它用来记录连接失败的Route的黑名单，当连接失败的时候就会把失败的线路加进去（本文不讨论）</connection></p>
<h5 id="put-get操作"><a href="#put-get操作" class="headerlink" title="put/get操作"></a>put/get操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从连接池中获取</span></span><br><span class="line"><span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (connection.allocations.size() &lt; connection.allocationLimit</span><br><span class="line">          &amp;&amp; address.equals(connection.route().address)</span><br><span class="line">          &amp;&amp; !connection.noNewStreams) &#123;</span><br><span class="line">        streamAllocation.acquire(connection);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//放入连接池</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">      cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">      executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    connections.add(connection);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//线程变的空闲，并调用清理线程池</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">connectionBecameIdle</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (connection.noNewStreams || maxIdleConnections == <span class="number">0</span>) &#123;</span><br><span class="line">      connections.remove(connection);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      notifyAll(); <span class="comment">// Awake the cleanup thread: we may have exceeded the idle connection limit.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>随着上述操作被更高级的对象调用，Connection中的StreamAllocation被不断的aquire与release，也就是List&lt;WeakReference<streamallocation>&gt;的大小将时刻变化</streamallocation></p>
<h5 id="Connection自动回收的实现"><a href="#Connection自动回收的实现" class="headerlink" title="Connection自动回收的实现"></a>Connection自动回收的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">//遍历Deque所有的RealConnection，标记遗漏的连接</span></span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line">        <span class="comment">// 查询此连接内部StreamAllocation引用的数量</span></span><br><span class="line">        <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idleConnectionCount++;</span><br><span class="line">        <span class="comment">//标记出空闲的连接</span></span><br><span class="line">        <span class="comment">// If the connection is ready to be evicted, we're done.</span></span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">          <span class="comment">//如果(`空闲socket连接超过5个`</span></span><br><span class="line">          <span class="comment">//且`keepalive时间大于5分钟`)</span></span><br><span class="line">          <span class="comment">//就将此泄漏连接从`Deque`中移除</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//返回此连接即将到期的时间，供下次清理</span></span><br><span class="line">        <span class="comment">//这里依据是在上文`connectionBecameIdle`中设定的计时</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 全都是活跃的连接</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有任何连接，跳出循环</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>找到不活跃连接的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似于引用计数法，如果引用全部为空，返回立刻清理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//虚引用列表</span></span><br><span class="line">    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">      <span class="comment">//遍历弱引用列表</span></span><br><span class="line">      Reference&lt;StreamAllocation&gt; reference = references.get(i);</span><br><span class="line">      <span class="comment">//如果正在被使用，跳过，接着循环</span></span><br><span class="line">      <span class="comment">//是否置空是在上文`connectionBecameIdle`的`release`控制的</span></span><br><span class="line">      <span class="keyword">if</span> (reference.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//非常明显的引用计数</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// We've discovered a leaked allocation. This is an application bug.</span></span><br><span class="line">      Platform.get().log(WARN, <span class="string">"A connection to "</span> + connection.route().address().url()</span><br><span class="line">          + <span class="string">" was leaked. Did you forget to close a response body?"</span>, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//否则移除引用</span></span><br><span class="line">      references.remove(i);</span><br><span class="line">      connection.noNewStreams = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//如果所有分配的流均没了，标记为已经距离现在空闲了5分钟</span></span><br><span class="line">      <span class="comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span></span><br><span class="line">      <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">        connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> references.size();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过判断弱引用是是否为null来判断这个连接是否遗漏</p>
<p>根据生产者消费者模型的模型理论，当入队(enqueue)请求时，如果满足(runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行。如果消费者缓存满了，就放入readyAsyncCalls进行缓存等待。<br>当任务执行完成后,调用finished的promoteCalls()函数，手动移动缓存区（可以看出这里是主动清理的，因此不会发生死锁）</p>
<h4 id="HTTP请求序列化-反序列化"><a href="#HTTP请求序列化-反序列化" class="headerlink" title="HTTP请求序列化/反序列化"></a>HTTP请求序列化/反序列化</h4><p>本段主要分析从拼装HTTP套接字到读取的步骤，用垠神的话说，就是实现了一个Parser。分析的对象是HttpStream接口，在HTTP/1.1下是Http1xStream实现的</p>
<h5 id="获取Http流-HttpStream"><a href="#获取Http流-HttpStream" class="headerlink" title="获取Http流(HttpStream)"></a>获取Http流(HttpStream)</h5><p>我们已经在上文的RealConnection通过connectSocket构造HttpStream对象并建立套接字连接<br>在connect()有非常重要的一步，它通过okio库和远程socket建立了I/O连接，为了更好的理解，我们可以把它看成管道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//source 用于获取response</span></span><br><span class="line">source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line"><span class="comment">//sink 用于write buffer 到server</span></span><br><span class="line">sink = Okio.buffer(Okio.sink(rawSocket));</span><br></pre></td></tr></table></figure>
<p>Okhttp的I/O使用的是Okio库，它是java中最好用的I/O API，本人曾经写NFC对这个用的就非常顺手。<br>Buffer: Buffer是可变字节，类似于byte[]，相当于传输介质<br>source: source是okio库中的输入组件，类似于inputstream，经常在下载中用到。它的重要方法是read(Buffer sink, long byteCount)，从流中读取数据。<br>Sink: sink是okio库中的io输出组件，类似于outputstream，经常用于写到file/Socket，它的最重要方法是void write(Buffer source, long byteCount)，写数据到Buffer中<br>如果把连接看成管道，-&gt;为管道的方向，如下图，这里借鉴了go语言的描述</p>
<h5 id="拼装Raw请求与Headers-writeRequestHeaders"><a href="#拼装Raw请求与Headers-writeRequestHeaders" class="headerlink" title="拼装Raw请求与Headers(writeRequestHeaders)"></a>拼装Raw请求与Headers(writeRequestHeaders)</h5><p>我们通过Request.Builder构建了简陋的请求后，可能需要进行一些修饰，这时需要使用Interceptors对Request进行进一步的拼装了。<br>拦截器是okhttp中强大的流程装置，它可以用来监控log，修改请求，修改结果，甚至是对用户透明的GZIP压缩。类似于脚本语言中的map操作。在okhttp中，内部维护了一个Interceptors的List，通过InterceptorChain进行多次拦截修改操作。<br>请求的代码如下，详细代码在这里，源代码中是自增递归(recursive)调用Chain.process()，直到interceptors().size()中的拦截器全部调用完。这里代码维护性估计看着头大，大神们以后可能把它改成for等更简单的循环，主要做了两件事：<br>1.递归调用Interceptors，依次入栈对response进行处理<br>2.当全部递归出栈完成后，移交给网络模块(getResponse)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &lt; client.interceptors().size()) &#123;</span><br><span class="line"></span><br><span class="line">   Interceptor.Chain chain = <span class="keyword">new</span> ApplicationInterceptorChain(index + <span class="number">1</span>, request, forWebSocket);</span><br><span class="line">   Interceptor interceptor = client.interceptors().get(index);</span><br><span class="line">   <span class="comment">//递归调用Chain.process()</span></span><br><span class="line">   Response interceptedResponse = interceptor.intercept(chain);</span><br><span class="line">   <span class="keyword">if</span> (interceptedResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"application interceptor "</span> + interceptor</span><br><span class="line">         + <span class="string">" returned null"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> interceptedResponse;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// No more interceptors. Do HTTP.</span></span><br><span class="line"> <span class="keyword">return</span> getResponse(request, forWebSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是正式的网络请求getResponse()，此步骤通过http协议规范将对象中的数据信息序列化为Raw文本：<br>1.在okhttp中，通过RequestLine，Requst，HttpEngine，Header等参数进行序列化操作，也就是拼装参数为socketRaw数据。拼装方法也比较暴力，直接按照RFC协议要求的格式进行concat输出就实现了<br>2.通过sink写入write到socket连接。</p>
<h5 id="获得响应-readResponseHeaders-Body"><a href="#获得响应-readResponseHeaders-Body" class="headerlink" title="获得响应(readResponseHeaders/Body)"></a>获得响应(readResponseHeaders/Body)</h5><p>此步骤根据获取到的Socket纯文本，解析为Response对象，我们可以看成是一个反序列化（通过http协议将Raw文本转成对象）的过程：</p>
<p>拦截器的设计:<br>1.自定义网络拦截器请求进行递归入栈<br>2.在自定义网络拦截器的intercept中，调用NetworkInterceptorChain的proceed(request),进行真正的网络请求(readNetworkResponse)<br>3.接自定义请求递归出栈<br>网络读取(readNetworkResponse)分析:<br>1.读取Raw的第一行，并反序列化为StatusLine对象<br>2.以Transfer-Encoding: chunked的模式传输并组装Body<br>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(RawData &lt;- RemoteChannel(www.xx.com, <span class="number">80</span>))<span class="comment">//读取远程的Raw</span></span><br><span class="line">    map(<span class="function">func <span class="title">NetworkInterceptorChains</span><span class="params">()</span>)<span class="comment">//预处理</span></span></span><br><span class="line"><span class="function">    <span class="comment">//这里的source引用了HttpEngine，并重写了read方法</span></span></span><br><span class="line"><span class="function">    .<span class="title">map</span><span class="params">(func getTransferStream()</span></span>&#123;&#125;)</span><br><span class="line">    <span class="comment">//根据source拼装body对象</span></span><br><span class="line">    .map(<span class="function">func <span class="title">RealResponseBody</span><span class="params">()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>接下来进行释放socket连接，上文已经介绍过了。现在我们就获得到response对象，可以进行进一步的Gson等操作了。</p>
<h4 id="Http缓存基本知识"><a href="#Http缓存基本知识" class="headerlink" title="Http缓存基本知识"></a>Http缓存基本知识</h4><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>表示到期时间，一般用在response报文中，当超过此事件后响应将被认为是无效的而需要网络连接，反之而是直接使用缓存</p>
<h6 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h6><p>相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。</p>
<h6 id="修订文件名-Reving-Filenames"><a href="#修订文件名-Reving-Filenames" class="headerlink" title="修订文件名(Reving Filenames)"></a>修订文件名(Reving Filenames)</h6><p>如果我们通过设置header保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？我们这时可以通过修改url中的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery</p>
<h6 id="条件GET请求-Conditional-GET-Requests-与304"><a href="#条件GET请求-Conditional-GET-Requests-与304" class="headerlink" title="条件GET请求(Conditional GET Requests)与304"></a>条件GET请求(Conditional GET Requests)与304</h6><p>如缓存果过期或者强制放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送条件get请求即可，如果缓存是有效的，则返回304 Not Modifiled，否则直接返回body。<br>请求的方式有两种：<br>4.1. Last-Modified-Date:<br>客户端第一次网络请求时，服务器返回了<br>Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT<br>客户端再次请求时，通过发送<br>If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT<br>交给服务器进行判断，如果仍然可以缓存使用，服务器就返回304<br>4.2. ETag<br>ETag是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一请求时，服务器返回了<br>ETag: “5694c7ef-24dc”<br>客户端再次请求时，通过发送<br>If-None-Match:”5694c7ef-24dc”<br>交给服务器进行判断，如果仍然可以缓存使用，服务器就返回304<br>如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。</p>
<h6 id="其它标签"><a href="#其它标签" class="headerlink" title="其它标签"></a>其它标签</h6><p>no-cache/no-store: 不使用缓存，no-cache指令的目的是防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令的话，表示客户端将不会接受缓存过的相应，于是缓存服务器必须把客户端请求转发给源服务器。服务器端返回的相应中包含no-cache指令的话那么缓存服务器不能对资源进行缓存。<br>only-if-cached: 只使用缓存<br>Date: The date and time that the message was sent<br>Age: The Age response-header field conveys the sender’s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. 说人话就是CDN反代服务器到原始服务器获取数据延时的缓存时间<br><img src="http://omjy3y3o5.bkt.clouddn.com/78357eee1a7414813f7a1777729fd198.png" alt="缓存"></p>
<h4 id="缓存源码"><a href="#缓存源码" class="headerlink" title="缓存源码"></a>缓存源码</h4><p>OkHttp中使用了CacheStrategy实现了上文的流程图，它根据之前的缓存结果与当前将要发送Request的header进行策略分析，并得出是否进行请求的结论。<br>Request:<br>开发者手动编写并在Interceptor中递归加工而成的对象（如果读者需要调试分析的话，可以用logging-interceptor进行log操作），我们只需要知道了目前传入的Request中并没有任何关于缓存的Header<br>cacheCandidate:<br>也就是上次与服务器交互缓存的Response，可能为null。这里的缓存全部是基于文件系统的Map，key是请求中url的md5，value是在文件中查询到的缓存，页面置换基于LRU算法，我们现在只需要知道它是一个可以读取缓存Header的Response即可。<br>当被CacheStrategy加工输出后，输出networkRequest与cacheResponse，根据是否为空执行不同的请求</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>networkRequest</th>
<th style="text-align:center">cacheResponse</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td style="text-align:center">null</td>
<td>only-if-cached(表明不进行网络请求，且缓存不存在或者过期，一定会返回503错误)</td>
</tr>
<tr>
<td>null</td>
<td style="text-align:center">non-null</td>
<td>不进行网络请求，而且缓存可以使用，直接返回缓存，不用请求网络</td>
</tr>
<tr>
<td>non-null</td>
<td style="text-align:center">null</td>
<td>需要进行网络请求，而且缓存不存在或者过期，直接访问网络</td>
</tr>
<tr>
<td>non-null</td>
<td style="text-align:center">non-null</td>
<td>Header中含有ETag/Last-Modified标签，需要在条件请求下使用，还是需要访问网络</td>
</tr>
</tbody>
</table>
</div>
<p>CacheStrategy使用Factory模式进行构造，参数如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InternalCache responseCache = Internal.instance.internalCache(client);</span><br><span class="line"><span class="comment">//cacheCandidate从disklurcache中获取</span></span><br><span class="line"><span class="comment">//request的url被md5序列化为key,进行缓存查询</span></span><br><span class="line">Response cacheCandidate = responseCache != <span class="keyword">null</span> ? responseCache.get(request) : <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//请求与缓存</span></span><br><span class="line">factory = <span class="keyword">new</span> CacheStrategy.Factory(now, request, cacheCandidate);</span><br><span class="line">cacheStrategy = factory.get();</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">networkRequest = cacheStrategy.networkRequest;</span><br><span class="line">cacheResponse = cacheStrategy.cacheResponse;</span><br><span class="line"><span class="comment">//进行一大堆的if判断，内容同上表格</span></span><br></pre></td></tr></table></figure>
<p>可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果缓存没有命中(即null),网络请求也不需要加缓存Header了</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//`没有缓存的网络请求,查上文的表可知是直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果缓存的TLS握手信息丢失,返回进行直接连接</span></span><br><span class="line">  <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检测response的状态码,Expired时间,是否有no-cache标签</span></span><br><span class="line">  <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">    <span class="comment">//直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CacheControl requestCaching = request.cacheControl();</span><br><span class="line">  <span class="comment">//如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)</span></span><br><span class="line">  <span class="comment">//或者有ETag/Since标签(也就是条件GET请求)</span></span><br><span class="line">  <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">    <span class="comment">//直接连接,把缓存判断交给服务器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据RFC协议计算</span></span><br><span class="line">  <span class="comment">//计算当前age的时间戳</span></span><br><span class="line">  <span class="comment">//now - sent + age (s)</span></span><br><span class="line">  <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">  <span class="comment">//大部分情况服务器设置为max-age</span></span><br><span class="line">  <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//大部分情况下是取max-age</span></span><br><span class="line">    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//大部分情况下设置是0</span></span><br><span class="line">    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//ParseHeader中的缓存控制信息</span></span><br><span class="line">  CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">  <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//设置最大过期时间,一般设置为0</span></span><br><span class="line">    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缓存在过期时间内,可以使用</span></span><br><span class="line">  <span class="comment">//大部分情况下是进行如下判断</span></span><br><span class="line">  <span class="comment">//now - sent + age + 0 &lt; max-age + 0</span></span><br><span class="line">  <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">    <span class="comment">//返回上次的缓存</span></span><br><span class="line">    Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缓存失效, 如果有etag等信息</span></span><br><span class="line">  <span class="comment">//进行发送`conditional`请求,交给服务器处理</span></span><br><span class="line">  Request.Builder conditionalRequestBuilder = request.newBuilder();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionalRequestBuilder.header(<span class="string">"If-None-Match"</span>, etag);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionalRequestBuilder.header(<span class="string">"If-Modified-Since"</span>, lastModifiedString);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionalRequestBuilder.header(<span class="string">"If-Modified-Since"</span>, servedDateString);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//下面请求实质还说网络请求</span></span><br><span class="line">  Request conditionalRequest = conditionalRequestBuilder.build();</span><br><span class="line">  <span class="keyword">return</span> hasConditions(conditionalRequest) ? <span class="keyword">new</span> CacheStrategy(conditionalRequest,</span><br><span class="line">      cacheResponse) : <span class="keyword">new</span> CacheStrategy(conditionalRequest, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。<br>1.Okhttp的缓存是自动完成的，完全由服务器Header决定的，自己没有必要进行控制。网上热传的文章在Interceptor中手工添加缓存代码控制，它固然有用，但是属于Hack式的利用，违反了RFC文档标准，不建议使用，OkHttp的官方缓存控制在注释中。如果读者的需求是对象持久化，建议用文件储存或者数据库即可（比如realm）。<br>2.服务器的配置非常重要，如果你需要减小请求次数，建议直接找对接人员对max-age等头文件进行优化；服务器的时钟需要严格NTP同步<br>3.充分利用Idea的findUsage的功能，源码的各个跳转条件可以很快分析完成<br>4.使用CMD + Y可以快速预览某个函数，类似于forcetouch功能</p>
<h4 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h4><h5 id="缓存简介、"><a href="#缓存简介、" class="headerlink" title="缓存简介、"></a>缓存简介、</h5><p>缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，Redis数据库，都可以看作缓存。它有如下的特点：</p>
<p>1.缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。<br>2.需要实现排序依据，在java中，可以使用Comparable<t>作为排序的的接口<br>3.需要一种页面置换算法(page replacement algorithm)将旧页面去掉换成新的页面，如最久未使用算法（LFU）、先进先出算法（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等<br>4.在OkHttp中，使用FileSystem作为缓存载体（磁盘相对于网络的缓存），使用LRU作为页面置换算法（封装了LinkedHashMap）。</t></p>
<p>在LinkedHashMap中，除了Node&lt;K,V&gt;[] table，还维护着Entry&lt;K,V&gt; head,tail。当put元素后，调用下列回调函数对链表将元素移动到链尾以及清理旧的元素<br>在get元素时，如果设置accessOrder为true时，通过调用如下回调移动元素到链尾，这里特别强调移动，如果这个元素本身已经在链表中，那它将只会移动，而不是新建<br>综上，当你反复对元素进行get/put操作时，经常使用的元素会被移动到tail中，而长期不用的元素会被移动到head</p>
<p>最后迭代(Iterator)时，迭代是从旧元素迭代到新元素，这就是LRU的实现</p>
<p><strong>OkHttp中的关键对象如下：</strong><br>FileSystem: 使用Okio对File的封装，简化了IO操作<br>DiskLruCache.Editor: 添加了同步锁，并对FileSystem进行高度封装<br>DiskLruCache.Entry: 维护着key对应的多个文件<br>Cache.Entry: Responsejava对象与Okio流的序列化/反序列化类<br>DiskLruCache: 维护着文件的创建，清理，读取。内部有清理线程池，LinkedHashMap(也就是LruCache)<br>Cache: 被上级代码调用，提供透明的put/get操作，封装了缓存检查条件与DiskLruCache，开发者只用配置大小即可，不需要手动管理<br>Response/Requset: OkHttp的请求与回应</p>
<h5 id="文件初级封装-FileSystem"><a href="#文件初级封装-FileSystem" class="headerlink" title="文件初级封装(FileSystem)"></a>文件初级封装(FileSystem)</h5><p>众所周之，文件读写是流操作，是一大堆的令人头痛的try/cache操作，在OkHttp中设计了FileSystem.SYSTEM作为文件层的管理。通过用Okio库中的Source/Sink对File进行包装，而不用更为头痛的InputStream这类东西，使上层调用与管道操作一样简单。<br>File(低级操作，步骤繁琐) -&gt; Okio(封装) －&gt; FileSystem(友好工具类)</p>
<h5 id="文件高级封装-DiskLruCache-Entry-Editor-Snapshot"><a href="#文件高级封装-DiskLruCache-Entry-Editor-Snapshot" class="headerlink" title="文件高级封装(DiskLruCache.Entry/Editor/Snapshot)"></a>文件高级封装(DiskLruCache.Entry/Editor/Snapshot)</h5><p>本部分进行了如下的转换，进行了实际的put/get操作<br>FileSystem &lt;— DiskLruCache.Entry/Editor —&gt; source/sink(更少参数)<br>DiskLruCache.Entry针对每个请求的url对应的文件进行引用维护（而没有进行创建/读取等操作），它内部维护了2个File数组，一般来说每个url对应2～4个文件。 文件名命名规则是{md5(url)+ {0,1}}，后面的0或1，分别表示ENTRY_METADATA与ENTRY_BODY。<br>DiskLruCache.Editor对工具类FileSystem进行进一步的封装，它以DiskLruCache.Entry作为构造参数，通过操控Entry中维护的数组，对外暴露source/sink，为上层的java对象与文件的转换提供基于okio的流操作，我们可以通过对它的两个方法进行FindUsage查询获得OkHttp关于文件读写的全部场景</p>
<h5 id="序列化与反序列化-Cache-Entry"><a href="#序列化与反序列化-Cache-Entry" class="headerlink" title="序列化与反序列化(Cache.Entry)"></a>序列化与反序列化(Cache.Entry)</h5><p>文件存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变<br>Resonse(java对象) &lt;—- Cache.Entry —-&gt; source/sink(文件io)<br>代码部分不复杂，与上面的findusage位置相同，可以概括下：<br>如果信息本身就是二进制，就直接写到文件中；如果是文本信息，按照预设的格式写入即可。<br>至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。<br>注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象</p>
<h5 id="缓存的自动清理"><a href="#缓存的自动清理" class="headerlink" title="缓存的自动清理"></a>缓存的自动清理</h5><p>在DiskLruCache初始化时，将建立线程池，最少零个线程，最大一个线程，线程空闲可以活60s，线程名叫做”OkHttp DiskLruCache”，当JVM退出时，线程自动结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!initialized | closed) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// Nothing to do</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历LRU缓存(从旧到新进行遍历map),并删除文件</span></span><br><span class="line">        <span class="comment">//直到小于MaxSize为止</span></span><br><span class="line">        trimToSize();</span><br><span class="line">        <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">          rebuildJournal();</span><br><span class="line">          redundantOpCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>OkHttp通过对文件进行了多次封装，实现了非常简单的I/O操作<br>OkHttp通过对请求url进行md5实现了与文件的映射，实现写入，删除等操作<br>OkHttp内部维护着清理线程池，实现对缓存文件的自动清理</p>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h5><p>代理，也就是有个中间服务器帮助你访问不存在的网站，okhttp中使用jdk自带的代理</p>
<p>You —— Proxy ——- Server<br>HTTP代理的本质是改Header信息，当你访问HTTP/HTTPS服务时，本质是明文向跳板发送如下raw，远程服务器帮你完成dns与请求操作，比如HTTPS请求源码就详细的解释了发送的内容是非加密的，下面是我实际抓包的内容</p>
<p>//HTTP 请求<br>GET HTTP&#x3A;//www.qq.com HTTP/1.1<br>//HTTPS 请求<br>CONNECT github.com:443 HTTP/1.1<br>上面的抓包过程，廉价的民用上网行为管理交换机就可以把你记录的一清二楚，所以慎用HTTP代理或者尽量使用HTTPS代理，它是“不安全”的。</p>
<h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>DNS也就是域名到ip的映射(mapping)操作，用户向DNS服务器的53端口发送udp包后，会返回域名对应的地址，当然发送udp的细节对用户是透明的，用户直接调用jdk就可以了。我们先试下Unix下的查询</p>
<p>$ host baidu.com<br>baidu.com has address 111.13.101.208<br>baidu.com has address 123.125.114.144<br>…..<br>在OkHttp中，提供了DNS接口，默认是使用Dns.SYSTEM，它包装了java原生socket包中的InetAddress.getAllByName(hostname)方法。</p>
<p>参考：DNSPod中HTTP DNS的实现</p>
<h5 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h5><p>OkHttp的最底层是Socket，而不是URLConnection，它通过Platform的Class.forName()反射获得当前Runtime使用的socket库，调用栈如下（了解即可）</p>
<p>okhttp//实现HTTP协议<br>    framwork//JRE，实现JDK中Socket封装<br>      jvm//JDK的实现，本质对libc标准库的native封装<br>        bionic//android下的libc标准库<br>          systemcall//用户态切换入内核<br>              kernel//实现下协议栈(L4,L3)与网络驱动(一般是L2,L1)<br>如果你想用蓝牙硬件中Socket的进行HTTP协议开发，尝试重写这个类。</p>
<p>另外，再说一句废话，自从Android4.4以来，URLConnection在fram的实现也是使用了okhttp</p>
<p>OkHttp支持非常多平台下的Socket库实现，包括Android, JettyBootPlatform等都是支持的，具体的平台支持可以看这里</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/11/Retrofit框架解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/11/Retrofit框架解析/" itemprop="url">
                  Retrofit框架解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T14:59:00+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架解析/" itemprop="url" rel="index">
                    <span itemprop="name">框架解析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/11/Retrofit框架解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/11/Retrofit框架解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Retrofit的原理"><a href="#Retrofit的原理" class="headerlink" title="Retrofit的原理"></a>Retrofit的原理</h4><p>Retrofit充当了一个适配器的角色，将一个java接口翻译成一个Http请求，然后用Okhttp去发送这个请求<br>它是通过java动态代理实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApiManagerService service = retrofit.create(ApiManagerService.class);</span><br></pre></td></tr></table></figure>
<p>传给一个ApiManagerService接口的Class对象，返回ApiManagerService的对象<br>进去看下create方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>获取数据的代码是这句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.carReco(descriptionRequest,body)</span><br></pre></td></tr></table></figure>
<p>上面的service其实就是一个动态代理对象，当service调用carReco方法时会被动态代理拦截，然后调用proxy.newProxyInstance方法中的InvocationHandler对象，他的invoke方法会传入三个对象<br><strong>Object proxy：代理对象</strong><br><strong>Method method：调用的方法</strong><br><strong>Object..args：方法的参数</strong><br>Retrofit关心的时method和他的参数args，接下去Retrofit就会用Java反射获取方法的注解信息，配合args参数，创建一个serviceMethod对象<br>ServiceMethod就像一个中央处理器，传入Retrofit对象和method对象，调用各个接口和解析器，最终生成一个Request,包含api的域名、path、http请求方法、请求头、是否有body、是否是multipart等等，最后返回一个Call对象<br>使用Java动态代理的目的就是拦截被调用的java方法，然后解析这个java方法的注解，最后生成Request由OkHttp发送</p>
<h4 id="创建ServiceMethod"><a href="#创建ServiceMethod" class="headerlink" title="创建ServiceMethod"></a>创建ServiceMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      callAdapter = createCallAdapter();</span><br><span class="line">      responseType = callAdapter.responseType();</span><br><span class="line">      <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">            + Utils.getRawType(responseType).getName()</span><br><span class="line">            + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      responseConverter = createResponseConverter();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(</span><br><span class="line">              <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"FormUrlEncoded can only be specified on HTTP methods with "</span></span><br><span class="line">              + <span class="string">"request body (e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">        Type parameterType = parameterTypes[p];</span><br><span class="line">        <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">              parameterType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">        <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CallAdapter&lt;?&gt; createCallAdapter() &#123;</span><br><span class="line">      Type returnType = method.getGenericReturnType();</span><br><span class="line">      <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(</span><br><span class="line">            <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Annotation[] annotations = method.getAnnotations();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.callAdapter(returnType, annotations);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到第一步获取CallAdapter，responseType和repositoryConverter三个对象，然后解析method的注解，</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/10/Volley框架解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/10/Volley框架解析/" itemprop="url">
                  Volley框架解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T21:52:00+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架解析/" itemprop="url" rel="index">
                    <span itemprop="name">框架解析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/10/Volley框架解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/10/Volley框架解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来来来，先来看下Volley的设计图<br><img src="http://omjy3y3o5.bkt.clouddn.com/2bd47591a6ea7c0619f5de33c36d2fa0.png" alt="Volley"><br>图中可以看到：<br>请求被添加到缓存队列<br>然后请求被缓存分发器出队<br>如果有缓存直接封装结果回调到主线程<br>如果没有缓存则被添加到网络请求队列<br>进行网络请求后传递response到主线程</p>
<h4 id="从使用Volley的第一步开始"><a href="#从使用Volley的第一步开始" class="headerlink" title="从使用Volley的第一步开始"></a>从使用Volley的第一步开始</h4><p>首先调用Volley.newRequestQueue来获取RequestQuene对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上是调用下面这个两个构造参数的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">        String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String packageName = context.getPackageName();</span><br><span class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</span><br><span class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">        RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">        queue.start();</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当stack为空时，会判断手机系统半杯号是否大于9.如果大于9创建一个HurlStack，否则创建HttpClientStack。<br>在这里我们先知道在Android2.2之前HttpClient更好，反之HttpUrlConnection更好，稍后分析他的源码<br>在这个方法里还初始化NetWork类和RequestQueue类，现在我们来看看这两个类的实现。</p>
<h4 id="RequestQueue类"><a href="#RequestQueue类" class="headerlink" title="RequestQueue类"></a>RequestQueue类</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cache, network, threadPoolSize,<span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">        mCache = cache;</span><br><span class="line">        mNetwork = network;</span><br><span class="line">        mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">        mDelivery = delivery;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到RequestQueue四个参数<br>初始化了Cache、Nerwork、NetworkDispatcher,ExecutorDelivery四个参数</p>
<h5 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h5><p>下面看下这个类中的关键代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">        <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">        mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">        mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">            NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                    mCache, mDelivery);</span><br><span class="line">            mDispatchers[i] = networkDispatcher;</span><br><span class="line">            networkDispatcher.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到在这个类中初始化了一个CacheDispatcher(缓存线程)和四个NetworkDispatcher(网络请求线程)<br>并调用了它们的start的方法</p>
<h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">        request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">            mCurrentRequests.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Process requests in the order they are added.</span></span><br><span class="line">        request.setSequence(getSequenceNumber());</span><br><span class="line">        request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line">        <span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.</span></span><br><span class="line">        <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">            mNetworkQueue.add(request);</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Insert request into stage if there's already a request with the same cache key in flight.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">            String cacheKey = request.getCacheKey();</span><br><span class="line">            <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">                <span class="comment">// There is already a request in flight. Queue up.</span></span><br><span class="line">                Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">                <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                stagedRequests.add(request);</span><br><span class="line">                mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                    VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></span><br><span class="line">                <span class="comment">// flight.</span></span><br><span class="line">                mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">                mCacheQueue.add(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在添加请求时，如果请求不能被缓存，直接添加到网络请求队列<br>如果能缓存，被添加到缓存队列</p>
<h4 id="CacheDispatcher类"><a href="#CacheDispatcher类" class="headerlink" title="CacheDispatcher类"></a>CacheDispatcher类</h4><h5 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        <span class="comment">// Make a blocking call to initialize the cache.</span></span><br><span class="line">        mCache.initialize();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Get a request from the cache triage queue, blocking until</span></span><br><span class="line">                <span class="comment">// at least one is available.</span></span><br><span class="line">                <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">                request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line">                <span class="comment">// If the request has been canceled, don't bother dispatching it.</span></span><br><span class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Attempt to retrieve this item from cache.</span></span><br><span class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                    <span class="comment">// Cache miss; send off to the network dispatcher.</span></span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If it is completely expired, just send it to the network.</span></span><br><span class="line">                <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span></span><br><span class="line">                request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">                    <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span></span><br><span class="line">                    mDelivery.postResponse(request, response);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span></span><br><span class="line">                    <span class="comment">// but we need to also send the request to the network for</span></span><br><span class="line">                    <span class="comment">// refreshing.</span></span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line">                    <span class="comment">// Mark the response as intermediate.</span></span><br><span class="line">                    response.intermediate = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// Post the intermediate response back to the user and have</span></span><br><span class="line">                    <span class="comment">// the delivery then forward the request along to the network.</span></span><br><span class="line">                    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                mNetworkQueue.put(request);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                <span class="comment">// Not much we can do about this.</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>死循环方法，这个线程一直会运行，这时候会判断请求是否取消，如果取消直接continue<br>如果没有取消会去查找是否有缓存，如果没有缓存或者缓存已经过期会把请求放到网络请求队列<br>然后判断缓存是否需要刷新，不需要则直接把结果传递回去，否则把结果传递回去后添加请求到网络请求队列<br>添加到网络请求队列，现在看看网络请求分发时怎么进行的</p>
<h4 id="NetworkDispatcher类"><a href="#NetworkDispatcher类" class="headerlink" title="NetworkDispatcher类"></a>NetworkDispatcher类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</span><br><span class="line">        Request&lt;?&gt; request;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Take a request from the queue.</span></span><br><span class="line">            request = mQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line">            <span class="comment">// If the request was cancelled already, do not perform the</span></span><br><span class="line">            <span class="comment">// network request.</span></span><br><span class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            addTrafficStatsTag(request);</span><br><span class="line">            <span class="comment">// Perform the network request.</span></span><br><span class="line">            NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">            request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line">            <span class="comment">// If the server returned 304 AND we delivered a response already,</span></span><br><span class="line">            <span class="comment">// we're done -- don't deliver a second identical response.</span></span><br><span class="line">            <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Parse the response here on the worker thread.</span></span><br><span class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">            request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line">            <span class="comment">// Write to cache if applicable.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line">            <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Post the response back.</span></span><br><span class="line">            request.markDelivered();</span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">            parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">            VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</span><br><span class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">            mDelivery.postError(request, volleyError);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类的逻辑就很清晰了，首先会检查请求是否被取消，如果没有则在Network的performRequest方法中进行网络请求<br>然后构造Response对象准备回传，如果这个请求的结果能被缓存，那么则把这个结果缓存下来<br>出错了则构造VolleyErroy进行回传<br>既然网络请求是在PerformRequest方法进行的，那么我们去看下是怎么实现的<br>然而发现这个方法在Nerwork中，而Network是一个接口，所以我们直接看他的实现类BasicNetwork</p>
<h4 id="BasicNetwork类"><a href="#BasicNetwork类" class="headerlink" title="BasicNetwork类"></a>BasicNetwork类</h4><h5 id="PerformRequest方法"><a href="#PerformRequest方法" class="headerlink" title="PerformRequest方法"></a>PerformRequest方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">           Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// Gather headers.</span></span><br><span class="line">               Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">               addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">               httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">               StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">               <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</span><br><span class="line">               responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">               <span class="comment">// Handle cache validation.</span></span><br><span class="line">               <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">                   Entry entry = request.getCacheEntry();</span><br><span class="line">                   <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</span><br><span class="line">                               responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">                               SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// A HTTP 304 response does not have all header fields. We</span></span><br><span class="line">                   <span class="comment">// have to use the header fields from the cache entry plus</span></span><br><span class="line">                   <span class="comment">// the new ones from the response.</span></span><br><span class="line">                   <span class="comment">// http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</span></span><br><span class="line">                   entry.responseHeaders.putAll(responseHeaders);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</span><br><span class="line">                           entry.responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">                           SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">               <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">                 <span class="comment">// no-content request.</span></span><br><span class="line">                 responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// if the request is slow, log it.</span></span><br><span class="line">               <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">               logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line">               <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,</span><br><span class="line">                       SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">               attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line">               attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">               NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   statusCode = httpResponse.getStatusLine().getStatusCode();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</span><br><span class="line">               &#125;</span><br><span class="line">               VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</span><br><span class="line">               <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,</span><br><span class="line">                           responseHeaders, <span class="keyword">false</span>, SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">                   <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</span><br><span class="line">                           statusCode == HttpStatus.SC_FORBIDDEN) &#123;</span><br><span class="line">                       attemptRetryOnException(<span class="string">"auth"</span>,</span><br><span class="line">                               request, <span class="keyword">new</span> AuthFailureError(networkResponse));</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// <span class="doctag">TODO:</span> Only throw ServerError for 5xx status codes.</span></span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>大多都是网络请求细节的代码，重要代码在HttpStack.performRequest(request, headers)中<br>然而这个方法里就是网络请求的具体实现了，有时间再解析吧，其实也没啥好解析的<br>另外Request类中有个方法会解析返回的NetworkResponse<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>最后来看看回调怎么实现的吧<br>ResponseDelivery是个接口，实现类为ExexuterDelivery</p>
<h4 id="ExexuterDelivery"><a href="#ExexuterDelivery" class="headerlink" title="ExexuterDelivery"></a>ExexuterDelivery</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">     request.markDelivered();</span><br><span class="line">     request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">     mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// If this request has canceled, finish it and don't deliver.</span></span><br><span class="line">          <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">              mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Deliver a normal response or error, depending.</span></span><br><span class="line">          <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">              mRequest.deliverResponse(mResponse.result);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mRequest.deliverError(mResponse.error);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">          <span class="comment">// and the request can be finished.</span></span><br><span class="line">          <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">              mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></span><br><span class="line">          <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mRunnable.run();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到通过deliverResponse或者deliverError把结果发送到ui线程。<br>然后看下本地缓存怎么实现的</p>
<h4 id="DiskBasedCache类"><a href="#DiskBasedCache类" class="headerlink" title="DiskBasedCache类"></a>DiskBasedCache类</h4><p>由于缓存是写到本地文件夹的，所以缓存空间不能无限制增大<br>解决方法就要看下面这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pruneIfNeeded</span><span class="params">(<span class="keyword">int</span> neededSpace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">            VolleyLog.v(<span class="string">"Pruning old cache entries."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> before = mTotalSize;</span><br><span class="line">        <span class="keyword">int</span> prunedFiles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();</span><br><span class="line">            CacheHeader e = entry.getValue();</span><br><span class="line">            <span class="keyword">boolean</span> deleted = getFileForKey(e.key).delete();</span><br><span class="line">            <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">                mTotalSize -= e.size;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               VolleyLog.d(<span class="string">"Could not delete cache entry for key=%s, filename=%s"</span>,</span><br><span class="line">                       e.key, getFilenameForKey(e.key));</span><br><span class="line">            &#125;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            prunedFiles++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">            VolleyLog.v(<span class="string">"pruned %d files, %d bytes, %d ms"</span>,</span><br><span class="line">                    prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中mMaxCacheSizeInBytes是构造方法传入的一个缓存文件夹的大小，如果不传默认是5M的大小。<br>通过这个方法可以发现，每当被调用时会传入一个neededSpace，也就是需要申请的磁盘大小(即要新缓存的那个文件所需大小)。首先会判断如果这个neededSpace申请成功以后是否会超过最大可用容量，如果会超过，则通过遍历本地已经保存的缓存文件的header(header中包含了缓存文件的缓存有效期、占用大小等信息)去删除文件，直到可用容量不大于声明的缓存文件夹的大小。<br><strong>Volley缓存命中率的优化</strong><br>如果让你去设计Volley的缓存功能，你要如何增大它的命中率。<br>还是上面的代码，在缓存内容可能超过缓存文件夹的大小时，删除的逻辑是直接遍历header删除。这个时候删除的文件有可能是我们上一次请求时刚刚保存下来的，屁股都还没坐稳呢，现在立即删掉，有点舍不得啊。<br>如果遍历的时候，判断一下，首先删除超过缓存有效期的(过期缓存)，其次按照LRU算法，删除最久未使用的，岂不是更合适？<br><strong>Volley缓存文件名的计算</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getFilenameForKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstHalfLength = key.length() / <span class="number">2</span>;</span><br><span class="line">        String localFilename = String.valueOf(key.substring(<span class="number">0</span>, firstHalfLength).hashCode());</span><br><span class="line">        localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());</span><br><span class="line">        <span class="keyword">return</span> localFilename;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>把key分成两部分分别求hash值再把它们拼接起来，为了防止文件名冲突。<br>下面的总结出自<a href="http://blog.csdn.net/yanbober/article/details/45307217" target="_blank" rel="noopener">工匠若水的博文</a><br>当一个RequestQueue被成功申请后会开启一个CacheDispatcher和4个默认的NetworkDispatcher。<br>1.CacheDispatcher缓存调度器最为第一层缓冲，开始工作后阻塞的从缓存序列mCacheQueue中取得请求；对于已经取消的请求，标记为跳过并结束这个请求；新的或者过期的请求，直接放入mNetworkQueue中由N个NetworkDispatcher进行处理；已获得缓存信息（网络应答）却没有过期的请求，由Request的parseNetworkResponse进行解析，从而确定此应答是否成功。然后将请求和应答交由Delivery分发者进行处理，如果需要更新缓存那么该请求还会被放入mNetworkQueue中。<br>2.将请求Request add到RequestQueue后对于不需要缓存的请求（需要额外设置，默认是需要缓存）直接丢入mNetworkQueue交给N个NetworkDispatcher处理；对于需要缓存的，新的请求加到mCacheQueue中给CacheDispatcher处理；需要缓存，但是缓存列表中已经存在了相同URL的请求，放在mWaitingQueue中做暂时处理，等待之前请求完毕后，再重新添加到mCacheQueue中。<br>3.网络请求调度器NetworkDispatcher作为网络请求真实发生的地方，对消息交给BasicNetwork进行处理，同样的，请求和结果都交由Delivery分发者进行处理。<br>4.Delivery分发者实际上已经是对网络请求处理的最后一层了，在Delivery对请求处理之前，Request已经对网络应答进行过解析，此时应答成功与否已经设定；而后Delivery根据请求所获得的应答情况做不同处理；若应答成功，则触发deliverResponse方法，最终会触发开发者为Request设定的Listener；若应答失败，则触发deliverError方法，最终会触发开发者为Request设定的ErrorListener；处理完后，一个Request的生命周期就结束了，Delivery会调用Request的finish操作，将其从mRequestQueue中移除，与此同时，如果等待列表中存在相同URL的请求，则会将剩余的层级请求全部丢入mCacheQueue交由CacheDispatcher进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/10/计算机网络-传输层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/10/计算机网络-传输层/" itemprop="url">
                  计算机网络-传输层之流量控制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T10:27:00+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/10/计算机网络-传输层/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/10/计算机网络-传输层/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="套接字地址"><a href="#套接字地址" class="headerlink" title="套接字地址"></a>套接字地址</h5><p>一个IP和一个端口号结合起来称为一个套接字地址<br>我们使用传输层需要一对套接字地址<br>这四条信息时网络层分组头部和传输层分组头部的组成部分</p>
<h4 id="封装与解封装"><a href="#封装与解封装" class="headerlink" title="封装与解封装"></a>封装与解封装</h4><p>传输层负责封装与解封装报文<br>传输层的分组称为用户数据报</p>
<h5 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h5><p>一个实体从一个以上的源接收到数据项时称为多路复用<br>一个实体将数据项传递到一个以上的源时称为多路分解</p>
<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p><strong>(重点，面试考到过，典型的生产者消费者模型)</strong><br>当一个实体创建数据项并有另一个实体消耗它们时，就存在生产效率和消费效率的平衡问题。如果数据项生产比消费快，那么消费者可能被淹没并且可能要丢弃一些数据项。如果数据项生产者比消费者慢，那么消费者必须等待，系统变的低效。<br><strong>push or pull</strong><br>生产者传递数据项到消费者有两种方式：推或拉。<br>每当发送方生产数据项时，它无需事前获得消费者的请求就会发送它们—这种传递称为push<br>如果生产者在消费者请求这些数据项之后进行发送，这种传递称为pull<br><strong>传输层流量控制</strong><br>传输层通信中，我们需要处理四个实体：发送端进程、发送方传输层、接收方传输层、接收方进程<br>发送方进程仅仅是一个生产者，它生产报文块，并把它们推到传输层。<br>发送方传输层有两个作用：既是生产者也是消费者，消费生产者推送的报文，传递到接收方传输层<br>接收方传输层也有两个作用：消费从发送方那里接受来的分组，也是生产者，解封装报文传递到接收方应用层<br>接收方<br>我们至少需要两种流量控制：从发送方传输层到发送方应用层的流量控制和从接收方传输层到发送方传输层的流量控制<br><strong>缓冲区</strong><br>通常使用两个缓冲区：一个位于发送方传输层，一个位于接收方传输层。<br>缓冲区是一组内存单元<br>当发送端传输层的缓冲区已满，他就通知应用层停止传输报文块：当有空闲位置时，它通知应用层可以再次传输报文块<br>当接收方传输层的缓冲区已满，他就通知发送方停止传输分组；当有空闲位置时，它通知发送方传输层可以再次传输分组</p>
<h5 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h5><p>网络层不可靠，可靠性通过传输层的差错控制实现，复杂以下几个方面：<br>1.发现并对其被破坏的分组<br>2.记录丢失和丢弃的分组并重传它们<br>3.识别重复分组并丢弃它们<br>4.缓冲失序分组直到丢失的分组到达<br><strong>序号</strong><br>传输层要直到哪个分组是失序的<br>需要在传输层分组中加入一个字段来保存分组的序号<br>一般要设置一个界限。如允许m个比特位，序号范围是0到2</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/09/深入理解Java虚拟机-垃圾收集器及内存分配策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/深入理解Java虚拟机-垃圾收集器及内存分配策略/" itemprop="url">
                  深入理解Java虚拟机-垃圾收集器及内存分配策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T01:02:30+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/09/深入理解Java虚拟机-垃圾收集器及内存分配策略/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/09/深入理解Java虚拟机-垃圾收集器及内存分配策略/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Java内存运行时其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生随线程而灭，这几个区域不需要过多考虑回收的问题，随着方法结束或者线程结束时，内存自然跟着回收了。而Java堆和方法区则不一样</p>
<h4 id="对象是否存活"><a href="#对象是否存活" class="headerlink" title="对象是否存活"></a>对象是否存活</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对象添加一个引用计数器，每当有地方引用它时，计数器值就加1，当引用失效时，计数器就减一，然和时刻计数器为0的对象就是不可能再被使用的。<br>在COM、FlasherPlayer、Python和Squirrel都使用了引用计数算法进行内存管理。<br>但它难以解决对象之间相互循环引用的问题</p>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为七点，从这个节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GCRoots没有任何引用链相联，就证明这个对象是不可用的<br>Java中，可作为GC Roots的对象包括以下几种：<br>虚拟机栈中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中JNI引用的对象</p>
<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引 用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。<br>软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。SoftReference类来实现软引用。<br>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的 对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。WeakReference类来实现弱引用。<br>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。PhantomReference类来实现虚引用。</p>
<h5 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h5><p>在可达性分析算法不可达的对象，到真正宣告一个对象的死亡，至少经历两个标记过程。<br>1.没有引用链时，它会被第一次标记并且进行一个筛选，筛选的条件式此对象是否有必要执行finalize方法，当对象没有覆盖finalize方法或者finalize已经被虚拟机调用过，虚拟机将这两种情况都视为没必要执行。如果被判定有必要执行finalize方法，那么这个对象会被放在一个F-Quene队列之中，稍后由一个虚拟机自动建立的Finalizer线程去出发这个方法<br>2.GC对F-Quene中的对象进行小规模的标记，如果这个对象重新和引用链上的对象建立关联，在这次标记时它会被移除即将回收的集合<br><strong>尽量避免使用finalize()方法</strong></p>
<h5 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h5><p>很多人认为方法区（Hotspot中的永久代）是没有垃圾回收的，java虚拟机规范中可以不要求虚拟机在方法区实现垃圾回收<br>在方法区中进行垃圾收集的性价比比较低：在堆中，尤其是新生代中，常规的应用一次垃圾收集一般可以回收70%~95%的空间，而永久带的垃圾回收效率远低于此<br>永久代的垃圾收集包括两方面内容，废弃常量和无用的类<br>回收废弃常量与回收java堆中的对象类似<br>判断一个类是否是无用的类要同时满足以下条件<br>1.该类的所有实例已经被回收，Java堆中不存在该类的任何实例<br>2.加载该类的ClassLoader已经被回收<br>3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类<br>因此在大量使用反射，动态代理，CGLib等BiteCode框架、动态生成JSP以及OSGi这类自定义ClassLoader的场景都需要虚拟机具备类写在的功能，以保证永久代不会溢出</p>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h5><p>算法分为标记，清除两个阶段<br>首先标记出所有需要回收的对象。<br>在标记完成后同一回收所有被标记的对象<br>存在两个缺点：<br>1.标记和清除两个过程的效率都不高<br>2.标记清除之后会产生大量不连续的内存碎片</p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>将内存分为一块较大的Eden和两块较小的的Survivor空间，每次使用Eden和其中一块Survivor.当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过地Survivor空间，HotSpot虚拟机默认Eden和Survivor地大小比例时8：1，也就是每次新生代中可用内存空间为整个新生代容量地90%，但没有办法保证每次回收都只有不多于10%地对象存活，当Survivor空间不够用时，需要依赖其他内存进行分配担保</p>
<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>复制收集算法在对象存活率较高时要进行较多地复制操作，效率会变低。老年代一般不能选用这种算法<br>标记过程与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>根据对象存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代<br>在新生代中每次回收有大量的对象死去，只是有少量存活，那就选用复制算法<br>而老年代中因为对象存活率高，没有额外空间对它进行分配担保，一般采用标记清理或者标记整理进行回收</p>
<h4 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h4><h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>可作为GC Root的节点主要在全局性引用与执行上下文中<br>HotSpot的实现中，使用一组称为OopMap的数据结构来检查完所有执行上下文和全局的引用位置，在类加载完成的时，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来。</p>
<h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>在OopMap的协助下，HotSpot可以快速且准确完成GC Roots的枚举，但可能呆滞引用关系的变化，每一条指令都生成对应的OopMap,将会产生大量的额外空间，其实只是在特定的位置记录了这些信息，这些位置称为安全点，只有到达安全点程序才能停下来开始GC<br><strong>如何在GC发生时让所有线程跑到安全点再停顿下来</strong><br>1.抢先式中断<br>在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上则回复线程<br>2.主动式中断<br>当GC需要中断线程的时候，不直接对线程操作，仅仅简单设置一个标志，各个线程区轮询这个标志，发现这个标志为真时就自己中断挂起</p>
<h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>程序不执行的时候，线程无法响应JVM的中断请求，JVM也不可能等待线程重新分配CPU时间，这个时候需要安全区域来解决，安全区域指一段代码片段中，引用关系不会发生改变。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p><img src="http://omjy3y3o5.bkt.clouddn.com/5b7d3e81526a432463060c3ff33fb3ba.png" alt="serial"></p>
<h5 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h5><h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p><img src="http://omjy3y3o5.bkt.clouddn.com/05b2deb63abf84ea964f4e9030fe03ef.png" alt="parNew"></p>
<h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p><img src="http://omjy3y3o5.bkt.clouddn.com/5d242a8b2a4b0655399c2bd43773483f.png" alt="parsca"></p>
<h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p><img src="http://omjy3y3o5.bkt.clouddn.com/65051ed2fda5ee89b46695be1c36fd76.png" alt="cms"></p>
<h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p><strong>未完待续</strong></p>
<p><strong>后面的由于忘记保存所以笔记遗失</strong><br><strong>另外博客集成七牛图床终于可以发图片</strong><br><strong>qiniu-uploader插件bug花了好长时间，附上解决方案：</strong><br><a href="https://github.com/qiniu/nodejs-sdk.v6/pull/206/commits/19f5dc7909a6b1e30ead24535a1875615bf68791#diff-7247aa230f67062fd963dadb9bdecaa7L45" target="_blank" rel="noopener">https://github.com/qiniu/nodejs-sdk.v6/pull/206/commits/19f5dc7909a6b1e30ead24535a1875615bf68791#diff-7247aa230f67062fd963dadb9bdecaa7L45</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/08/关于String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/关于String/" itemprop="url">
                  关于String
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T22:21:34+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/08/关于String/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/08/关于String/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-String类"><a href="#1-String类" class="headerlink" title="1.String类"></a>1.String类</h4><p>String类被final所修饰，String对象是不可变量，String实现了Serializable，Comparable，CharSequence，CharSequence接口。</p>
<h4 id="2-String属性"><a href="#2-String属性" class="headerlink" title="2.String属性"></a>2.String属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br></pre></td></tr></table></figure>
<p>String类中包含了一个不可变的char数组来存放字符串，一个int型的变量hash来存放计算后的哈希值</p>
<h4 id="3-String构造函数"><a href="#3-String构造函数" class="headerlink" title="3.String构造函数"></a>3.String构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不含参数的构造函数，一般没什么用，因为value是不可变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数为String类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数为char数组，使用java.utils包中的Arrays类复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从bytes数组中的offset位置开始，将长度为length的字节，以charsetName格式编码，拷贝到value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用public String(byte bytes[], int offset, int length, String charsetName)构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length, charsetName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-String常用方法"><a href="#4-String常用方法" class="headerlink" title="4.String常用方法"></a>4.String常用方法</h4><h5 id="1-equals"><a href="#1-equals" class="headerlink" title="1.equals"></a>1.equals</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>先比较是不是同一个对象，再判断是不是String数据类型，把String转成char数组之后判断数组的长度是否相等，然后从后往前单个判断char，都相等则返回true</p>
<h5 id="2-hashCode"><a href="#2-hashCode" class="headerlink" title="2.hashCode"></a>2.hashCode</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>hashcode计算方法是s[0]_31^(n-1) + s[1]_31^(n-2) + … + s[n-1]</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>String是不可变类型，返回类型为String的String方法每次返回都是新的String<br>对象<br>String的三种比较方式：<br>内存比较：直接对比两个引用所指向的内存值，精确间接直接明了<br>equals字符串值比较，比较两个引用所指对象字面值是否相等<br>hashCode字符串数值化比较：两个hashCode相同，不保证内存相同，不保证字面值相同。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2017/03/08/关于使用Hexo-Github搭建技术博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/关于使用Hexo-Github搭建技术博客/" itemprop="url">
                  关于使用Hexo+Github搭建技术博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T17:21:49+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/08/关于使用Hexo-Github搭建技术博客/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/08/关于使用Hexo-Github搭建技术博客/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h4><h4 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h4><h4 id="3-安装配置hexo"><a href="#3-安装配置hexo" class="headerlink" title="3.安装配置hexo"></a>3.安装配置hexo</h4><p>下载安装hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>初始化博客</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个博客文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字</span><br><span class="line"><span class="meta">$</span> hexo init &lt;folder&gt;</span><br><span class="line">// 进入博客文件夹，&lt;folder&gt;为文件夹的名称</span><br><span class="line"><span class="meta">$</span> cd &lt;folder&gt;</span><br><span class="line">// node.js的命令，根据博客既定的dependencies配置安装所有的依赖包</span><br><span class="line"><span class="meta">$</span> npm install</span><br></pre></td></tr></table></figure>
<h4 id="4-配置博客"><a href="#4-配置博客" class="headerlink" title="4.配置博客"></a>4.配置博客</h4><p>在_config.yml中配置，主要修改以下几条</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.网站相关信息</span></span><br><span class="line">title: inerdstack</span><br><span class="line">subtitle: the stack <span class="keyword">of</span> it nerds</span><br><span class="line">description: start <span class="keyword">from</span> zero</span><br><span class="line">author: inerdstack</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br><span class="line"><span class="comment">//2.配置个人域名</span></span><br><span class="line">url: http:<span class="comment">//blog.andeper.cn</span></span><br><span class="line"><span class="comment">//3.配置部署</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:hc944822354/hc944822354.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h4 id="5-Github"><a href="#5-Github" class="headerlink" title="5.Github"></a>5.Github</h4><p>注册github账号</p>
<p>建立Repository</p>
<p>建立与用户名相对应的仓库，仓库名为your_user_name.github.io，主要是为了映射到github.io的个人域名上</p>
<p>在_config.yml中配置repo地址</p>
<p>然后执行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h4 id="6-发布及部署"><a href="#6-发布及部署" class="headerlink" title="6.发布及部署"></a>6.发布及部署</h4><p>发布到本地服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>在<a href="http://0.0.0.0:4000即可看到自己的博客" target="_blank" rel="noopener">http://0.0.0.0:4000即可看到自己的博客</a></p>
<p>清除生成的文件及缓存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>生成静态文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>部署到远程服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<h4 id="7-报错及解决"><a href="#7-报错及解决" class="headerlink" title="7.报错及解决"></a>7.报错及解决</h4><p><strong>ERROR Deployer not found: git</strong></p>
<p><strong>解决方法</strong>： <strong>npm install hexo-deployer-git —save</strong></p>
<h4 id="8-绑定域名到博客"><a href="#8-绑定域名到博客" class="headerlink" title="8.绑定域名到博客"></a>8.绑定域名到博客</h4><p>在github的repository的setting中Custom domain中输入你要绑定的域名，save之后Github会在项目中自动生成CNAME文件，然后在云解析中解析这个域名就好了。</p>
<p>然而每次部署博客CNAME文件都会消失，导致域名不能访问，因此要把这个文件放在本地source文件夹下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/update/avatar.jpg"
               alt="Andeper" />
          <p class="site-author-name" itemprop="name">Andeper</p>
           
              <p class="site-description motion-element" itemprop="description">欢迎来到我的技术博客</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/tags/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andeper</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"andeper"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.0"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  

</body>
</html>
