<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="框架解析," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="本文基本出自BlackSwift的简书OkHttp是一个高效的Http客户端，有如下的特点：  支持HTTP2/SPDY黑科技 socket自动选择最好路线，并支持自动重连 拥有自动维护的socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING） 基于Headers的缓存策略  主要对象Connections">
<meta name="keywords" content="框架解析">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp框架解析">
<meta property="og:url" content="http://ndeper.cn/2017/03/11/OkHttp框架解析/index.html">
<meta property="og:site_name" content="Andeper的个人博客">
<meta property="og:description" content="本文基本出自BlackSwift的简书OkHttp是一个高效的Http客户端，有如下的特点：  支持HTTP2/SPDY黑科技 socket自动选择最好路线，并支持自动重连 拥有自动维护的socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING） 基于Headers的缓存策略  主要对象Connections">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omjy3y3o5.bkt.clouddn.com/a150a71fea0f337dea91ba2ae1a209b9.png">
<meta property="og:image" content="http://omjy3y3o5.bkt.clouddn.com/78357eee1a7414813f7a1777729fd198.png">
<meta property="og:updated_time" content="2017-03-30T02:09:54.158Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OkHttp框架解析">
<meta name="twitter:description" content="本文基本出自BlackSwift的简书OkHttp是一个高效的Http客户端，有如下的特点：  支持HTTP2/SPDY黑科技 socket自动选择最好路线，并支持自动重连 拥有自动维护的socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING） 基于Headers的缓存策略  主要对象Connections">
<meta name="twitter:image" content="http://omjy3y3o5.bkt.clouddn.com/a150a71fea0f337dea91ba2ae1a209b9.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ndeper.cn/2017/03/11/OkHttp框架解析/"/>





  <title> OkHttp框架解析 | Andeper的个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
<script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '',
      xfbml      : true,
      version    : 'v2.6'
    });
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "//connect.facebook.net/zh_Hans/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>




	<div id="vk_api_transport"></div>
	<script type="text/javascript">
		window.vkAsyncInit = function() {
			VK.init({
				apiId: 
			});

			
				VK.Widgets.Like("vk_like", {type: "mini", height: 20});
			

			
				VK.Widgets.Comments("vk_comments", {limit: 10, attach: "*"});
			
		};
		setTimeout(function() {
			var el = document.createElement("script");
			el.type = "text/javascript";
			el.src = "//vk.com/js/api/openapi.js";
			el.async = true;
			document.getElementById("vk_api_transport").appendChild(el);
		}, 0);
	</script>





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8aabc26c969f399d0abe524a29699f13";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Andeper的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ndeper.cn/2017/03/11/OkHttp框架解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                OkHttp框架解析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T20:29:00+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架解析/" itemprop="url" rel="index">
                    <span itemprop="name">框架解析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/11/OkHttp框架解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/11/OkHttp框架解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文基本出自<a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="noopener">BlackSwift的简书</a><br>OkHttp是一个高效的Http客户端，有如下的特点：</p>
<ol>
<li>支持HTTP2/SPDY黑科技</li>
<li>socket自动选择最好路线，并支持自动重连</li>
<li>拥有自动维护的socket连接池，减少握手次数</li>
<li>拥有队列线程池，轻松写并发</li>
<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）</li>
<li>基于Headers的缓存策略</li>
</ol>
<h4 id="主要对象"><a href="#主要对象" class="headerlink" title="主要对象"></a>主要对象</h4><p>Connections: 对JDK中的socket进行了引用计数封装，用来控制socket连接<br>Streams: 维护HTTP的流，用来对Requset/Response进行IO操作<br>Calls: HTTP请求任务封装<br>StreamAllocation: 用来控制Connections/Streams的资源分配与释放</p>
<h4 id="工作流程概述"><a href="#工作流程概述" class="headerlink" title="工作流程概述"></a>工作流程概述</h4><p>当我们用OkHttpClient.newCall(request)进行execute/enenqueue时，实际是将请求Call放到了Dispatcher中，okhttp使用Dispatcher进行线程分发，它有两种方法，一个是普通的同步单线程；另一种是使用了队列进行并发任务的分发(Dispatch)与回调，我们下面主要分析第二种，也就是队列这种情况，这也是okhttp能够竞争过其它库的核心功能之一</p>
<h4 id="Dispatcher结构"><a href="#Dispatcher结构" class="headerlink" title="Dispatcher结构"></a>Dispatcher结构</h4><p>Dispatcher维护了如下变量，用于控制并发的请求</p>
<h6 id="maxRequests-64-最大并发请求数为64"><a href="#maxRequests-64-最大并发请求数为64" class="headerlink" title="maxRequests = 64: 最大并发请求数为64"></a>maxRequests = 64: 最大并发请求数为64</h6><h6 id="maxRequestsPerHost-5-每个主机最大请求数为5"><a href="#maxRequestsPerHost-5-每个主机最大请求数为5" class="headerlink" title="maxRequestsPerHost = 5: 每个主机最大请求数为5"></a>maxRequestsPerHost = 5: 每个主机最大请求数为5</h6><h6 id="Dispatcher-分发者，也就是生产者（默认在主线程）"><a href="#Dispatcher-分发者，也就是生产者（默认在主线程）" class="headerlink" title="Dispatcher: 分发者，也就是生产者（默认在主线程）"></a>Dispatcher: 分发者，也就是生产者（默认在主线程）</h6><h6 id="AsyncCall-队列中需要处理的Runnable（包装了异步回调接口）"><a href="#AsyncCall-队列中需要处理的Runnable（包装了异步回调接口）" class="headerlink" title="AsyncCall: 队列中需要处理的Runnable（包装了异步回调接口）"></a>AsyncCall: 队列中需要处理的Runnable（包装了异步回调接口）</h6><h6 id="ExecutorService：消费者池（也就是线程池）"><a href="#ExecutorService：消费者池（也就是线程池）" class="headerlink" title="ExecutorService：消费者池（也就是线程池）"></a>ExecutorService：消费者池（也就是线程池）</h6><h6 id="Deque：缓存（用数组实现，可自动扩容，无大小限制）"><a href="#Deque：缓存（用数组实现，可自动扩容，无大小限制）" class="headerlink" title="Deque：缓存（用数组实现，可自动扩容，无大小限制）"></a>Deque<readyasynccalls>：缓存（用数组实现，可自动扩容，无大小限制）</readyasynccalls></h6><h6 id="Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存"><a href="#Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存" class="headerlink" title="Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存"></a>Deque<runningasynccalls>：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存</runningasynccalls></h6><p>在下面的的代码中我们能看到线程池的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<h6 id="int-corePoolSize-最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。"><a href="#int-corePoolSize-最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。" class="headerlink" title="int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。"></a>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。</h6><h6 id="int-maximumPoolSize-最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理"><a href="#int-maximumPoolSize-最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理" class="headerlink" title="int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理"></a>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</h6><h6 id="long-keepAliveTime-当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive"><a href="#long-keepAliveTime-当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive" class="headerlink" title="long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive"></a>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</h6><h6 id="TimeUnit-unit-时间单位，一般用秒"><a href="#TimeUnit-unit-时间单位，一般用秒" class="headerlink" title="TimeUnit unit: 时间单位，一般用秒"></a>TimeUnit unit: 时间单位，一般用秒</h6><h6 id="BlockingQueue-workQueue-工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。"><a href="#BlockingQueue-workQueue-工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。" class="headerlink" title="BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。"></a>BlockingQueue<runnable> workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。</runnable></h6><h6 id="ThreadFactory-threadFactory-单个线程的工厂，可以打Log，设置Daemon-即当JVM退出时，线程自动结束-等"><a href="#ThreadFactory-threadFactory-单个线程的工厂，可以打Log，设置Daemon-即当JVM退出时，线程自动结束-等" class="headerlink" title="ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等"></a>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</h6><h5 id="反向代理模式"><a href="#反向代理模式" class="headerlink" title="反向代理模式"></a>反向代理模式</h5><p>在Nginx中，用户通过Http访问前置的服务器，服务器也会添加Header并自动转发请求给后端集群，接着返回数据结果给用户。通过将工作分配给多个后台服务器并共享Session，可以提高服务的负载均衡，实现<strong>非阻塞、高可用、高并发连接</strong>。<br>在OkHttp中，使用Dispatcher作为任务的派发器，线程池对应多台后置服务器，用AsyncCall对应Socket请求，用Deque<readyasynccalls>对应Socket内部缓存<br><img src="http://omjy3y3o5.bkt.clouddn.com/a150a71fea0f337dea91ba2ae1a209b9.png" alt="Dispatcher"><br>当我们用OkHttp的异步请求时，实际上是Dispather进行了入队操作</readyasynccalls></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果正在进行的异步操作小于最大并发请求数并且请求某个主机的请求书小雨每个主机最大请求数<br>那么把请求添加到正在运行的任务队列<br>否则添加到缓存队列</p>
<p>当任务执行完之后，会在finally代码块中调用Dispatcher的finish函数，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!runningAsyncCalls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"AsyncCall wasn't running!"</span>);</span><br><span class="line">    promoteCalls();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        i.remove();</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的作用在一个任务完成之后，把缓存等待区的最后一个移动到运行区中并执行</p>
<h4 id="Socket管理-StreamAllocation"><a href="#Socket管理-StreamAllocation" class="headerlink" title="Socket管理(StreamAllocation)"></a>Socket管理(StreamAllocation)</h4><p>经过上一步的分配，我们现在需要进行连接了。我们目前有封装好的Request，而进行HTTP连接需要进行Socket握手，Socket握手的前提是根据域名或代理确定Socket的ip与端口。这个环节主要讲了http的握手过程与连接池的管理，分析的对象主要是StreamAllocation</p>
<h5 id="选择路线与自动重连-RouteSelector"><a href="#选择路线与自动重连-RouteSelector" class="headerlink" title="选择路线与自动重连(RouteSelector)"></a>选择路线与自动重连(RouteSelector)</h5><p>此步骤用于获取socket的ip与端口,各位请欣赏源码中next()的迷之缩进与递归，代码进行了如下事情：<br>如果Proxy为null:<br>在构造函数中设置代理为Proxy.NO_PROXY<br>如果缓存中的lastInetSocketAddress为空，就通过DNS（默认是Dns.SYSTEM，包装了jdk自带的lookup函数）查询，并保存结果，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源<br>如果还没有查询到就递归调用next查询，直到查到为止<br>一切next都没有枚举到，抛出NoSuchElementException，退出(这个几乎见不到)<br>如果Proxy为HTTP&#x3A;<br>设置socket的ip为代理地址的ip<br>设置socket的端口为代理地址的端口<br>一切next都没有枚举到，抛出NoSuchElementException，退出<br>HTTP代理是不安全的，本文附录有介绍<br>HTTP代理会帮你在远程服务器进行DNS查询<br>至于socket代理这里就不分析了，它已经不属于应用层了</p>
<h5 id="连接socket链路-RealConnection"><a href="#连接socket链路-RealConnection" class="headerlink" title="连接socket链路(RealConnection)"></a>连接socket链路(RealConnection)</h5><p>当地址，端口准备好了，就可以进行TCP连接了（也就是我们常说的TCP三次握手），步骤如下：</p>
<p>如果连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步<br>根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手<br>将建立成功的RealConnection放入(put)连接池缓存<br>如果存在TLS，就根据SSL版本与证书进行安全握手<br>构造HttpStream并维护刚刚的socket连接，管道建立完成</p>
<h5 id="释放socket链路-release"><a href="#释放socket链路-release" class="headerlink" title="释放socket链路(release)"></a>释放socket链路(release)</h5><p>如果不再需要（比如通信完成，连接失败等）此链路后，释放连接（也就是TCP断开的握手）<br>尝试从缓存的连接池中删除(remove)<br>如果没有命中缓存,就直接调用jdk的socket关闭</p>
<h4 id="复用连接池"><a href="#复用连接池" class="headerlink" title="复用连接池"></a>复用连接池</h4><p>在进行http连接时，首先进行tcp握手，然后传输数据，最后释放，但是在复杂的网络中，创建Socket需要进行三次五首，释放socket需要2次握手或者4次，在http中有一种叫做keeplive connection的机制，它可以在传输数据后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手<br>Okhttp支持5个并发的keepAlive,默认链路生命为5分钟。</p>
<h5 id="keepAlive的缺点"><a href="#keepAlive的缺点" class="headerlink" title="keepAlive的缺点"></a>keepAlive的缺点</h5><p>1.根据TCP的拥塞机制，当总水管大小固定时，如果存在大量空闲的keepalive connections（我们可以称作僵尸连接或者泄漏连接），其它客户端们的正常连接速度也会受到影响，这也是运营商为何限制P2P连接数的道理<br>2.服务器/防火墙上有并发限制，比如apache服务器对每个请求都开线程，导致只支持150个并发连接（数据来源于nginx官网），不过这个瓶颈随着高并发server软硬件的发展（golang/分布式/IO多路复用）将会越来越少<br>3.大量的DDOS产生的僵尸连接可能被用于恶意攻击服务器，耗尽资源</p>
<h5 id="连接池关键对象"><a href="#连接池关键对象" class="headerlink" title="连接池关键对象"></a>连接池关键对象</h5><h6 id="Call-对http的请求封装，属于程序员能够接触的上层高级代码"><a href="#Call-对http的请求封装，属于程序员能够接触的上层高级代码" class="headerlink" title="Call: 对http的请求封装，属于程序员能够接触的上层高级代码"></a>Call: 对http的请求封装，属于程序员能够接触的上层高级代码</h6><h6 id="Connection-对jdk的socket物理连接的包装，它内部有List-lt-WeakReference-gt-的引用"><a href="#Connection-对jdk的socket物理连接的包装，它内部有List-lt-WeakReference-gt-的引用" class="headerlink" title="Connection: 对jdk的socket物理连接的包装，它内部有List&lt;WeakReference&gt;的引用"></a>Connection: 对jdk的socket物理连接的包装，它内部有List&lt;WeakReference<streamallocation>&gt;的引用</streamallocation></h6><h6 id="StreamAllocation-表示Connection被上层高级代码的引用次数"><a href="#StreamAllocation-表示Connection被上层高级代码的引用次数" class="headerlink" title="StreamAllocation: 表示Connection被上层高级代码的引用次数"></a>StreamAllocation: 表示Connection被上层高级代码的引用次数</h6><h6 id="ConnectionPool-Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计"><a href="#ConnectionPool-Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计" class="headerlink" title="ConnectionPool: Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计"></a>ConnectionPool: Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计</h6><h6 id="Deque-Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础"><a href="#Deque-Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础" class="headerlink" title="Deque: Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础"></a>Deque: Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础</h6><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><p>在源码中，我们先找ConnectionPool实例化的位置，它是直接new出来的，而它的各种操作却在OkHttpClient的static区实现了Internal.instance接口作为ConnectionPool的包装。<br>至于为什么需要这么多此一举的分层包装，主要是为了让外部包的成员访问非public方法</p>
<h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><p>1.连接池内部维护了一个叫做OkHttp ConnectionPool的ThreadPool，专门用来淘汰末位的socket，当满足以下条件时，就会进行末位淘汰，非常像GC<br>并发socket空闲连接超过5个<br>某个socket的keepalive时间大于5分钟<br>2.维护着一个Deque<connection>，提供get/put/remove等数据结构的功能<br>3.维护着一个RouteDatabase，它用来记录连接失败的Route的黑名单，当连接失败的时候就会把失败的线路加进去（本文不讨论）</connection></p>
<h5 id="put-get操作"><a href="#put-get操作" class="headerlink" title="put/get操作"></a>put/get操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从连接池中获取</span></span><br><span class="line"><span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (connection.allocations.size() &lt; connection.allocationLimit</span><br><span class="line">          &amp;&amp; address.equals(connection.route().address)</span><br><span class="line">          &amp;&amp; !connection.noNewStreams) &#123;</span><br><span class="line">        streamAllocation.acquire(connection);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//放入连接池</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">      cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">      executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    connections.add(connection);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//线程变的空闲，并调用清理线程池</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">connectionBecameIdle</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (connection.noNewStreams || maxIdleConnections == <span class="number">0</span>) &#123;</span><br><span class="line">      connections.remove(connection);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      notifyAll(); <span class="comment">// Awake the cleanup thread: we may have exceeded the idle connection limit.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>随着上述操作被更高级的对象调用，Connection中的StreamAllocation被不断的aquire与release，也就是List&lt;WeakReference<streamallocation>&gt;的大小将时刻变化</streamallocation></p>
<h5 id="Connection自动回收的实现"><a href="#Connection自动回收的实现" class="headerlink" title="Connection自动回收的实现"></a>Connection自动回收的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">//遍历Deque所有的RealConnection，标记遗漏的连接</span></span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line">        <span class="comment">// 查询此连接内部StreamAllocation引用的数量</span></span><br><span class="line">        <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idleConnectionCount++;</span><br><span class="line">        <span class="comment">//标记出空闲的连接</span></span><br><span class="line">        <span class="comment">// If the connection is ready to be evicted, we're done.</span></span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">          <span class="comment">//如果(`空闲socket连接超过5个`</span></span><br><span class="line">          <span class="comment">//且`keepalive时间大于5分钟`)</span></span><br><span class="line">          <span class="comment">//就将此泄漏连接从`Deque`中移除</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//返回此连接即将到期的时间，供下次清理</span></span><br><span class="line">        <span class="comment">//这里依据是在上文`connectionBecameIdle`中设定的计时</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 全都是活跃的连接</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有任何连接，跳出循环</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>找到不活跃连接的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似于引用计数法，如果引用全部为空，返回立刻清理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//虚引用列表</span></span><br><span class="line">    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">      <span class="comment">//遍历弱引用列表</span></span><br><span class="line">      Reference&lt;StreamAllocation&gt; reference = references.get(i);</span><br><span class="line">      <span class="comment">//如果正在被使用，跳过，接着循环</span></span><br><span class="line">      <span class="comment">//是否置空是在上文`connectionBecameIdle`的`release`控制的</span></span><br><span class="line">      <span class="keyword">if</span> (reference.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//非常明显的引用计数</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// We've discovered a leaked allocation. This is an application bug.</span></span><br><span class="line">      Platform.get().log(WARN, <span class="string">"A connection to "</span> + connection.route().address().url()</span><br><span class="line">          + <span class="string">" was leaked. Did you forget to close a response body?"</span>, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//否则移除引用</span></span><br><span class="line">      references.remove(i);</span><br><span class="line">      connection.noNewStreams = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//如果所有分配的流均没了，标记为已经距离现在空闲了5分钟</span></span><br><span class="line">      <span class="comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span></span><br><span class="line">      <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">        connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> references.size();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过判断弱引用是是否为null来判断这个连接是否遗漏</p>
<p>根据生产者消费者模型的模型理论，当入队(enqueue)请求时，如果满足(runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行。如果消费者缓存满了，就放入readyAsyncCalls进行缓存等待。<br>当任务执行完成后,调用finished的promoteCalls()函数，手动移动缓存区（可以看出这里是主动清理的，因此不会发生死锁）</p>
<h4 id="HTTP请求序列化-反序列化"><a href="#HTTP请求序列化-反序列化" class="headerlink" title="HTTP请求序列化/反序列化"></a>HTTP请求序列化/反序列化</h4><p>本段主要分析从拼装HTTP套接字到读取的步骤，用垠神的话说，就是实现了一个Parser。分析的对象是HttpStream接口，在HTTP/1.1下是Http1xStream实现的</p>
<h5 id="获取Http流-HttpStream"><a href="#获取Http流-HttpStream" class="headerlink" title="获取Http流(HttpStream)"></a>获取Http流(HttpStream)</h5><p>我们已经在上文的RealConnection通过connectSocket构造HttpStream对象并建立套接字连接<br>在connect()有非常重要的一步，它通过okio库和远程socket建立了I/O连接，为了更好的理解，我们可以把它看成管道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//source 用于获取response</span></span><br><span class="line">source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line"><span class="comment">//sink 用于write buffer 到server</span></span><br><span class="line">sink = Okio.buffer(Okio.sink(rawSocket));</span><br></pre></td></tr></table></figure>
<p>Okhttp的I/O使用的是Okio库，它是java中最好用的I/O API，本人曾经写NFC对这个用的就非常顺手。<br>Buffer: Buffer是可变字节，类似于byte[]，相当于传输介质<br>source: source是okio库中的输入组件，类似于inputstream，经常在下载中用到。它的重要方法是read(Buffer sink, long byteCount)，从流中读取数据。<br>Sink: sink是okio库中的io输出组件，类似于outputstream，经常用于写到file/Socket，它的最重要方法是void write(Buffer source, long byteCount)，写数据到Buffer中<br>如果把连接看成管道，-&gt;为管道的方向，如下图，这里借鉴了go语言的描述</p>
<h5 id="拼装Raw请求与Headers-writeRequestHeaders"><a href="#拼装Raw请求与Headers-writeRequestHeaders" class="headerlink" title="拼装Raw请求与Headers(writeRequestHeaders)"></a>拼装Raw请求与Headers(writeRequestHeaders)</h5><p>我们通过Request.Builder构建了简陋的请求后，可能需要进行一些修饰，这时需要使用Interceptors对Request进行进一步的拼装了。<br>拦截器是okhttp中强大的流程装置，它可以用来监控log，修改请求，修改结果，甚至是对用户透明的GZIP压缩。类似于脚本语言中的map操作。在okhttp中，内部维护了一个Interceptors的List，通过InterceptorChain进行多次拦截修改操作。<br>请求的代码如下，详细代码在这里，源代码中是自增递归(recursive)调用Chain.process()，直到interceptors().size()中的拦截器全部调用完。这里代码维护性估计看着头大，大神们以后可能把它改成for等更简单的循环，主要做了两件事：<br>1.递归调用Interceptors，依次入栈对response进行处理<br>2.当全部递归出栈完成后，移交给网络模块(getResponse)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &lt; client.interceptors().size()) &#123;</span><br><span class="line"></span><br><span class="line">   Interceptor.Chain chain = <span class="keyword">new</span> ApplicationInterceptorChain(index + <span class="number">1</span>, request, forWebSocket);</span><br><span class="line">   Interceptor interceptor = client.interceptors().get(index);</span><br><span class="line">   <span class="comment">//递归调用Chain.process()</span></span><br><span class="line">   Response interceptedResponse = interceptor.intercept(chain);</span><br><span class="line">   <span class="keyword">if</span> (interceptedResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"application interceptor "</span> + interceptor</span><br><span class="line">         + <span class="string">" returned null"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> interceptedResponse;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// No more interceptors. Do HTTP.</span></span><br><span class="line"> <span class="keyword">return</span> getResponse(request, forWebSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是正式的网络请求getResponse()，此步骤通过http协议规范将对象中的数据信息序列化为Raw文本：<br>1.在okhttp中，通过RequestLine，Requst，HttpEngine，Header等参数进行序列化操作，也就是拼装参数为socketRaw数据。拼装方法也比较暴力，直接按照RFC协议要求的格式进行concat输出就实现了<br>2.通过sink写入write到socket连接。</p>
<h5 id="获得响应-readResponseHeaders-Body"><a href="#获得响应-readResponseHeaders-Body" class="headerlink" title="获得响应(readResponseHeaders/Body)"></a>获得响应(readResponseHeaders/Body)</h5><p>此步骤根据获取到的Socket纯文本，解析为Response对象，我们可以看成是一个反序列化（通过http协议将Raw文本转成对象）的过程：</p>
<p>拦截器的设计:<br>1.自定义网络拦截器请求进行递归入栈<br>2.在自定义网络拦截器的intercept中，调用NetworkInterceptorChain的proceed(request),进行真正的网络请求(readNetworkResponse)<br>3.接自定义请求递归出栈<br>网络读取(readNetworkResponse)分析:<br>1.读取Raw的第一行，并反序列化为StatusLine对象<br>2.以Transfer-Encoding: chunked的模式传输并组装Body<br>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(RawData &lt;- RemoteChannel(www.xx.com, <span class="number">80</span>))<span class="comment">//读取远程的Raw</span></span><br><span class="line">    map(<span class="function">func <span class="title">NetworkInterceptorChains</span><span class="params">()</span>)<span class="comment">//预处理</span></span></span><br><span class="line"><span class="function">    <span class="comment">//这里的source引用了HttpEngine，并重写了read方法</span></span></span><br><span class="line"><span class="function">    .<span class="title">map</span><span class="params">(func getTransferStream()</span></span>&#123;&#125;)</span><br><span class="line">    <span class="comment">//根据source拼装body对象</span></span><br><span class="line">    .map(<span class="function">func <span class="title">RealResponseBody</span><span class="params">()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>接下来进行释放socket连接，上文已经介绍过了。现在我们就获得到response对象，可以进行进一步的Gson等操作了。</p>
<h4 id="Http缓存基本知识"><a href="#Http缓存基本知识" class="headerlink" title="Http缓存基本知识"></a>Http缓存基本知识</h4><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>表示到期时间，一般用在response报文中，当超过此事件后响应将被认为是无效的而需要网络连接，反之而是直接使用缓存</p>
<h6 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h6><p>相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。</p>
<h6 id="修订文件名-Reving-Filenames"><a href="#修订文件名-Reving-Filenames" class="headerlink" title="修订文件名(Reving Filenames)"></a>修订文件名(Reving Filenames)</h6><p>如果我们通过设置header保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？我们这时可以通过修改url中的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery</p>
<h6 id="条件GET请求-Conditional-GET-Requests-与304"><a href="#条件GET请求-Conditional-GET-Requests-与304" class="headerlink" title="条件GET请求(Conditional GET Requests)与304"></a>条件GET请求(Conditional GET Requests)与304</h6><p>如缓存果过期或者强制放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送条件get请求即可，如果缓存是有效的，则返回304 Not Modifiled，否则直接返回body。<br>请求的方式有两种：<br>4.1. Last-Modified-Date:<br>客户端第一次网络请求时，服务器返回了<br>Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT<br>客户端再次请求时，通过发送<br>If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT<br>交给服务器进行判断，如果仍然可以缓存使用，服务器就返回304<br>4.2. ETag<br>ETag是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一请求时，服务器返回了<br>ETag: “5694c7ef-24dc”<br>客户端再次请求时，通过发送<br>If-None-Match:”5694c7ef-24dc”<br>交给服务器进行判断，如果仍然可以缓存使用，服务器就返回304<br>如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。</p>
<h6 id="其它标签"><a href="#其它标签" class="headerlink" title="其它标签"></a>其它标签</h6><p>no-cache/no-store: 不使用缓存，no-cache指令的目的是防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令的话，表示客户端将不会接受缓存过的相应，于是缓存服务器必须把客户端请求转发给源服务器。服务器端返回的相应中包含no-cache指令的话那么缓存服务器不能对资源进行缓存。<br>only-if-cached: 只使用缓存<br>Date: The date and time that the message was sent<br>Age: The Age response-header field conveys the sender’s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. 说人话就是CDN反代服务器到原始服务器获取数据延时的缓存时间<br><img src="http://omjy3y3o5.bkt.clouddn.com/78357eee1a7414813f7a1777729fd198.png" alt="缓存"></p>
<h4 id="缓存源码"><a href="#缓存源码" class="headerlink" title="缓存源码"></a>缓存源码</h4><p>OkHttp中使用了CacheStrategy实现了上文的流程图，它根据之前的缓存结果与当前将要发送Request的header进行策略分析，并得出是否进行请求的结论。<br>Request:<br>开发者手动编写并在Interceptor中递归加工而成的对象（如果读者需要调试分析的话，可以用logging-interceptor进行log操作），我们只需要知道了目前传入的Request中并没有任何关于缓存的Header<br>cacheCandidate:<br>也就是上次与服务器交互缓存的Response，可能为null。这里的缓存全部是基于文件系统的Map，key是请求中url的md5，value是在文件中查询到的缓存，页面置换基于LRU算法，我们现在只需要知道它是一个可以读取缓存Header的Response即可。<br>当被CacheStrategy加工输出后，输出networkRequest与cacheResponse，根据是否为空执行不同的请求</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th style="text-align:center">cacheResponse</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td style="text-align:center">null</td>
<td>only-if-cached(表明不进行网络请求，且缓存不存在或者过期，一定会返回503错误)</td>
</tr>
<tr>
<td>null</td>
<td style="text-align:center">non-null</td>
<td>不进行网络请求，而且缓存可以使用，直接返回缓存，不用请求网络</td>
</tr>
<tr>
<td>non-null</td>
<td style="text-align:center">null</td>
<td>需要进行网络请求，而且缓存不存在或者过期，直接访问网络</td>
</tr>
<tr>
<td>non-null</td>
<td style="text-align:center">non-null</td>
<td>Header中含有ETag/Last-Modified标签，需要在条件请求下使用，还是需要访问网络</td>
</tr>
</tbody>
</table>
<p>CacheStrategy使用Factory模式进行构造，参数如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InternalCache responseCache = Internal.instance.internalCache(client);</span><br><span class="line"><span class="comment">//cacheCandidate从disklurcache中获取</span></span><br><span class="line"><span class="comment">//request的url被md5序列化为key,进行缓存查询</span></span><br><span class="line">Response cacheCandidate = responseCache != <span class="keyword">null</span> ? responseCache.get(request) : <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//请求与缓存</span></span><br><span class="line">factory = <span class="keyword">new</span> CacheStrategy.Factory(now, request, cacheCandidate);</span><br><span class="line">cacheStrategy = factory.get();</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">networkRequest = cacheStrategy.networkRequest;</span><br><span class="line">cacheResponse = cacheStrategy.cacheResponse;</span><br><span class="line"><span class="comment">//进行一大堆的if判断，内容同上表格</span></span><br></pre></td></tr></table></figure>
<p>可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果缓存没有命中(即null),网络请求也不需要加缓存Header了</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//`没有缓存的网络请求,查上文的表可知是直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果缓存的TLS握手信息丢失,返回进行直接连接</span></span><br><span class="line">  <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检测response的状态码,Expired时间,是否有no-cache标签</span></span><br><span class="line">  <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">    <span class="comment">//直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CacheControl requestCaching = request.cacheControl();</span><br><span class="line">  <span class="comment">//如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)</span></span><br><span class="line">  <span class="comment">//或者有ETag/Since标签(也就是条件GET请求)</span></span><br><span class="line">  <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">    <span class="comment">//直接连接,把缓存判断交给服务器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据RFC协议计算</span></span><br><span class="line">  <span class="comment">//计算当前age的时间戳</span></span><br><span class="line">  <span class="comment">//now - sent + age (s)</span></span><br><span class="line">  <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">  <span class="comment">//大部分情况服务器设置为max-age</span></span><br><span class="line">  <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//大部分情况下是取max-age</span></span><br><span class="line">    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//大部分情况下设置是0</span></span><br><span class="line">    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//ParseHeader中的缓存控制信息</span></span><br><span class="line">  CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">  <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//设置最大过期时间,一般设置为0</span></span><br><span class="line">    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缓存在过期时间内,可以使用</span></span><br><span class="line">  <span class="comment">//大部分情况下是进行如下判断</span></span><br><span class="line">  <span class="comment">//now - sent + age + 0 &lt; max-age + 0</span></span><br><span class="line">  <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">    <span class="comment">//返回上次的缓存</span></span><br><span class="line">    Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缓存失效, 如果有etag等信息</span></span><br><span class="line">  <span class="comment">//进行发送`conditional`请求,交给服务器处理</span></span><br><span class="line">  Request.Builder conditionalRequestBuilder = request.newBuilder();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionalRequestBuilder.header(<span class="string">"If-None-Match"</span>, etag);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionalRequestBuilder.header(<span class="string">"If-Modified-Since"</span>, lastModifiedString);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionalRequestBuilder.header(<span class="string">"If-Modified-Since"</span>, servedDateString);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//下面请求实质还说网络请求</span></span><br><span class="line">  Request conditionalRequest = conditionalRequestBuilder.build();</span><br><span class="line">  <span class="keyword">return</span> hasConditions(conditionalRequest) ? <span class="keyword">new</span> CacheStrategy(conditionalRequest,</span><br><span class="line">      cacheResponse) : <span class="keyword">new</span> CacheStrategy(conditionalRequest, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。<br>1.Okhttp的缓存是自动完成的，完全由服务器Header决定的，自己没有必要进行控制。网上热传的文章在Interceptor中手工添加缓存代码控制，它固然有用，但是属于Hack式的利用，违反了RFC文档标准，不建议使用，OkHttp的官方缓存控制在注释中。如果读者的需求是对象持久化，建议用文件储存或者数据库即可（比如realm）。<br>2.服务器的配置非常重要，如果你需要减小请求次数，建议直接找对接人员对max-age等头文件进行优化；服务器的时钟需要严格NTP同步<br>3.充分利用Idea的findUsage的功能，源码的各个跳转条件可以很快分析完成<br>4.使用CMD + Y可以快速预览某个函数，类似于forcetouch功能</p>
<h4 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h4><h5 id="缓存简介、"><a href="#缓存简介、" class="headerlink" title="缓存简介、"></a>缓存简介、</h5><p>缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，Redis数据库，都可以看作缓存。它有如下的特点：</p>
<p>1.缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。<br>2.需要实现排序依据，在java中，可以使用Comparable<t>作为排序的的接口<br>3.需要一种页面置换算法(page replacement algorithm)将旧页面去掉换成新的页面，如最久未使用算法（LFU）、先进先出算法（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等<br>4.在OkHttp中，使用FileSystem作为缓存载体（磁盘相对于网络的缓存），使用LRU作为页面置换算法（封装了LinkedHashMap）。</t></p>
<p>在LinkedHashMap中，除了Node&lt;K,V&gt;[] table，还维护着Entry&lt;K,V&gt; head,tail。当put元素后，调用下列回调函数对链表将元素移动到链尾以及清理旧的元素<br>在get元素时，如果设置accessOrder为true时，通过调用如下回调移动元素到链尾，这里特别强调移动，如果这个元素本身已经在链表中，那它将只会移动，而不是新建<br>综上，当你反复对元素进行get/put操作时，经常使用的元素会被移动到tail中，而长期不用的元素会被移动到head</p>
<p>最后迭代(Iterator)时，迭代是从旧元素迭代到新元素，这就是LRU的实现</p>
<p><strong>OkHttp中的关键对象如下：</strong><br>FileSystem: 使用Okio对File的封装，简化了IO操作<br>DiskLruCache.Editor: 添加了同步锁，并对FileSystem进行高度封装<br>DiskLruCache.Entry: 维护着key对应的多个文件<br>Cache.Entry: Responsejava对象与Okio流的序列化/反序列化类<br>DiskLruCache: 维护着文件的创建，清理，读取。内部有清理线程池，LinkedHashMap(也就是LruCache)<br>Cache: 被上级代码调用，提供透明的put/get操作，封装了缓存检查条件与DiskLruCache，开发者只用配置大小即可，不需要手动管理<br>Response/Requset: OkHttp的请求与回应</p>
<h5 id="文件初级封装-FileSystem"><a href="#文件初级封装-FileSystem" class="headerlink" title="文件初级封装(FileSystem)"></a>文件初级封装(FileSystem)</h5><p>众所周之，文件读写是流操作，是一大堆的令人头痛的try/cache操作，在OkHttp中设计了FileSystem.SYSTEM作为文件层的管理。通过用Okio库中的Source/Sink对File进行包装，而不用更为头痛的InputStream这类东西，使上层调用与管道操作一样简单。<br>File(低级操作，步骤繁琐) -&gt; Okio(封装) －&gt; FileSystem(友好工具类)</p>
<h5 id="文件高级封装-DiskLruCache-Entry-Editor-Snapshot"><a href="#文件高级封装-DiskLruCache-Entry-Editor-Snapshot" class="headerlink" title="文件高级封装(DiskLruCache.Entry/Editor/Snapshot)"></a>文件高级封装(DiskLruCache.Entry/Editor/Snapshot)</h5><p>本部分进行了如下的转换，进行了实际的put/get操作<br>FileSystem &lt;– DiskLruCache.Entry/Editor –&gt; source/sink(更少参数)<br>DiskLruCache.Entry针对每个请求的url对应的文件进行引用维护（而没有进行创建/读取等操作），它内部维护了2个File数组，一般来说每个url对应2～4个文件。 文件名命名规则是{md5(url)+ {0,1}}，后面的0或1，分别表示ENTRY_METADATA与ENTRY_BODY。<br>DiskLruCache.Editor对工具类FileSystem进行进一步的封装，它以DiskLruCache.Entry作为构造参数，通过操控Entry中维护的数组，对外暴露source/sink，为上层的java对象与文件的转换提供基于okio的流操作，我们可以通过对它的两个方法进行FindUsage查询获得OkHttp关于文件读写的全部场景</p>
<h5 id="序列化与反序列化-Cache-Entry"><a href="#序列化与反序列化-Cache-Entry" class="headerlink" title="序列化与反序列化(Cache.Entry)"></a>序列化与反序列化(Cache.Entry)</h5><p>文件存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变<br>Resonse(java对象) &lt;— Cache.Entry —&gt; source/sink(文件io)<br>代码部分不复杂，与上面的findusage位置相同，可以概括下：<br>如果信息本身就是二进制，就直接写到文件中；如果是文本信息，按照预设的格式写入即可。<br>至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。<br>注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象</p>
<h5 id="缓存的自动清理"><a href="#缓存的自动清理" class="headerlink" title="缓存的自动清理"></a>缓存的自动清理</h5><p>在DiskLruCache初始化时，将建立线程池，最少零个线程，最大一个线程，线程空闲可以活60s，线程名叫做”OkHttp DiskLruCache”，当JVM退出时，线程自动结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!initialized | closed) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// Nothing to do</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历LRU缓存(从旧到新进行遍历map),并删除文件</span></span><br><span class="line">        <span class="comment">//直到小于MaxSize为止</span></span><br><span class="line">        trimToSize();</span><br><span class="line">        <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">          rebuildJournal();</span><br><span class="line">          redundantOpCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>OkHttp通过对文件进行了多次封装，实现了非常简单的I/O操作<br>OkHttp通过对请求url进行md5实现了与文件的映射，实现写入，删除等操作<br>OkHttp内部维护着清理线程池，实现对缓存文件的自动清理</p>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h5><p>代理，也就是有个中间服务器帮助你访问不存在的网站，okhttp中使用jdk自带的代理</p>
<p>You —- Proxy —– Server<br>HTTP代理的本质是改Header信息，当你访问HTTP/HTTPS服务时，本质是明文向跳板发送如下raw，远程服务器帮你完成dns与请求操作，比如HTTPS请求源码就详细的解释了发送的内容是非加密的，下面是我实际抓包的内容</p>
<p>//HTTP 请求<br>GET HTTP&#x3A;//www.qq.com HTTP/1.1<br>//HTTPS 请求<br>CONNECT github.com:443 HTTP/1.1<br>上面的抓包过程，廉价的民用上网行为管理交换机就可以把你记录的一清二楚，所以慎用HTTP代理或者尽量使用HTTPS代理，它是“不安全”的。</p>
<h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>DNS也就是域名到ip的映射(mapping)操作，用户向DNS服务器的53端口发送udp包后，会返回域名对应的地址，当然发送udp的细节对用户是透明的，用户直接调用jdk就可以了。我们先试下Unix下的查询</p>
<p>$ host baidu.com<br>baidu.com has address 111.13.101.208<br>baidu.com has address 123.125.114.144<br>…..<br>在OkHttp中，提供了DNS接口，默认是使用Dns.SYSTEM，它包装了java原生socket包中的InetAddress.getAllByName(hostname)方法。</p>
<p>参考：DNSPod中HTTP DNS的实现</p>
<h5 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h5><p>OkHttp的最底层是Socket，而不是URLConnection，它通过Platform的Class.forName()反射获得当前Runtime使用的socket库，调用栈如下（了解即可）</p>
<p>okhttp//实现HTTP协议<br>    framwork//JRE，实现JDK中Socket封装<br>      jvm//JDK的实现，本质对libc标准库的native封装<br>        bionic//android下的libc标准库<br>          systemcall//用户态切换入内核<br>              kernel//实现下协议栈(L4,L3)与网络驱动(一般是L2,L1)<br>如果你想用蓝牙硬件中Socket的进行HTTP协议开发，尝试重写这个类。</p>
<p>另外，再说一句废话，自从Android4.4以来，URLConnection在fram的实现也是使用了okhttp</p>
<p>OkHttp支持非常多平台下的Socket库实现，包括Android, JettyBootPlatform等都是支持的，具体的平台支持可以看这里</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/框架解析/" rel="tag"># 框架解析</a>
          
        </div>
      

      
        
          <div class="social-like">
            
              <div class="vk_like">
                <span id="vk_like"></span>
              </div>
            

            
          </div>
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/11/Retrofit框架解析/" rel="next" title="Retrofit框架解析">
                <i class="fa fa-chevron-left"></i> Retrofit框架解析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/13/Android开发艺术探索-IPC机制/" rel="prev" title="Android开发艺术探索-IPC机制">
                Android开发艺术探索-IPC机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/03/11/OkHttp框架解析/"
           data-title="OkHttp框架解析" data-url="http://ndeper.cn/2017/03/11/OkHttp框架解析/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/update/avatar.jpg"
               alt="Andeper" />
          <p class="site-author-name" itemprop="name">Andeper</p>
           
              <p class="site-description motion-element" itemprop="description">欢迎来到我的技术博客</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要对象"><span class="nav-number">1.</span> <span class="nav-text">主要对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作流程概述"><span class="nav-number">2.</span> <span class="nav-text">工作流程概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dispatcher结构"><span class="nav-number">3.</span> <span class="nav-text">Dispatcher结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#maxRequests-64-最大并发请求数为64"><span class="nav-number">3.0.1.</span> <span class="nav-text">maxRequests = 64: 最大并发请求数为64</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#maxRequestsPerHost-5-每个主机最大请求数为5"><span class="nav-number">3.0.2.</span> <span class="nav-text">maxRequestsPerHost = 5: 每个主机最大请求数为5</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Dispatcher-分发者，也就是生产者（默认在主线程）"><span class="nav-number">3.0.3.</span> <span class="nav-text">Dispatcher: 分发者，也就是生产者（默认在主线程）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AsyncCall-队列中需要处理的Runnable（包装了异步回调接口）"><span class="nav-number">3.0.4.</span> <span class="nav-text">AsyncCall: 队列中需要处理的Runnable（包装了异步回调接口）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ExecutorService：消费者池（也就是线程池）"><span class="nav-number">3.0.5.</span> <span class="nav-text">ExecutorService：消费者池（也就是线程池）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Deque：缓存（用数组实现，可自动扩容，无大小限制）"><span class="nav-number">3.0.6.</span> <span class="nav-text">Deque：缓存（用数组实现，可自动扩容，无大小限制）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存"><span class="nav-number">3.0.7.</span> <span class="nav-text">Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#int-corePoolSize-最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。"><span class="nav-number">3.0.8.</span> <span class="nav-text">int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#int-maximumPoolSize-最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理"><span class="nav-number">3.0.9.</span> <span class="nav-text">int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#long-keepAliveTime-当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive"><span class="nav-number">3.0.10.</span> <span class="nav-text">long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TimeUnit-unit-时间单位，一般用秒"><span class="nav-number">3.0.11.</span> <span class="nav-text">TimeUnit unit: 时间单位，一般用秒</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#BlockingQueue-workQueue-工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。"><span class="nav-number">3.0.12.</span> <span class="nav-text">BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ThreadFactory-threadFactory-单个线程的工厂，可以打Log，设置Daemon-即当JVM退出时，线程自动结束-等"><span class="nav-number">3.0.13.</span> <span class="nav-text">ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反向代理模式"><span class="nav-number">3.1.</span> <span class="nav-text">反向代理模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket管理-StreamAllocation"><span class="nav-number">4.</span> <span class="nav-text">Socket管理(StreamAllocation)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#选择路线与自动重连-RouteSelector"><span class="nav-number">4.1.</span> <span class="nav-text">选择路线与自动重连(RouteSelector)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#连接socket链路-RealConnection"><span class="nav-number">4.2.</span> <span class="nav-text">连接socket链路(RealConnection)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#释放socket链路-release"><span class="nav-number">4.3.</span> <span class="nav-text">释放socket链路(release)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复用连接池"><span class="nav-number">5.</span> <span class="nav-text">复用连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#keepAlive的缺点"><span class="nav-number">5.1.</span> <span class="nav-text">keepAlive的缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#连接池关键对象"><span class="nav-number">5.2.</span> <span class="nav-text">连接池关键对象</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Call-对http的请求封装，属于程序员能够接触的上层高级代码"><span class="nav-number">5.2.1.</span> <span class="nav-text">Call: 对http的请求封装，属于程序员能够接触的上层高级代码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Connection-对jdk的socket物理连接的包装，它内部有List-lt-WeakReference-gt-的引用"><span class="nav-number">5.2.2.</span> <span class="nav-text">Connection: 对jdk的socket物理连接的包装，它内部有List&lt;WeakReference&gt;的引用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#StreamAllocation-表示Connection被上层高级代码的引用次数"><span class="nav-number">5.2.3.</span> <span class="nav-text">StreamAllocation: 表示Connection被上层高级代码的引用次数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ConnectionPool-Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计"><span class="nav-number">5.2.4.</span> <span class="nav-text">ConnectionPool: Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Deque-Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础"><span class="nav-number">5.2.5.</span> <span class="nav-text">Deque: Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例化"><span class="nav-number">5.3.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造"><span class="nav-number">5.4.</span> <span class="nav-text">构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#put-get操作"><span class="nav-number">5.5.</span> <span class="nav-text">put/get操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Connection自动回收的实现"><span class="nav-number">5.6.</span> <span class="nav-text">Connection自动回收的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP请求序列化-反序列化"><span class="nav-number">6.</span> <span class="nav-text">HTTP请求序列化/反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#获取Http流-HttpStream"><span class="nav-number">6.1.</span> <span class="nav-text">获取Http流(HttpStream)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拼装Raw请求与Headers-writeRequestHeaders"><span class="nav-number">6.2.</span> <span class="nav-text">拼装Raw请求与Headers(writeRequestHeaders)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获得响应-readResponseHeaders-Body"><span class="nav-number">6.3.</span> <span class="nav-text">获得响应(readResponseHeaders/Body)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Http缓存基本知识"><span class="nav-number">7.</span> <span class="nav-text">Http缓存基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Expires"><span class="nav-number">7.0.1.</span> <span class="nav-text">Expires</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Cache-Control"><span class="nav-number">7.0.2.</span> <span class="nav-text">Cache-Control</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#修订文件名-Reving-Filenames"><span class="nav-number">7.0.3.</span> <span class="nav-text">修订文件名(Reving Filenames)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#条件GET请求-Conditional-GET-Requests-与304"><span class="nav-number">7.0.4.</span> <span class="nav-text">条件GET请求(Conditional GET Requests)与304</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#其它标签"><span class="nav-number">7.0.5.</span> <span class="nav-text">其它标签</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存源码"><span class="nav-number">8.</span> <span class="nav-text">缓存源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件缓存"><span class="nav-number">9.</span> <span class="nav-text">文件缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存简介、"><span class="nav-number">9.1.</span> <span class="nav-text">缓存简介、</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件初级封装-FileSystem"><span class="nav-number">9.2.</span> <span class="nav-text">文件初级封装(FileSystem)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件高级封装-DiskLruCache-Entry-Editor-Snapshot"><span class="nav-number">9.3.</span> <span class="nav-text">文件高级封装(DiskLruCache.Entry/Editor/Snapshot)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#序列化与反序列化-Cache-Entry"><span class="nav-number">9.4.</span> <span class="nav-text">序列化与反序列化(Cache.Entry)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存的自动清理"><span class="nav-number">9.5.</span> <span class="nav-text">缓存的自动清理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#附录"><span class="nav-number">10.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Proxy"><span class="nav-number">10.1.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DNS"><span class="nav-number">10.2.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Platform"><span class="nav-number">10.3.</span> <span class="nav-text">Platform</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andeper</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"andeper"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.0"></script>



  

</body>
</html>
