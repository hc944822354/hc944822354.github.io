<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Andeper的个人博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="欢迎来到我的技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Andeper的个人博客">
<meta property="og:url" content="http://andeper.cn/index.html">
<meta property="og:site_name" content="Andeper的个人博客">
<meta property="og:description" content="欢迎来到我的技术博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Andeper的个人博客">
<meta name="twitter:description" content="欢迎来到我的技术博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://andeper.cn/"/>





  <title> Andeper的个人博客 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
<!-- hexo-inject:begin --><!-- hexo-inject:end --><script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '',
      xfbml      : true,
      version    : 'v2.6'
    });
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "//connect.facebook.net/zh_Hans/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>




	<div id="vk_api_transport"></div>
	<script type="text/javascript">
		window.vkAsyncInit = function() {
			VK.init({
				apiId: 
			});

			

			
		};
		setTimeout(function() {
			var el = document.createElement("script");
			el.type = "text/javascript";
			el.src = "//vk.com/js/api/openapi.js";
			el.async = true;
			document.getElementById("vk_api_transport").appendChild(el);
		}, 0);
	</script>





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8aabc26c969f399d0abe524a29699f13";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Andeper的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2019/04/03/文献摘要之Short-Text-Clustering-via-Convolutional-Neural-Networks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/03/文献摘要之Short-Text-Clustering-via-Convolutional-Neural-Networks/" itemprop="url">
                  文献摘要之Short-Text-Clustering-via-Convolutional-Neural-Networks
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-03T20:37:31+08:00">
                2019-04-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/03/文献摘要之Short-Text-Clustering-via-Convolutional-Neural-Networks/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/03/文献摘要之Short-Text-Clustering-via-Convolutional-Neural-Networks/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Short Text Clustering via Convolutional Neural Networks</p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Short text clustering has become an increasing important task with the popularity of social media, and it is a challenging problem due to its sparseness of text representation. In this paper, we propose a Short Text Clustering via Convolutional neural networks (abbr. to STCC), which is more beneficial for clustering by considering one constraint on learned features through a self-taught learning framework without using any external tags/labels. First, we embed the original keyword features into compact binary codes with a localitypreserving constraint. Then, word embeddings are explored and fed into convolutional neural networks to learn deep feature representations, with the output units fitting the pre-trained binary code in the training process. After obtaining the learned representations, we use K-means to cluster them. Our extensive experimental study on two public short text datasets shows that the deep feature representation learned by our approach can achieve a significantly better performance than some other existing features, such as term frequency-inverse document frequency, Laplacian eigenvectors and average embedding, for clustering.<br>随着社交媒体的普及，短文本聚类已成为一项日益重要的任务，由于其文本表示的稀疏性，它是一个具有挑战性的问题。在本文中，我们通过卷积神经网络（简称STCC）提出了一种短文本聚类，通过自学习学习框架考虑学习特征的一个约束而不使用任何外部标签/标签，这对聚类更有利。首先，我们将原始关键字特征嵌入到具有局部保持约束的紧凑二进制代码中。然后，探索单词嵌入并将其馈入卷积神经网络以学习深度特征表示，其中输出单元在训练过程中拟合预训练的二进制代码。在获得学习的表示后，我们使用K-means来聚类它们。我们对两个公共短文本数据集的广泛实验研究表明，通过我们的方法学习的深度特征表示可以实现比其他一些现有特征明显更好的性能，例如术语频率 - 逆文档频率，拉普拉斯特征向量和平均嵌入，用于聚类。</p>
<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><p>Different from the normal text clustering, short text clustering has the problem of sparsity(Aggarwal and Zhai, 2012). Most words only occur once in each short text, as a result, the term frequencyinverse document frequency (TF-IDF) measure cannot work well in the short text setting. In order to address this problem, some researchers work on expanding and enriching the context of data from Wikipedia (Banerjee et al., 2007) or an ontology (Fodeh et al., 2011). However, these methods involve solid natural language processing (NLP) knowledge and still use high-dimensional representation which may result in a waste of both memory and computation time. Another way to overcome these issues is to explore some sophisticated models to cluster short texts. For example, Yin and Wang (2014) proposed a Dirichlet multinomial mixture model-based approach for short text clustering and Cai et al. (2005) clustered texts using Locality Preserving Indexing (LPI) algorithm. Yet how to design an effective model is an open question, and most of these methods directly trained based on bagof-words (BoW) are shallow structures which cannot preserve the accurate semantic similarities.<br>与普通文本聚类不同，短文本聚类具有稀疏性问题（Aggarwal和Zhai，2012）。大多数单词仅在每个短文本中出现一次，因此，术语频率反向文档频率（TF-IDF）度量在短文本设置中不能很好地起作用。为了解决这个问题，一些研究人员致力于扩展和丰富维基百科（Banerjee等，2007）或本体论（Fodeh等，2011）的数据背景。然而，这些方法涉及固体自然语言处理（NLP）知识并且仍然使用高维表示，这可能导致浪费存储器和计算时间。克服这些问题的另一种方法是探索一些复杂的模型来聚类短文本。例如，Yin和Wang（2014）提出了一种基于Dirichlet多项式混合模型的短文本聚类方法和Cai等人。 （2005）使用局部保持索引（LPI）算法的聚类文本。然而，如何设计一个有效的模型是一个悬而未决的问题，而且大多数基于bagof-words（BoW）直接训练的方法都是浅层结构，不能保持准确的语义相似性。<br>With the recent revival of interest in Deep Neural Network (DNN), many researchers have concentrated on using Deep Learning to learn features. Hinton and Salakhutdinov (2006) use deep auto encoder (DAE) to learn text representation from raw text representation. Recently, with the help of word embedding, neural networks demonstrate their great performance in terms of constructing text representation, such as Recursive Neural Network (RecNN) (Socher et al., 2011; Socher et al., 2013) and Recurrent Neural Network (RNN) (Mikolov et al.,2011). However, RecNN exhibits high time complexity to construct the textual tree, and RNN, using the layer computed at the last word to represent the text, is a biased model (Lai et al., 2015). More recently, Convolution Neural Network (CNN), applying convolutional filters to capture local features, has achieved a better performance in many NLP applications, such as sentence modeling (Blunsom et al.,2014), relation classification (Zeng et al., 2014), and other traditional NLP tasks (Collobert et al., 2011).Most of the previous works focus CNN on solving supervised NLP tasks, while in this paper we aim to explore the power of CNN on one unsupervised NLP task, short text clustering.<br>随着最近人们对深度神经网络（DNN）兴趣的兴起，许多研究人员将注意力集中在使用深度学习来学习特征。 Hinton和Salakhutdinov（2006）使用深度自动编码器（DAE）来学习原始文本表示的文本表示。最近，在文字嵌入的帮助下，神经网络在构建文本表示方面表现出了很好的表现，如递归神经网络（RecNN）（Socher等，2011; Socher等，2013）和递归神经网络（ RNN）（Mikolov等，2011）。然而，RecNN表现出构建文本树的高时间复杂度，并且使用在最后一个词处计算的层来表示文本的RNN是偏向模型（Lai等人，2015）。最近，卷积神经网络（CNN）应用卷积滤波器捕获局部特征，在许多NLP应用中取得了更好的性能，例如句子建模（Blunsom等，2014），关系分类（Zeng et al。，2014） ）和其他传统的NLP任务（Collobert等，2011）。以前的大部分工作都集中在CNN上解决有监督的NLP任务，而在本文中我们的目的是探讨CNN在一个无监督的NLP任务，短文本聚类上的力量。 。<br><img src="/2019/04/03/文献摘要之Short-Text-Clustering-via-Convolutional-Neural-Networks/TIM图片20190403220837.png" alt="figure1"><br>To address the above challenges, we systematically introduce a short text clustering method via convolutional neural networks. An overall architecture of the proposed method is illustrated in Figure 1. Given a short text collection X, the goal of this work is to cluster these texts into clusters C based on the deep feature representation h learned from CNN models. In order to train the CNN models, we,inspired by (Zhang et al., 2010), utilize a self-taught learning framework in our work. In particular, we first embed the original features into compact binary code B with a locality-preserving constraint. Then word vectors S projected from word embeddings are fed into a CNN model to learn the feature representation h and the output units are used to fit the pretrained binary code B. After obtaining the learned features, traditional K-means algorithm is employed to cluster texts into clusters C. The main contributions of this paper are summarized as follows:<br>1). To the best of our knowledge, this is the first attempt to explore the feasibility and effectiveness of combining CNN and traditional semantic constraint, with the help of word embedding to solve one unsupervised learning task, short text clustering.<br>2). We learn deep feature representations with locality-preserving constraint through a self-taught learning framework, and our approach do not use any external tags/labels or complicated NLP preprocessing.<br>3). We conduct experiments on two short text datasets. The experimental results demonstrate that the proposed method achieves excellent performance in terms of both accuracy and normalized mutual information.The remainder of this paper is organized as follows: In Section 2, we first describe the proposed approach STCC and implementation details. Experimental results and analyses are presented in Section 3. In Section 4, we briefly survey several related works. Finally, conclusions are given in the last Section.<br>为了解决上述挑战，我们通过卷积神经网络系统地引入了一种短文本聚类方法。图1中示出了所提出方法的总体结构。给定短文本集X，该工作的目标是基于从CNN模型学习的深度特征表示将这些文本聚类成聚类C.为了训练CNN模型，我们受到（Zhang et al。，2010）的启发，在我们的工作中使用自学的学习框架。特别是，我们首先将原始特征嵌入到具有局部性保留约束的紧凑二进制代码B中。然后将从字嵌入投射的字向量S馈入CNN模型以学习特征表示h，并且使用输出单元来拟合预训练的二进制码B.在获得学习的特征之后，使用传统的K均值算法来对文本进行聚类。本文的主要贡献概括如下：<br>1）。据我们所知，这是首次尝试探索CNN与传统语义约束相结合的可行性和有效性，借助于单词嵌入来解决一个无监督学习任务，即短文本聚类。<br>2）。我们通过自学的学习框架学习具有局部性保留约束的深度特征表示，并且我们的方法不使用任何外部标签/标签或复杂的NLP预处理。<br>3）。我们对两个短文本数据集进行了实验。实验结果表明，该方法在准确性和规范化互信息方面均取得了良好的性能。本文的其余部分安排如下：第2节，我们首先描述了提出的方法STCC和实现细节。实验结果和分析见第3节。在第4节中，我们简要地调查了几个相关的工作。最后，最后一节给出了结论。</p>
<h3 id="2-Methodology"><a href="#2-Methodology" class="headerlink" title="2 Methodology"></a>2 Methodology</h3><h4 id="2-1-Convolutional-Neural-Networks"><a href="#2-1-Convolutional-Neural-Networks" class="headerlink" title="2.1 Convolutional Neural Networks"></a>2.1 Convolutional Neural Networks</h4><p><img src="/2019/04/03/文献摘要之Short-Text-Clustering-via-Convolutional-Neural-Networks/TIM图片20190403220922.png" alt="figure2"><br>In this section, we will briefly review one popular deep convolutional neural network, Dynamic Convolutional Neural Network (DCNN) (Blunsom et al., 2014), which is the foundation of our proposed method.<br>Taking a neural network with two convolutional layers in Figure 2 as an example, the network transforms raw input text to a powerful representation.Particularly, let $X = \{x_i:x_i \in \mathbb{R}^{d\times1} \}_{i=1,2,\cdots,n}$ denote the set of input $n$ texts, where $d$ is the dimensionality of the original keyword features. Each raw text vector $x_i$ is projected into a matrix representation $S \in \mathbb{R}^{d_w\times s}$ by looking up a word embedding E, where $d_w$ is the dimension of word embedding features and $s$ is the length of one text. We also let $\tilde W = \{W_i\}_{i=1,2}$ and $W_O$ denote the weights of the neural networks. The network defines a transformation $f(\cdot):\mathbb R^{d\times1}\to \mathbb R^{r\times1}(d\gg r)$ which transforms an raw input text $x$ to a r-dimensional deep representation h. There are three basic operations described as follows:<br><strong>– Wide one-dimensional convolution</strong> This operation is applied to an individual row of the sentence matrix $S\in \mathbb R^{d_w\times s}$, and yields a set of sequences $C_i\in \mathbb R^{s+m-1}$where $m$ is the width of convolutional filter.<br><strong>– Folding</strong> In this operation, every two rows in a feature map component-wise are simply summed.For a map of $d_w$ rows, folding returns a map of $d_w/2$ rows, thus halving the size of the representation.<br><strong>– Dymantic k-max pooling</strong> Given a fixed pooling parameter ktop for the topmost convolutional layer, the parameter k of k-max pooling in the l-th convolutional layer can be computed as follows:<script type="math/tex">k_l = max(k_{top},\left \lceil \frac{L-l}{L} \right \rceil)</script><br>where L is the total number of convolutional layers in the network.<br>在本节中，我们将简要回顾一种流行的深度卷积神经网络 - 动态卷积神经网络(DCNN) (Blunsom et al., 2014)，这是我们提出的方法的基础。<br>以图2中带有两个卷积层的神经网络为例，网络将原始输入文本转换为强大的表示。特别是，让$X = \{x_i:x_i \in \mathbb{R}^{d\times1} \}_{i=1,2,\cdots,n}$表示输入$n$ 个文本的集合，其中$d$是原始关键字要素的维度。通过查找嵌入E的单词，将每个原始文本向量$x_i$投影到矩阵表示$S \in \mathbb{R}^{d_w\times s}$中，其中$d_w$是单词嵌入要素的维度$s$是一个文本的长度。我们还让$\tilde W = \{W_i\}_{i=1,2}$和$W_O$表示神经网络的权重。网络定义转换$f(\cdot):\mathbb R^{d\times1}\to \mathbb R^{r\times1}(d\gg r)$将原始输入文本$x$转换为r维深度表示h。有三种基本操作描述如下：</p>
<ul>
<li>宽一维卷积 此操作适用于句子矩阵 $S\in \mathbb R^{d_w\times s}$的单个行，并产生一组序列$C_i\in \mathbb R^{s+m-1}$where $m$其中$m$是卷积滤波器的宽度。</li>
<li>折叠在此操作中，特征映射中的每两行都是简单求和的。对于$d_w$ rows的映射，folding返回$d_w/2$ rows的映射，从而将表示的大小减半。</li>
<li>Dymantic k-max pooling给定最顶层卷积层的固定池参数ktop，第l个卷积层中k-max池的参数k可以如下计算：<script type="math/tex">k_l = max(k_{top},\left \lceil \frac{L-l}{L} \right \rceil)</script><br>其中L是网络中卷积层的总数。<h4 id="2-2-Locality-preserving-Constraint"><a href="#2-2-Locality-preserving-Constraint" class="headerlink" title="2.2 Locality-preserving Constraint"></a>2.2 Locality-preserving Constraint</h4>Here, we first pre-train binary code B based on the keyword features with a locality-preserving constraint, and choose Laplacian affinity loss, also used in some previous works (Weiss et al., 2009; Zhang et al., 2010). The optimization can be written as:<script type="math/tex">\min_B\sum_{i,j=1}^nS_{ij}\left \| b_i-b_j \right \|_F^2   s.t.B\in\{-1,1\}^{n\times q},B^T1=0,B^TB=I</script><br>where $S_{ij}$ is the pairwise similarity between texts $x_i$ and $x_j$ , and $\left | \cdot \right |_F$ is the Frobenius norm. The problem is relaxed by discarding $B \in \{-1, 1\}^{n\times q}$, and the q-dimensional real-valued vectors $\tilde B$ can be learned from Laplacian Eigenmap. Then, we get the binary code B via the media vector $median(\tilde B)$. In particular, we construct the $n\times n$ local similarity matrix $S$ by using heat kernel as follows:<script type="math/tex">S_{ij}=\left\{\begin{matrix}exp(-\frac{\left \| x_i-x_j \right \|^2}{2\sigma^2}),&if\,x_i\in N_k(x_j)or\,vice\,versa \\0,&otherwise\end{matrix}\right.</script><br>where,$\sigma$is a tuning parameter (default is 1) and $N_k(x)$ represents the set of k-nearest-neighbors of x.The last layer of CNN is an output layer as follows:<script type="math/tex">O = W_Oh, (4)</script>where $h$ is the deep feature representation, $o\in \mathbb R^q$ is the output vector and $W_O\in \mathbb R^{q\times r}$is weight matrix. In order to fit the pre-trained binary code B, we apply q logistic operations to the output vector O as follows:<script type="math/tex">p_i=\frac{exp(O_i)}{1+exp(O_i)}(5)</script><br>在这里，我们首先基于具有局部性保留约束的关键字特征预先训练二进制代码B，并选择拉普拉斯亲和力损失，也用于先前的一些工作中(Weiss et al., 2009; Zhang et al., 2010)。优化可写为：<script type="math/tex">\min_B\sum_{i,j=1}^nS_{ij}\left \| b_i-b_j \right \|_F^2   s.t.B\in\{-1,1\}^{n\times q},B^T1=0,B^TB=I</script><br>其中$S_{ij}$是文本$x_i$和$x_j$之间的成对相似性,$\left | \cdot \right |_F$是Frobenius规范。通过丢弃$B \in \{-1, 1\}^{n\times q}$来放宽问题，并且可以从拉普拉斯算子图中学习q维实值向量$\tilde B$。然后，我们通过媒体向量$median(\tilde B)$得到二进制代码B.特别是，我们使用热内核构造$n\times n$局部相似性矩阵$S$，如下所示：<script type="math/tex">S_{ij}=\left\{\begin{matrix}exp(-\frac{\left \| x_i-x_j \right \|^2}{2\sigma^2}),&if\,x_i\in N_k(x_j)or\,vice\,versa \\0,&otherwise\end{matrix}\right.</script><br>其中，$ \sigma $是一个调整参数（默认为1），$N_k(x)$表示x的k-最近邻居的集合.CNN的最后一层是输出层，如下所示：<script type="math/tex">O =W_Oh(4)</script>其中$ h $是深度特征表示，$o\in \mathbb R^q$是输出向量而$W_O\in \mathbb R^{q\times r}$是权重矩阵。为了拟合预先训练的二进制代码B，我们将q逻辑运算应用于输出向量O，如下所示：<script type="math/tex">p_i=\frac{exp(O_i)}{1+exp(O_i)}(5)</script><h4 id="2-3-Learning"><a href="#2-3-Learning" class="headerlink" title="2.3 Learning"></a>2.3 Learning</h4>All of the parameters to be trained are defined as $\theta$.<script type="math/tex; mode=display">\theta=\{E,\tilde W,W_O\}(6)$$Given the training text collection X, and the pretrained binary code B, the log likelihood of the parameters can be written down as follows:$$J(\theta)=\sum_{i=1}^nlogp(b_i|x_i,\theta)(6)</script>Following the previous work (Blunsom et al.,2014), we train the network with mini-batches by back-propagation and perform the gradient-based optimization using the Adagrad update rule (Duchi et al., 2011). For regularization, we employ dropout with 50% rate to the penultimate layer (Blunsom et al., 2014; Kim, 2014).<br>所有要训练的参数都定义为$\theta$。<script type="math/tex; mode=display">\theta=\{E,\tilde W,W_O\}(6)$$给定训练文本集合X和预训练二进制代码B，参数的对数似然可以写成如下：$$J(\theta)=\sum_{i=1}^nlogp(b_i|x_i,\theta)(6)</script>在之前的工作(Blunsom et al.,2014)之后，我们通过反向传播对小批量网络进行训练，并使用Adagrad更新规则执行基于梯度的优化(Duchi et al., 2011)。 对于正则化，我们使用50％率的退出率到倒数第二层(Blunsom et al., 2014; Kim, 2014)<h4 id="2-4-K-means-for-Clustering"><a href="#2-4-K-means-for-Clustering" class="headerlink" title="2.4 K-means for Clustering"></a>2.4 K-means for Clustering</h4>With the given short texts, we first utilize the trained deep neural network to obtain the semantic representations h, and then employ traditional K-means algorithm to perform clustering.<br>利用给定的短文本，我们首先利用训练好的深度神经网络获得语义表示h，然后采用传统的K-means算法进行聚类。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2019/04/01/文献摘要之Semi-supervised-Clustering-for-Short-Text-via-Deep-Representation-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/01/文献摘要之Semi-supervised-Clustering-for-Short-Text-via-Deep-Representation-Learning/" itemprop="url">
                  文献摘要之Semi-supervised-Clustering-for-Short-Text-via-Deep-Representation-Learning
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T15:40:37+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/01/文献摘要之Semi-supervised-Clustering-for-Short-Text-via-Deep-Representation-Learning/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/01/文献摘要之Semi-supervised-Clustering-for-Short-Text-via-Deep-Representation-Learning/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>声明：作者翻译论文仅为学习，如有侵权请联系作者删除博文，谢谢！</strong><br>Semi-supervised Clustering for Short Text via Deep Representation Learning<br>基于深度表示学习的短文本半监督聚类</p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>In this work, we propose a semi-supervised method for short text clustering, where we represent texts as distributed vectors with neural networks, and use a small amount of labeled data to specify our intention for clustering. We design a novel objective to combine the representation learning process and the kmeans clustering process together, and optimize the objective with both labeled data and unlabeled data iteratively until convergence through three steps: (1) assign each short text to its nearest centroid based on its representation from the current neural networks; (2) reestimate the cluster centroids based on cluster assignments from step (1); (3) update neural networks according to the objective by keeping centroids and cluster assignments fixed.Experimental results on four datasets show that our method works significantly better than several other text clustering methods.</p>
<p>在这项工作中，我们提出了一种用于短文本聚类的半监督方法，其中我们将文本表示为具有神经网络的分布式向量，并使用少量标记数据来指定我们的聚类意图。 我们设计了一个新的目标，将表示学习过程和kmeans聚类过程结合在一起，迭代地用标记数据和未标记数据优化目标，直到通过三个步骤收敛：（1）基于其分配每个短文本到最近的质心 来自当前神经网络的表示; （2）根据步骤（1）中的聚类分配重新估计聚类质心; （3）通过保持质心和聚类分配固定，根据目标更新神经网络。对四个数据集的实验结果表明，我们的方法比其他几种文本聚类方法效果明显更好。</p>
<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><p>Text clustering is a fundamental problem in text mining and information retrieval. Its task is to group similar texts together such that texts within a cluster are more similar to texts in other clusters. Usually, a text is represented as a bag-of-words or term frequency-inverse document frequency (TFIDF) vector, and then the k-means algorithm (MacQueen, 1967) is performed to partition a set of texts into homogeneous groups.<br>However, when dealing with short texts, the characteristics of short text and clustering task raise several issues for the conventional unsupervised clustering algorithms. First, the number of uniqe words in each short text is small, as a result, the lexcical sparsity issue usually leads to poor clustering quality (Dhillon and Guan, 2003). Second, for a specific short text clustering task, we have prior knowledge or paticular intenstions before clustering, while fully unsupervised approaches may learn some classes the other way around. Take the sentences in Table 1 for example, those sentences can be clustered into different partitions based on different intentions: apple{a, b, c} and orange {d, e, f} with a fruit type intension, or what-question {a, d}, when-question {b, e},and yes/no-question cluster {c, f} with a question type intension.<br>文本聚类是文本挖掘和信息检索中的基本问题。 其任务是将类似的文本组合在一起，使得群集内的文本更类似于其他群集中的文本。 通常，文本被表示为词袋或术语频率 - 逆文档频率（TFIDF）向量，然后执行k均值算法（MacQueen，1967）以将一组文本划分为同类组。<br>然而，在处理短文本时，短文本和聚类任务的特征为传统的无监督聚类算法提出了若干问题。首先，每个短文本中的单词数量很少，因此，词汇稀疏性问题通常会导致较差的聚类质量（Dhillon和Guan，2003）。其次，对于特定的短文本聚类任务，我们在聚类之前具有先验知识或特定强度，而完全无监督的方法可以反过来学习一些类。 以表1中的句子为例，这些句子可以根据不同的意图聚类到不同的分区：苹果{a，b，c}和橘子{d，e，f}，具有水果类型内涵，或者什么问题{a，d}，什么时候问题{b，e}，是否问题{c，f}，带有问题类型含义。<br><img src="/2019/04/01/文献摘要之Semi-supervised-Clustering-for-Short-Text-via-Deep-Representation-Learning/TIM图片20190401153334.png" alt="table1"><br>To address the lexical sparity issue, one direction is to enrich text representations by extracting features and relations from Wikipedia (Banerjee et al.,2007) or an ontology (Fodeh et al., 2011). But this approach requires the annotated knowlege, which is also language dependent. So the other direction, which directly encode texts into distributed vectors with neural networks (Hinton and Salakhutdinov,2006; Xu et al., 2015), becomes more interesing. To tackle the second problem, semi-supervised approaches (e.g. (Bilenko et al., 2004; Davidson and Basu, 2007; Bair, 2013)) have gained significant popularity in the past decades. Our question is can we have a unified model to integrate netural networks into the semi-supervied framework?<br>为了解决词汇间性问题，一个方向是通过从维基百科(Banerjee et al.,2007)或本体论(Fodeh et al., 2011)中提取特征和关系来丰富文本表示。但是这种方法需要带注释的知识，这也是语言依赖的。因此，使用神经网络将文本直接编码为分布式向量的另一个方向（Hinton和Salakhutdinov，2006; Xu等，2015）变得更加有意义。为了解决第二个问题，半监督方法 (e.g. (Bilenko et al., 2004; Davidson and Basu, 2007; Bair, 2013))在过去几十年中获得了极大的欢迎。我们的问题是，我们可以有一个统一的模型将神经网络整合到半监督框架中吗？</p>
<p>In this paper, we propose a unified framework for the short text clustering task. We employ a deep neural network model to represent short sentences, and integrate it into a semi-supervised algorithm. Concretely, we extend the objective in the classical unsupervised k-means algorithm by adding a penalty term from labeled data. Thus, the new objective covers three key groups of parameters: centroids of clusters, the cluster assignment for each text, and the parameters within deep neural networks. In the training procedure, we start from random initialization of centroids and neural networks, and then optimize the objective iteratively through three steps until converge:<br>(1) assign each short text to its nearest centroid based on its representation from the current neural networks;<br>(2) re-estimate cluster centroids based on cluster assignments from step (1);<br>(3) update neural networks according to the objective by keeping centroids and cluster assignments fixed.<br>Experimental results on four different datasets show that our method achieves significant improvements over several other text clustering methods In following parts, we first describe our neural network models for text representaion (Section 2).Then we introduce our semi-supervised clustering method and the learning algorithm (Section 3). Finally, we evaluate our method on four different datasets (Section 4).<br>在本文中，我们提出了一个用于短文本聚类任务的统一框架。我们采用深度神经网络模型来表示短句，并将其整合到半监督算法中。具体地说，我们通过从标记数据中添加惩罚项来扩展经典无监督k均值算法的目标。因此，新目标涵盖三个关键参数组：聚类的质心，每个文本的聚类分配以及深度神经网络中的参数。在训练过程中，我们从质心和神经网络的随机初始化开始，然后通过三个步骤迭代地优化目标直到收敛：<br>（1）根据当前神经网络的表示，将每个短文本分配到最近的质心;<br>（2）根据步骤（1）中的聚类分配重新估计聚类质心;<br>（3）通过保持质心和簇分配固定，根据目标更新神经网络。<br>四个不同数据集的实验结果表明，我们的方法比其他几种文本聚类方法有了显着的改进。在下面的部分中，我们首先描述了用于文本表示的神经网络模型（第2节）。然后我们介绍了我们的半监督聚类方法和学习。算法（第3节）。最后，我们在四个不同的数据集上评估我们的方法（第4节）。</p>
<h3 id="2-Representation-Learning-for-Short-Texts"><a href="#2-Representation-Learning-for-Short-Texts" class="headerlink" title="2 Representation Learning for Short Texts"></a>2 Representation Learning for Short Texts</h3><p>We represent each word with a dense vector w, so that a short text s is first represented as a matrix $S = [w_1, …, w_{|s|}]$, which is a concatenation of all vectors of w in s, |s| is the length of s. Then we design two different types of neural networks to ingest the word vector sequence S: the convolutional neural networks (CNN) and the long short-term memory(LSTM). More formally, we define the presentation function as $x = f(s)$, where x is the represent vector of the text s. We test two encoding functions (CNN and LSTM) in our experiments.<br>我们用密集向量w表示每个单词，因此短文本s首先表示为矩阵$S = [w_1, …, w_{|s|}]$，它是s中所有w的向量的连接，|s|是s的长度。然后我们设计了两种不同类型的神经网络来摄取单词矢量序列S：卷积神经网络（CNN）和长短期记忆（LSTM）。更正式地，我们将表示函数定义为$x = f(s)$，其中x是文本s的表示向量。我们在实验中测试了两种编码函数（CNN和LSTM）。<br><img src="/2019/04/01/文献摘要之Semi-supervised-Clustering-for-Short-Text-via-Deep-Representation-Learning/]DFHXJ5RX}G[A242WKCXNT6.png" alt="figure1"><br>Inspired from Kim (2014), our CNN model views the sequence of word vectors as a matrix, and applies two sequential operations: convolution and maxpooling. Then, a fully connected layer is employed to convert the final representation vector into a fixed size. Figure 1 gives the diagram of the CNN model. In the convolution operation, we define a list of filters ${w_o}$, where the shape of each filter is d × h, dis the dimension of word vectors and h is the window size. Each filter is applied to a patch (a window size h of vectors) of S, and generates a feature. We apply this filter to all possible patches in S, and produce a series of features. The number of features depends on the shape of the filter wo and the length of the input short text. To deal with variable feature size, we perform a max-pooling operation over all the features to select the maximum value. Therefore, after the two operations, each filter generates only one feature. We define several filters by varying the window size and the initial values. Thus, a vector of features is captured after the max-pooling operation, and the feature dimension is equal to the number of filters.<br>受Kim（2014）的启发，我们的CNN模型将单词向量序列视为矩阵，并应用两个连续运算：卷积和最大化。然后，使用完全连接的层将最终表示矢量转换为固定大小。图1给出了CNN模型的示意图。在卷积运算中，我们定义了一个过滤器列表${w_o}$，其中每个过滤器的形状是d×h，dis是单词向量的维度，h是窗口大小。每个滤波器应用于S的贴片（矢量的窗口大小h），并生成特征。我们将此过滤器应用于S中的所有可能的补丁，并生成一系列功能。特征的数量取决于滤波器的形状和输入短文本的长度。为了处理可变特征尺寸，我们对所有特征执行最大池操作以选择最大值。因此，在两次操作之后，每个过滤器仅生成一个特征。我们通过改变窗口大小和初始值来定义几个过滤器。因此，在最大池操作之后捕获特征向量，并且特征维度等于过滤器的数量。<br><img src="/2019/04/01/文献摘要之Semi-supervised-Clustering-for-Short-Text-via-Deep-Representation-Learning/图2.png" alt="tu2"><br>Figure 2 gives the diagram of our LSTM model. We implement the standard LSTM block described in Graves (2012). Each word vector is fed into the LSTM model sequentially, and the mean of the hidden states over the entire sentence is taken as the final representation vector.<br>图2给出了我们的LSTM模型图。我们实现了Graves（2012）中描述的标准LSTM块。每个单词矢量被顺序地馈送到LSTM模型中，并且整个句子上的隐藏状态的平均值被作为最终表示矢量。</p>
<h3 id="3-Semi-supervised-Clustering-for-Short-Texts"><a href="#3-Semi-supervised-Clustering-for-Short-Texts" class="headerlink" title="3 Semi-supervised Clustering for Short Texts"></a>3 Semi-supervised Clustering for Short Texts</h3><h4 id="3-1-Revisiting-K-means-Clustering"><a href="#3-1-Revisiting-K-means-Clustering" class="headerlink" title="3.1 Revisiting K-means Clustering"></a>3.1 Revisiting K-means Clustering</h4><p>Given a set of texts $\{s_1,s_2,\cdots,s_N\}$, we represent them as a set of data points $\{x_1,x_2,\cdots,x_N\}$, where $x_i$ can be a bag-of-words or TF-IDF vector in traditional approaches, or a dense vector in Section 2.The task of text clustering is to partition the data set into some numberK of clusters, such that the sum of the squared distance of each data point to its closest cluster centroid is minimized. For each data point $x_n$, we define a set of binary variables $r_{nk}\in\{0,1\}$,where $k\in\{1,\cdots,K\}$ describing which of the K clusters $x_n$ is assigned to. So that if $x_n$ is assigned to cluster k, then $r_{nk} = 1$, and $r_{nj} = 0$ for$j\neq k$.Let’s define $u_k$ as the centroid of the k-th cluster.We can then formulate the objective function as<script type="math/tex">J_{unsup} = \sum_{n=1}^N\sum_{k=1}^K r_{nk}\left \|x_n-u_k\right \|^2</script>Our goal is the find the values of $\{r_{nk}\}$ and $\{u_k\}$ so as to minimize Junsup.<br>给出一组文本$\{s_1,s_2,\cdots,s_N\}$，我们将它们表示为一组数据点$\{x_1,x_2,\cdots,x_N\}$，其中$x_i$可以是传统方法中的词袋或TF-IDF向量，或者是第2节中的密集向量。文本聚类的任务是将数据集划分为某些数量的簇，使得总和 每个数据点到其最近的聚类质心的平方距离最小化。 对于每个数据点$x_n$，我们定义一组二进制变量$r_{nk}\in\{0,1\}$，其中$k\in\{1,\cdots,K\}$描述$x_n$分配到哪个群集。 因此，如果将$x_n$分配给簇k，则$r_{nk} = 1$，并且对于$j\neq k,r_{nj} = 0$。让我们将$u_k$定义为第k个簇的质心。然后我们可以将目标函数表示为<script type="math/tex">J_{unsup} = \sum_{n=1}^N\sum_{k=1}^K r_{nk}\left \|x_n-u_k\right \|^2</script>我们的目标是找到$\{r_{nk}\}$和$\{u_k\}$的值，以便最小化$J_{unsup}$。</p>
<p>The k-means algorithm optimizes $J_{semi}$ through the gradient descent approach, and results in an iterative procedure (Bishop, 2006). Each iteration involves two steps: E-step and M-step. In the Estep, the algorithm minimizes $J_{semi}$ with respect to $\{r_{nk}\}$ by keeping $\{u_k\}$ fixed. $J_{semi}$ is a linear function for $\{r_{nk}\}$, so we can optimize for each data point separately by simply assigning the n-th data point to the closest cluster centroid. In the M-step,the algorithm minimizes $J_{semi}$ with respect to $\{u_k\}$ by keeping $\{r_{nk}\}$ fixed. $J_{semi}$ is a quadratic function of $\{u_k\}$, and it can be minimized by setting its derivative with respect to $\{u_k\}$ to zero.<script type="math/tex">\frac{\partial J_{unsup}}{\partial \mu_k} = 2\sum_{n=1}^Nr_{nk}(x_n-\mu_k)=0(2)</script><br>Then, we can easily solve $\{u_k\}$ as<script type="math/tex">\mu_k=\frac{\sum_{n=1}^Nr_{nk}x_n}{\sum_{n=1}^Nr_{nk}}(3)</script><br>In other words, $\{u_k\}$ is equal to the mean of all the data points assigned to cluster k.<br>k-means算法通过梯度下降方法优化$J_{semi}$，并产生迭代过程（Bishop，2006）。 每次迭代都涉及两个步骤：E步和M步。 在E-step中，算法通过保持$\{u_k\}$固定来最小化$J_{semi}$相对于$\{r_{nk}\}$。 $J_{semi}$是$\{r_{nk}\}$的线性函数，因此我们可以通过简单地将第n个数据点分配给最近的聚类质心来分别优化每个数据点。 在M步骤中，算法通过保持$\{r_{nk}\}$固定来最小化$J_{semi}$相对于$\{u_k\}$。 $J_{semi}$是$\{u_k\}$的二次函数，可以通过将其导数相对于$\{u_k\}$设置为零来最小化。<script type="math/tex">\frac{\partial J_{unsup}}{\partial \mu_k} = 2\sum_{n=1}^Nr_{nk}(x_n-\mu_k)=0(2)</script><br>我们很容易得到<script type="math/tex">\mu_k=\frac{\sum_{n=1}^Nr_{nk}x_n}{\sum_{n=1}^Nr_{nk}}(3)</script><br>换句话说，$\{u_k\}$等于分配给簇k的所有数据点的平均值。</p>
<h4 id="3-2-Semi-supervised-K-means-with-Neural-Networks"><a href="#3-2-Semi-supervised-K-means-with-Neural-Networks" class="headerlink" title="3.2 Semi-supervised K-means with Neural Networks"></a>3.2 Semi-supervised K-means with Neural Networks</h4><p>The classical k-means algorithm only uses unlabeled data, and solves the clustering problem under the unsupervised learning framework. As already mentioned, the clustering results may not be consistent to our intention. In order to acquire useful clustering results, some supervised information should be introduced into the learning procedure. To this end,we employ a small amount of labeled data to guide the clustering process.<br>Following Section 2, we represent each text s as a dense vector x via neural networks $f(s)$. Instead of training the text representation model separately,we integrate the training process into the k-means algorithm, so that both the labeled data and the unlabeled data can be used for representation learning and text clustering. Let us denote the labeled data set as $\{(s_1,y_1),(s_2,y_2),\cdots,(s_L,y_L)\}$, and the unlabeled data set as $\{s_{L+1},s_{L+2},\cdots,s_N\}$, where $y_i$ is the given label for $s_i$. We then define the objective function as:<script type="math/tex">J_{semi} =\alpha \sum_{n=1}^N\sum_{k=1}^Kr_{nk}\left \|  f(s_n)-\mu_k\right \|^2+(1-\alpha)\sum_{n=1}^L\{\left \|  f(s_n)-\mu_{g_n}\right \|^2+\sum_{j\neq g_n}[l+\sum_{n=1}^L\left \|  f(s_n)-\mu_{g_n}\right \|^2-\sum_{n=1}^L\left \|  f(s_n)-\mu_{j}\right \|^2]_+\}</script><br>经典的k-means算法仅使用未标记的数据，并解决了无监督学习框架下的聚类问题。 如前所述，聚类结果可能与我们的意图不一致。为了获得有用的聚类结果，应该在学习过程中引入一些监督信息。为此，我们使用少量标记数据来指导群集过程。<br>在第2节之后，我们通过神经网络$f(s)$将每个文本s表示为密集向量x。我们不是单独训练文本表示模型，而是将训练过程集成到k-means算法中，以便标记数据和未标记数据都可以用于表示学习和文本聚类。 让我们将标记数据集表示为$\{(s_1,y_1),(s_2,y_2),\cdots,(s_L,y_L)\}$，并将未标记数据集表示为$\{s_{L+1},s_{L+2},\cdots,s_N\}$，其中$y_i$是$s_i$的给定标签。 然后我们将目标函数定义为：</p>
<script type="math/tex; mode=display">J_{semi} =\alpha \sum_{n=1}^N\sum_{k=1}^Kr_{nk}\left \|  f(s_n)-\mu_k\right \|^2+(1-\alpha)\sum_{n=1}^L\{\left \|  f(s_n)-\mu_{g_n}\right \|^2+\sum_{j\neq g_n}[l+\sum_{n=1}^L\left \|  f(s_n)-\mu_{g_n}\right \|^2-\sum_{n=1}^L\left \|  f(s_n)-\mu_{j}\right \|^2]_+\}</script><p>The objective function contains two terms. The first term is adapted from the unsupervised k-means algorithm in Eq. (1), and the second term is defined to encourage labeled data being clustered in correlation with the given labels. $\alpha\in[0,1]$ is used to tune the importance of unlabeled data. The second term contains two parts. The first part penalizes large distance between each labeled instance and its correct cluster centroid, where $g_n=G(y_n)$ is the cluster ID mapped from the given label yn, and the mapping function $G(\cdot)$ is implemented with the Hungarian algorithm (Munkres, 1957). The second part is denoted as a hinge loss with a margin l, where $[x]_+ = max(x,0)$. This part incurs some loss if the distance to the correct centroid is not shorter (by the margin l) than distances to any of incorrect cluster centroids.<br>目标函数包含两个部分。第一项改编自方程式中的无监督k均值算法。(1)，并且第二项被定义为鼓励标记数据与给定标签相关联地聚类。$\alpha\in[0,1]$用于调整未标记数据的重要性。第二项包含两部分。第一部分惩罚每个标记实例与其正确的聚类质心之间的大距离，其中$g_n=G(y_n)$是从给定标签$y_n$映射的聚类ID，映射函数$G(\cdot)$用匈牙利算法(Munkres, 1957)实现。第二部分表示为具有边界l的铰链损耗，其中$[x]_+ = max(x,0)$。如果到正确质心的距离不短（通过边缘l）而不是到任何不正确的聚类质心的距离，则该部分会引起一些损失。</p>
<p>There are three groups of parameters in $J_{semi}$: the cluster assignment of each text $\{r_{nk}\}$, the cluster centroids $\{\mu_k\}$, and the parameters within the neural network model $f(\cdot)$. Our goal is the find the values of $\{r_{nk}\}$, $\{\mu_k\}$ and parameters in $f(\cdot)$, so as to minimize $J_{semi}$. Inspired from the k-means algorithm,we design an algorithm to successively minimize $J_{semi}$ with respect to $\{r_{nk}\}$, $\{\mu_k\}$, and parameters in $f(\cdot)$. Table 2 gives the corresponding pseudocode.First, we initialize the cluster centroids $\{\mu_k\}$ with the k-means++ strategy (Arthur and Vassilvitskii,2007), and randomly initialize all the parameters in the neural network model. Then, the algorithm iteratively goes through three steps (assign cluster, estimate centroid, and update parameter) until $J_{semi}$ converges.<br>$J_{semi}$中有三组参数：每个文本的集群分配$\{r_{nk}\}$，集群质心$\{\mu_k\}$，以及神经网络模型$f(\cdot)$中的参数。我们的目标是在$f(\cdot)$中找到$\{r_{nk}\}$，$\{\mu_k\}$和参数的值，以便最小化$J_{semi}$。受k-means算法的启发，我们设计了一种算法，相对于$\{r_{nk}\}$，$\{\mu_k\}$和$f(\cdot)$中的参数，连续地最小化$J_{semi}$。表2给出了相应的伪代码。首先，我们用k-means ++策略初始化聚类中心$\{\mu_k\}$（Arthur和Vassilvitskii，2007），并随机初始化神经网络模型中的所有参数。然后，算法迭代地经历三个步骤（分配簇，估计质心和更新参数）直到$J_{semi}$收敛。</p>
<p>The assign cluster step minimizes $J_{semi}$ with respect to $\{r_{nk}\}$ by keeping $f(\cdot)$ and $\{\mu_k\}$ fixed. Its goal is to assign a cluster ID for each data point. We can see that the second term in Eq. (4) has no relation with $\{r_{nk}\}$. Thus, we only need to minimize the first term by assigning each text to its nearest cluster centroid, which is identical to the E-step in the k-means algorithm. In this step, we also calculate the mappings between the given labels $\{y_i\}$ and the cluster IDs (with the Hungarian algorithm) based on cluster assignments of all labeled data.<br>分配簇步骤通过保持$f(\cdot)$和$\{\mu_k\}$固定来最小化$J_{semi}$相对于$\{r_{nk}\}$。其目标是为每个数据点分配一个集群ID。我们可以看到方程式(4)中的第二项与$\{r_{nk}\}$无关。因此，我们只需要通过将每个文本分配到其最近的聚类质心来最小化第一项，这与k均值算法中的E步骤相同。在此步骤中，我们还基于所有标记数据的集群分配来计算给定标签$\{y_i\}$与集群ID（使用匈牙利算法）之间的映射。</p>
<p>The estimate centroid step minimizes $J_{semi}$ with respect to $\{\mu_k\}$ by keeping $\{r_{nk}\}$ and $f(\cdot)$ fixed,which corresponds to the M-step in the k-means algorithm. It aims to estimate the cluster centroids$\{\mu_k\}$ based on the cluster assignments $\{r_{nk}\}$ from the assign cluster step. The second term in Eq.(4) makes each labeled instance involved in the estimating process of cluster centroids. By solving $\partial J_{semi}/\partial \mu_k = 0$, we get<script type="math/tex">u_k =\frac{\sum_{n=1}^N\alpha r_{nk}f(s_n)+\sum_{n=1}^L w_{nk}f(s_n)}{\sum_{n=1}^N\alpha r_{nk}+\sum_{n=1}^L w_{nk}} (5)</script><br>${I}’_{nk} = \delta(k,g_n)$<br>${I}’’_{nkj} = \delta(k,j)\cdot \delta’_{nj}$<br>${I}’’’_{nkj} = (1-\delta(k,j))\cdot \delta’_{nj}$<br>$\delta’_{nj} = \delta(l+\left|f(s_n)-\mu_{g_n}\right|^2-\left|f(s_n)-\mu_{j}\right|^2&gt;0)(6)$<br>where $\delta(x_1, x_2)=1$ if $x_1$ is equal to $x_2$, otherwise $\delta(x_1, x_2)=0$, and $\delta(x)=1$ if x is true, otherwise $\delta(x)=0$. The first term in the numerator of Eq. (5) is the contributions from all data points, and $\alpha r_{nk}$ is the weight of $s_n$ for $\mu_k$. The second term is acquired from labeled data, and $w_{nk}$ is the weight of a labeled instance $s_n$ for $\mu_k$.<br>通过保持$\{r_{nk}\}$和$f(\cdot)$固定，估计质心步骤使$J_{semi}$相对于$\{\mu_k\}$最小化，这对应于k均值算法中的M步。它旨在根据分配集群步骤中的集群分配$\{r_{nk}\}$估计集群质心$\{\mu_k\}$。方程(4)中的第二项使得每个标记实例参与聚类质心的估计过程。通过求解$\partial J_{semi}/\partial \mu_k = 0$，我们得到了<script type="math/tex">u_k =\frac{\sum_{n=1}^N\alpha r_{nk}f(s_n)+\sum_{n=1}^L w_{nk}f(s_n)}{\sum_{n=1}^N\alpha r_{nk}+\sum_{n=1}^L w_{nk}}</script><br>${I}’_{nk} = \delta(k,g_n)$<br>${I}’’_{nkj} = \delta(k,j)\cdot \delta’_{nj}$<br>${I}’’’_{nkj} = (1-\delta(k,j))\cdot \delta’_{nj}$<br>$\delta’_{nj} = \delta(l+\left|f(s_n)-\mu_{g_n}\right|^2-\left|f(s_n)-\mu_{j}\right|^2&gt;0)$<br>其中$ \delta(x_1,x_2)= 1 $如果$ x_1 $等于$ x_2 $，否则$ \delta(x_1,x_2)= 0 $，如果x为真，$ \delta(x)= 1 $ ，否则$ \delta(x)= 0 $。 方程式(5)分子中的第一项是所有数据点的贡献，$ \alpha r_{nk} $是$ \mu_k $的$ s_n $的权重。 第二个术语是从标记数据中获取的，$ w_{nk} $是$ \mu_k $的标记实例$s_n$的权重。</p>
<p>The update parameter step minimizes $J_{semi}$ with respect to $f(\cdot)$ by keeping $\{r_{nk}\}$ and $\{\mu_k\}$ fixed,which has no counterpart in the k-means algorithm.The main goal is to update parameters for the text representation model. We take $J_{semi}$ as the loss function, and train neural networks with the Adam algorithm (Kingma and Ba, 2014).<br>更新参数步骤通过保持$\{r_{nk}\}$和$\{\mu_k\}$固定来最小化$J_{semi}$相对于$f(\cdot)$，其在k均值算法中没有对应物。主要目标是更新文本表示模型的参数。 我们将$J_{semi}$作为损失函数，并使用Adam算法训练神经网络（Kingma和Ba，2014）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2019/03/20/文献摘要之Convolutional-Neural-Networks-for-Sentence-Classification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/20/文献摘要之Convolutional-Neural-Networks-for-Sentence-Classification/" itemprop="url">
                  文献摘要之Convolutional Neural Networks for Sentence Classification
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T14:51:10+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/20/文献摘要之Convolutional-Neural-Networks-for-Sentence-Classification/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/20/文献摘要之Convolutional-Neural-Networks-for-Sentence-Classification/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>声明：作者翻译论文仅为学习，如有侵权请联系作者删除博文，谢谢！</strong><br>Convolutional Neural Networks for Sentence Classification<br>用于句子分类的卷积神经网络</p>
<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><p>We report on a series of experiments with convolutional neural networks (CNN) trained on top of pre-trained word vectors for sentence-level classification tasks. We show that a simple CNN with little hyperparameter tuning and static vectors achieves excellent results on multiple benchmarks. Learning task-specific vectors through fine-tuning offers further gains in performance. We additionally propose a simple modification to the architecture to allow for the use of both task-specific and static vectors. The CNN models discussed herein improve upon the state of the art on 4 out of 7 tasks, which include sentiment analysis and question classification.<br>我们报告了一系列卷积神经网络（CNN）的实验，这些实验是在预训练的单词向量之上训练的，用于句子级分类任务。 我们展示了一个简单的CNN，它具有很少的超参数调整和静态向量，可以在多个基准测试中获得出色的结果。 通过微调学习任务特定的向量可以进一步提高性能。 我们还建议对架构进行简单修改，以允许使用任务特定和静态向量。 这里讨论的CNN模型在7个任务中的4个中改进了现有技术，包括情感分析和问题分类。</p>
<p>Deep learning models have achieved remarkable results in computer vision (Krizhevsky et al.,2012) and speech recognition (Graves et al., 2013) in recent years. Within natural language processing, much of the work with deep learning methods has involved learning word vector representations through neural language models (Bengio et al., 2003; Yih et al., 2011; Mikolov et al., 2013) and performing composition over the learned word vectors for classification (Collobert et al., 2011). Word vectors, wherein words are projected from a sparse, 1-of-V encoding (here V is the vocabulary size) onto a lower dimensional vector space via a hidden layer, are essentially feature extractors that encode semantic features of words in their dimensions. In such dense representations, semantically close words are likewise close—in euclidean or cosine distance—in the lower dimensional vector space.<br>深度学习模型近年来在计算机视觉（Krizhevsky等，2012）和语音识别（Graves等，2013）中取得了显着成果。在自然语言处理中，深度学习方法的大部分工作都涉及通过神经语言模型学习单词矢量表示（Bengio et al。，2003; Yih et al。，2011; Mikolov et al。，2013），并在学习了用于分类的单词向量（Collobert et al。，2011）。单词向量，其中单词通过隐藏层从稀疏的1-V编码（这里V是词汇量大小）投影到较低维度的向量空间上，本质上是特征提取器，其在其维度中编码单词的语义特征。在这种密集表示中，语义上接近的单词同样在较低维向量空间中接近欧几里德或余弦距离。</p>
<p>Convolutional neural networks (CNN) utilize layers with convolving filters that are applied to  local features (LeCun et al., 1998). Originally invented for computer vision, CNN models have subsequently been shown to be effective for NLP and have achieved excellent results in semantic parsing (Yih et al., 2014), search query retrieval (Shen et al., 2014), sentence modeling (Kalchbrenner et al., 2014), and other traditional NLP tasks (Collobert et al., 2011).<br>卷积神经网络（CNN）利用具有应用于局部特征的卷积滤波器的层（LeCun等，1998）。最初发明用于计算机视觉的CNN模型随后被证明对NLP有效，并且在语义分析（Yih等人，2014），搜索查询检索（Shen et al。，2014），句子建模（Kalchbrenner）方面取得了优异的成果。 et al。，2014）和其他传统的NLP任务（Collobert等，2011）。</p>
<p>In the present work, we train a simple CNN with one layer of convolution on top of word vectors obtained from an unsupervised neural language model. These vectors were trained by Mikolov et al. (2013) on 100 billion words of Google News, and are publicly available.1 We initially keep the word vectors static and learn only the other parameters of the model. Despite little tuning of hyperparameters, this simple model achieves excellent results on multiple benchmarks, suggesting that the pre-trained vectors are ‘universal’ feature extractors that can be utilized for various classification tasks. Learning task-specific vectors through fine-tuning results in further improvements. We finally describe a simple modification to the architecture to allow for the use of both pre-trained and task-specific vectors by having multiple channels.<br>Our work is philosophically similar to Razavian et al. (2014) which showed that for image classification, feature extractors obtained from a pretrained deep learning model perform well on a variety of tasks—including tasks that are very different from the original task for which the feature extractors were trained.<br>在目前的工作中，我们训练一个简单的CNN，在无人监督的神经语言模型中获得的单词向量之上有一层卷积。这些载体由Mikolov等人训练。 （2013）关于1000亿字的谷歌新闻，并且是公开可用的.1我们最初保持单词向量静态并仅学习模型的其他参数。尽管对超参数进行了很少的调整，但这个简单的模型在多个基准测试中取得了优异的成果，这表明预训练的矢量是可以用于各种分类任务的“通用”特征提取器。通过微调学习任务特定的向量可以进一步改进。我们最终描述了对体系结构的简单修改，以允许通过具有多个通道来使用预先训练的和任务特定的向量。<br>我们的工作在哲学上类似于Razavian等人。 （2014）表明，对于图像分类，从预训练深度学习模型获得的特征提取器在各种任务上表现良好 - 包括与训练特征提取器的原始任务非常不同的任务。</p>
<h3 id="2-Model"><a href="#2-Model" class="headerlink" title="2 Model"></a>2 Model</h3><p><img src="/2019/03/20/文献摘要之Convolutional-Neural-Networks-for-Sentence-Classification/TIM图片20190320203134.png" alt="figure1"></p>
<p>The model architecture, shown in figure 1, is a slight variant of the CNN architecture of Collobert et al. (2011). Let $x_i \in \mathbb{R}^k$ be the k-dimensional word vector corresponding to the i-th word in the sentence. A sentence of length n (padded where necessary) is represented as <script type="math/tex">x_{1:n} = x_1 \oplus x_2 \oplus \dots \oplus x_n, (1)</script>where $\oplus$ is the concatenation operator. In general, let $x_{i:i+j}$ refer to the concatenation of words $x_i, x_{i+1}, \dots , x_{i+j}$ . A convolution operation involves a filter $w \in \mathbb{R}^{hk}$, which is applied to a window of h words to produce a new feature. For example, a feature $c_i$ is generated from a window of words $x_{i:i+h-1}$ by <script type="math/tex">c_i = f(w · x_{i:i+h-1} + b). (2)</script></p>
<p>Here $b \in \mathbb{R}$ is a bias term and f is a non-linear function such as the hyperbolic tangent. This filter is applied to each possible window of words in the sentence $\{x_{1:h}, x_{2:h+1}, \dots , x_{n-h+1:n}\}$ to produce a feature map <script type="math/tex">c = [c_1, c_2, \dots , c_{n-h+1}], (3)</script> with $c \in R_{n-h+1}$. We then apply a max-overtime pooling operation (Collobert et al., 2011)over the feature map and take the maximum value $\hat{c} = max\{c\}$ as the feature corresponding to this particular filter. The idea is to capture the most important feature—one with the highest value—for each feature map. This pooling scheme naturally deals with variable sentence lengths.</p>
<p>We have described the process by which one feature is extracted from one filter. The model uses multiple filters (with varying window sizes) to obtain multiple features. These features form the penultimate layer and are passed to a fully connected softmax layer whose output is the probability distribution over labels.</p>
<p>In one of the model variants, we experiment with having two ‘channels’ of word vectors—one that is kept static throughout training and one that is fine-tuned via backpropagation (section 3.2).2 In the multichannel architecture, illustrated in figure 1, each filter is applied to both channels and the results are added to calculate $c_i$ in equation(2). The model is otherwise equivalent to the single channel architecture.</p>
<p>如图1所示，模型架构是Collobert等人的CNN架构的略微变体。（2011年）。 令$x_i \in \mathbb{R}^k$是对应于句子中的第i个单词的k维单词向量。长度为n的句子（必要时填充）表示为<script type="math/tex">x_{1:n} = x_1 \oplus x_2 \oplus \dots \oplus x_n, (1)</script>其中⊕是连接运算符。 通常，让 $x_{i:i+j}$指的是单词$x_i, x_{i+1}, \dots , x_{i+j}$的串联。卷积运算涉及滤波器$w \in \mathbb{R}^{hk}$，其应用于h字的窗口以产生新特征。 例如，通过<script type="math/tex">c_i = f(w · x_{i:i+h-1} + b). (2)</script>从单词$x_{i:i+h-1}$的窗口生成特征$c_i$。<br>这里$b \in \mathbb{R}$是偏置项，f是非线性函数，例如双曲正切。 此过滤器应用于句子$\{x_{1:h}, x_{2:h+1}, \dots , x_{n-h+1:n}\}$中的每个可能的单词窗口。生成特征映射<script type="math/tex">c = [c_1, c_2, \dots , c_{n-h+1}], (3)</script> $c \in R_{n-h+1}$。 然后，我们在特征图上应用最大超时池化操作（Collobert等，2011），并将最大值$\hat{c} = max\{c\}$作为与该特定过滤器对应的特征。 我们的想法是为每个要素图捕获最重要的特征——一个具有最高值的特征。 这种汇集方案自然地处理可变句子长度。<br>我们已经描述了从一个过滤器中提取一个特征的过程。 该模型使用多个过滤器（具有不同的窗口大小）来获得多个特征。 这些特征形成倒数第二层，并传递给完全连接的softmax层，其输出是标签上的概率分布。<br>在其中一个模型变体中，我们尝试使用两个“通道”的单词向量 - 一个在整个训练过程中保持静态，一个通过反向传播进行微调（第3.2节）.2在多通道架构中，如图1所示 ，将每个滤波器应用于两个通道，并将结果相加以计算等式（2）中的$c_i$。 该模型在其他方面等同于单通道架构。</p>
<h3 id="2-1-Regularization"><a href="#2-1-Regularization" class="headerlink" title="2.1 Regularization"></a>2.1 Regularization</h3><p>For regularization we employ dropout on the penultimate layer with a constraint on $l_2-$norms of the weight vectors (Hinton et al., 2012). Dropout prevents co-adaptation of hidden units by randomly dropping out—i.e., setting to zero—a proportion p of the hidden units during fowardbackpropagation. That is, given the penultimate layer $z = [\hat{c}_1, \dots , \hat{c}_m]$ (note that here we have m filters), instead of using <script type="math/tex">y = w · z + b (4)</script> for output unit y in forward propagation, dropout uses <script type="math/tex">y = w \cdot(z \circ r) + b, (5)</script> where $\circ$ is the element-wise multiplication operator and $r \in \mathbb{R}^m$ is a ‘masking’ vector of Bernoulli random variables with probability p of being 1. Gradients are backpropagated only through the unmasked units. At test time, the learned weight vectors are scaled by p such that $\hat{w} = pw$, and $\hat w$ is used (without dropout) to score unseen sentences. We additionally constrain $l_2$-norms of the weight vectors by rescaling w to have ${\lVert w \rVert}_2 = s$ whenever ${\lVert w \rVert}_2 &gt; s$ after a gradient descent step.</p>
<h3 id="2-1正规化"><a href="#2-1正规化" class="headerlink" title="2.1正规化"></a>2.1正规化</h3><p>对于正则化，我们在倒数第二层上使用丢失，并对权重向量的$l_2-$范数进行约束（Hinton等，2012）。Dropout通过随机丢弃来防止隐藏单元的共同适应，即在前向反向传播期间设置为零 - 隐藏单元的比例p。也就是说，给定倒数第二层$z = [\hat{c}_1, \dots , \hat{c}_m]$（请注意，这里我们有m个滤波器），而不是在前向传播中使用<script type="math/tex">y = w · z + b (4)</script>作为输出单位y，使用dropout <script type="math/tex">y = w \cdot(z \circ r) + b, (5)</script><br>其中$\circ$是逐元素乘法运算符，$r \in \mathbb{R}^m$是伯努利随机变量的’掩蔽’向量，概率p为1.梯度仅通过未掩蔽单元反向传播。在测试时，学习的权重向量通过p缩放，使得$\hat{w} = pw$，并且使用$\hat w$（没有丢失）来对看不见的句子进行评分。我们还通过在梯度下降步骤之后每当${\lVert w \rVert}_2 &gt; s$重新调整w以具有${\lVert w \rVert}_2 = s$来约束权重向量的$l_2$范数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2019/02/26/自然语言处理之词向量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/26/自然语言处理之词向量/" itemprop="url">
                  自然语言处理之词向量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T21:53:18+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/26/自然语言处理之词向量/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/26/自然语言处理之词向量/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="NLP-词向量"><a href="#NLP-词向量" class="headerlink" title="NLP-词向量"></a>NLP-词向量</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="什么是词向量-词嵌入"><a href="#什么是词向量-词嵌入" class="headerlink" title="什么是词向量/词嵌入"></a>什么是词向量/词嵌入</h4><p>词向量(word embedding)是一个固定长度的实值向量<br>词向量是神经语言模型的副产品<br>词向量是针对词提出的，事实上，也可以针对更细或更粗的粒度进行推广——比如字向量、句向量、文档向量等</p>
<h4 id="词向量的理解"><a href="#词向量的理解" class="headerlink" title="词向量的理解"></a>词向量的理解</h4><p>在NLP任务中，我们将自然语言交给机器学习算法来处理，但机器无法直接理解人类的语言，因此首先要做的事情就是将语言数字化,如何将自然语言进行数字化呢？词向量提供了一种很好的方式。</p>
<p>一种最简单的词向量是one-hot representation,就是用一个很长的向量来表示一个词，向量的长度为词典D的大小N，向量的分量只有一个1，其他全为0,1的位置对应该词在词典中的索引。但这种词向量表示有一个缺点，就是受维度灾难的困扰，尤其是将其用于Deep Learning场景时，又如，它不能很好刻画词与词之间的相似性；</p>
<p>另一种词向量是Distributed Representation，它最早是Hinton在1986年提出的，可以克服one-hot representation 的上述缺点，其基本想法是：通过训练将某种语言中的每一个词映射成一个固定长度的短向量，所有这些向量构成一个词向量空间，而每一向量可视为该空间中的一个点，在这个空间上引入“距离”，就可以根据词之间的距离来判断它们之间的相似性了，word2vec中采用的就是这种Distributed Representation的词向量</p>
<p>为了更好理解上述思想，我们来举一个通俗的例子：<br>假设在二维平面上有a个不同的点，给定其中的某个点，想在想在平面上找到与这个点最近的一个点。<br>我们是怎么做的呢？首先建立一个直角坐标系，基于该坐标系，其上每一个点就唯一的对应一个坐标(x,y);接着引入欧氏距离；最后分别计算这个点与其他a-1个点的距离，对应最小距离值得那个点便是我们要找的点了。</p>
<p>上面的例子中，坐标(X，y)的地位就相当于词向量，它来将平面上的一个点的位置在数学上作量化。坐标系建立好之后，要得到某个点的坐标是很容易的。然而，在NLP任务中,要得到词向量就复杂多了，而且词向量不唯一，其质量依赖于训练语料，训练算法等因素。</p>
<p>如何得到词向量呢？有很多不同的模型来估计词向量，包括右面的LSA和LDA，神经网络算法</p>
<h3 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h3><p>在word2vec出现之前，已经有用神经网络DNN来用训练词向量进而处理词与词之间的关系了。采用的方法一般是一个三层的神经网络结构（当然也可以多层），分为输入层，隐藏层和输出层(softmax层)。</p>
<p>这个模型是如何定义数据的输入和输出呢？一般分为CBOW(Continuous Bag-of-Words)与Skip-Gram两种模型。</p>
<p>CBOW模型的训练输入是某一个特征词的上下文相关的词对应的词向量，而输出就是这特定的一个词的词向量。比如下面这段话，我们的上下文大小取值为4，特定的这个词是”Learning”，也就是我们需要的输出词向量,上下文对应的词有8个，前后各4个，这8个词是我们模型的输入。由于CBOW使用的是词袋模型，因此这8个词都是平等的，也就是不考虑他们和我们关注的词之间的距离大小，只要在我们上下文之内即可。<br><img src="/2019/02/26/自然语言处理之词向量/word_example.png" alt="word"><br>这样在我们例子中，我们的输入是8个词向量，输出是所有词的softmax概率(训练的目标是期望训练样本特定词的softmax概率最大)，对应的CBOW神经网络模型输入层有8个神经元，输出层有词汇表大小个神经元。隐藏层的神经元个数我们可以自己指定。通过DNN的反向传播算法，我们可以求出DNN模型的参数，同时得到所有的词对应的词向量。这样当我们有新的需求，要求出某8个词对应的最可能的输出中心词时，我们可以通过一个DNN前向传播算法并通过softmax函数找到概率最大的词对应的神经元即可。<br>Skip-Gram模型和CBOW的思路是反着来的，即输入是特定的一个词的词向量，而输出是特定词对应的上下文词向量，我们上下文大小取值4，特定的这个词“learning”就是我们的输入，而这8个上下文词是我们的输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2019/02/16/使用Python操作Mangodb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/16/使用Python操作Mangodb/" itemprop="url">
                  使用Python操作Mangodb
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-16T20:55:27+08:00">
                2019-02-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/16/使用Python操作Mangodb/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/16/使用Python操作Mangodb/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Python-MongoDB"><a href="#Python-MongoDB" class="headerlink" title="Python MongoDB"></a>Python MongoDB</h2><p>MongoDB是目前最流行的NoSQL数据库之一，使用的数据类型是BSON</p>
<h3 id="PyMongoDB"><a href="#PyMongoDB" class="headerlink" title="PyMongoDB"></a>PyMongoDB</h3><p>Python要链接MongoDB需要MongoDB驱动，这里我们使用PyMongo驱动来连接</p>
<h4 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h4><p>pip是一个通用的Python包管理工具，提供了对Python包的查找、下载、安装、卸载的功能。<br>安装pymongo<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pip3 install pymongo</span><br></pre></td></tr></table></figure></p>
<p>也可以指定安装的版本<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pip3 install pymongo==3.5.1</span><br></pre></td></tr></table></figure></p>
<p>更新pymongo命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pip3 install --upgrade pymongo</span><br></pre></td></tr></table></figure></p>
<h4 id="测试pymongo"><a href="#测试pymongo" class="headerlink" title="测试pymongo"></a>测试pymongo</h4><p>在python控制台输入以下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br></pre></td></tr></table></figure></p>
<p>如果没有出现错误，表示安装成功</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><h4 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h4><p>创建数据库需要使用MongoClient对象，并且指定连接的URL地址和要创建的数据库名。<br>如下示例，我们需要创建数据库twittertopic<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">"mongodb://10.245.142.249:27017/"</span>)</span><br><span class="line">mydb = myclient[<span class="string">"twittertopic"</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：在MongoDB中，数据库只有在内容插入后才会创建！就是说，数据库创建要创建集合（数据表）并插入一条数据，数据库才会真正创建。</p>
<h4 id="判断数据库是否已存在"><a href="#判断数据库是否已存在" class="headerlink" title="判断数据库是否已存在"></a>判断数据库是否已存在</h4><p>我们可以读取MongoDB中所有的数据库，并判断制定的数据库是否存在：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">"mongodb://10.245.142.249:27017/"</span>)</span><br><span class="line">dblist = myclient.list_database_names()</span><br><span class="line"><span class="comment"># dblist = myclient.database_names()</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"twittertopic"</span> <span class="keyword">in</span> dblist:</span><br><span class="line">    print(<span class="string">"数据库已存在！"</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：database_names 在最新版本的 Python 中已废弃，Python3.7+ 之后的版本改为了 list_database_names()。</p>
<h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>MongoDB中的集合类似SQL的表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">"mongodb://10.245.142.249:27017/"</span>)</span><br><span class="line">mydb = myclient[<span class="string">"twittertopic"</span>]</span><br><span class="line">mycol = mydb[<span class="string">"sites"</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><h4 id="插入集合"><a href="#插入集合" class="headerlink" title="插入集合"></a>插入集合</h4><p>集合中插入文档使用insertone()方法，该方法的第一参数是字典name-&gt;value键值对。如下示例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">"mongodb://10.245.142.249:27017/"</span>)</span><br><span class="line">mydb = myclient[<span class="string">"twittertopic"</span>]</span><br><span class="line">mycol = mydb[<span class="string">"sites"</span>]</span><br><span class="line">mydict = &#123; <span class="string">"name"</span>: <span class="string">"RUNOOB"</span>, <span class="string">"alexa"</span>: <span class="string">"10000"</span>, <span class="string">"url"</span>: <span class="string">"https://www.runoob.com"</span> &#125;</span><br><span class="line">x = mycol.insert_one(mydict)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure></p>
<p>执行输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pymongo.results.InsertOneResult object at <span class="number">0x10a34b288</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="返回-id字段"><a href="#返回-id字段" class="headerlink" title="返回_id字段"></a>返回_id字段</h4><p>insert_one()方法返回InsertOneResult对象，该对象包含inserted_id属性，它是插入文档的id值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">"mongodb://10.245.142.249:27017/"</span>)</span><br><span class="line">mydb = myclient[<span class="string">"twittertopic"</span>]</span><br><span class="line">mycol = mydb[<span class="string">"Apex"</span>]</span><br><span class="line">mydict = &#123; <span class="string">"name"</span>: <span class="string">"RUNOOB"</span>, <span class="string">"alexa"</span>: <span class="string">"10000"</span>, <span class="string">"url"</span>: <span class="string">"https://www.runoob.com"</span> &#125;</span><br><span class="line">x = mycol.insert_one(mydict)</span><br><span class="line">print(x.inserted_id)</span><br></pre></td></tr></table></figure></p>
<p>执行输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>b2369cac315325f3698a1cf</span><br></pre></td></tr></table></figure></p>
<p>如果我们在插入文档时候没有指定_id，MongoDB会为每条数据添加一个唯一的id</p>
<h4 id="插入多个文档"><a href="#插入多个文档" class="headerlink" title="插入多个文档"></a>插入多个文档</h4><p>集合中插入多个文档使用 insert_many() 方法，该方法的第一参数是字典列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">"mongodb://10.245.142.249:27017/"</span>)</span><br><span class="line">mydb = myclient[<span class="string">"twittertopic"</span>]</span><br><span class="line">mycol = mydb[<span class="string">"sites"</span>]</span><br><span class="line">mylist = [</span><br><span class="line">  &#123; <span class="string">"name"</span>: <span class="string">"Taobao"</span>, <span class="string">"alexa"</span>: <span class="string">"100"</span>, <span class="string">"url"</span>: <span class="string">"https://www.taobao.com"</span> &#125;,</span><br><span class="line">  &#123; <span class="string">"name"</span>: <span class="string">"QQ"</span>, <span class="string">"alexa"</span>: <span class="string">"101"</span>, <span class="string">"url"</span>: <span class="string">"https://www.qq.com"</span> &#125;,</span><br><span class="line">  &#123; <span class="string">"name"</span>: <span class="string">"Facebook"</span>, <span class="string">"alexa"</span>: <span class="string">"10"</span>, <span class="string">"url"</span>: <span class="string">"https://www.facebook.com"</span> &#125;,</span><br><span class="line">  &#123; <span class="string">"name"</span>: <span class="string">"知乎"</span>, <span class="string">"alexa"</span>: <span class="string">"103"</span>, <span class="string">"url"</span>: <span class="string">"https://www.zhihu.com"</span> &#125;,</span><br><span class="line">  &#123; <span class="string">"name"</span>: <span class="string">"Github"</span>, <span class="string">"alexa"</span>: <span class="string">"109"</span>, <span class="string">"url"</span>: <span class="string">"https://www.github.com"</span> &#125;</span><br><span class="line">]</span><br><span class="line">x = mycol.insert_many(mylist)</span><br><span class="line"><span class="comment"># 输出插入的所有文档对应的 _id 值</span></span><br><span class="line">print(x.inserted_ids)</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ObjectId(<span class="string">'5b236aa9c315325f5236bbb6'</span>), ObjectId(<span class="string">'5b236aa9c315325f5236bbb7'</span>), ObjectId(<span class="string">'5b236aa9c315325f5236bbb8'</span>), ObjectId(<span class="string">'5b236aa9c315325f5236bbb9'</span>), ObjectId(<span class="string">'5b236aa9c315325f5236bbba'</span>)]</span><br></pre></td></tr></table></figure></p>
<h4 id="指定id的插入"><a href="#指定id的插入" class="headerlink" title="指定id的插入"></a>指定id的插入</h4><p>在字典加入_id字段即可</p>
<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><p>MongoDB中使用find和find_one方法来查询集合中的数据，它类似于SQL中的SELECT语句。<br>本文的测试数据如下：<br><img src="/2019/02/16/使用Python操作Mangodb/数据项.png" alt="数据项"><br>数据库连接代码如下，在之后的示例代码中不会重复：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">"mongodb://10.245.142.249:27017/"</span>)</span><br><span class="line">mydb = myclient[<span class="string">"twittertopic"</span>]</span><br><span class="line">mycol = mydb[<span class="string">"sites"</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="查询一条数据"><a href="#查询一条数据" class="headerlink" title="查询一条数据"></a>查询一条数据</h4><p>我们可以使用find_one()方法来查询一条数据<br>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = mycol.find_one()</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72852'</span>), <span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'alexa'</span>: <span class="string">'100'</span>, <span class="string">'url'</span>: <span class="string">'https://www.taobao.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="查询集合中所有的数据"><a href="#查询集合中所有的数据" class="headerlink" title="查询集合中所有的数据"></a>查询集合中所有的数据</h4><p>find() 方法可以查询集合中的所有数据，类似 SQL 中的 SELECT * 操作。<br>以下实例查找 sites 集合中的所有数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mycol.find():</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72852'</span>), <span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'alexa'</span>: <span class="string">'100'</span>, <span class="string">'url'</span>: <span class="string">'https://www.taobao.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72853'</span>), <span class="string">'name'</span>: <span class="string">'QQ'</span>, <span class="string">'alexa'</span>: <span class="string">'101'</span>, <span class="string">'url'</span>: <span class="string">'https://www.qq.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72854'</span>), <span class="string">'name'</span>: <span class="string">'Facebook'</span>, <span class="string">'alexa'</span>: <span class="string">'10'</span>, <span class="string">'url'</span>: <span class="string">'https://www.facebook.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72855'</span>), <span class="string">'name'</span>: <span class="string">'知乎'</span>, <span class="string">'alexa'</span>: <span class="string">'103'</span>, <span class="string">'url'</span>: <span class="string">'https://www.zhihu.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72856'</span>), <span class="string">'name'</span>: <span class="string">'Github'</span>, <span class="string">'alexa'</span>: <span class="string">'109'</span>, <span class="string">'url'</span>: <span class="string">'https://www.github.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="查询指定字段的数据"><a href="#查询指定字段的数据" class="headerlink" title="查询指定字段的数据"></a>查询指定字段的数据</h4><p>我们可以使用find()方法来查询指定字段的数据，将要返回的字段对应值设置为1.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mycol.find(&#123;&#125;,&#123; <span class="string">"_id"</span>: <span class="number">0</span>, <span class="string">"name"</span>: <span class="number">1</span>, <span class="string">"alexa"</span>: <span class="number">1</span> &#125;):</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'alexa'</span>: <span class="string">'100'</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'QQ'</span>, <span class="string">'alexa'</span>: <span class="string">'101'</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Facebook'</span>, <span class="string">'alexa'</span>: <span class="string">'10'</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'知乎'</span>, <span class="string">'alexa'</span>: <span class="string">'103'</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Github'</span>, <span class="string">'alexa'</span>: <span class="string">'109'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了_id不能在一个对象中同时指定0和1，如果你设置了一个字段为0.则其他都为1，反之亦然。<br>以下实例除了alexa字段外，其他都返回：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mycol.find(&#123;&#125;,&#123; <span class="string">"alexa"</span>: <span class="number">0</span> &#125;):</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72852'</span>), <span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'url'</span>: <span class="string">'https://www.taobao.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72853'</span>), <span class="string">'name'</span>: <span class="string">'QQ'</span>, <span class="string">'url'</span>: <span class="string">'https://www.qq.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72854'</span>), <span class="string">'name'</span>: <span class="string">'Facebook'</span>, <span class="string">'url'</span>: <span class="string">'https://www.facebook.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72855'</span>), <span class="string">'name'</span>: <span class="string">'知乎'</span>, <span class="string">'url'</span>: <span class="string">'https://www.zhihu.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72856'</span>), <span class="string">'name'</span>: <span class="string">'Github'</span>, <span class="string">'url'</span>: <span class="string">'https://www.github.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>以下代码同时指定了0和1则会报错</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mycol.find(&#123;&#125;,&#123; <span class="string">"name"</span>: <span class="number">1</span>, <span class="string">"alexa"</span>: <span class="number">0</span> &#125;):</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pymongo.errors.OperationFailure: Projection cannot have a mix of inclusion <span class="keyword">and</span> exclusion.</span><br></pre></td></tr></table></figure></p>
<h4 id="根据指定条件查询"><a href="#根据指定条件查询" class="headerlink" title="根据指定条件查询"></a>根据指定条件查询</h4><p>我们可以在 find() 中设置参数来过滤数据。<br>以下实例查找 name 字段为 “Taobao” 的数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myquery = &#123;<span class="string">"name"</span>: <span class="string">"Taobao"</span>&#125;</span><br><span class="line">mydoc = mycol.find(myquery)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mydoc:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72852'</span>), <span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'alexa'</span>: <span class="string">'100'</span>, <span class="string">'url'</span>: <span class="string">'https://www.taobao.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h4><p>查询的条件语句中，我们还可以使用修饰符。<br>以下实例用于读取 name 字段中第一个字母 ASCII 值大于 “H” 的数据，大于的修饰符条件为 {“$gt”: “H”} :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myquery = &#123; <span class="string">"name"</span>: &#123; <span class="string">"$gt"</span>: <span class="string">"H"</span> &#125; &#125;</span><br><span class="line">mydoc = mycol.find(myquery)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mydoc:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72852'</span>), <span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'alexa'</span>: <span class="string">'100'</span>, <span class="string">'url'</span>: <span class="string">'https://www.taobao.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72853'</span>), <span class="string">'name'</span>: <span class="string">'QQ'</span>, <span class="string">'alexa'</span>: <span class="string">'101'</span>, <span class="string">'url'</span>: <span class="string">'https://www.qq.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72855'</span>), <span class="string">'name'</span>: <span class="string">'知乎'</span>, <span class="string">'alexa'</span>: <span class="string">'103'</span>, <span class="string">'url'</span>: <span class="string">'https://www.zhihu.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用正则表达式查询"><a href="#使用正则表达式查询" class="headerlink" title="使用正则表达式查询"></a>使用正则表达式查询</h4><p>我们还可以使用正则表达式作为修饰符。<br>正则表达式修饰符只用于搜索字符串的字段。<br>以下实例用于读取 name 字段中第一个字母为 “T” 的数据，正则表达式修饰符条件为 {“$regex”: “^T”} :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myquery = &#123; <span class="string">"name"</span>: &#123; <span class="string">"$gt"</span>: <span class="string">"H"</span> &#125; &#125;</span><br><span class="line">mydoc = mycol.find(myquery)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mydoc:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72852'</span>), <span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'alexa'</span>: <span class="string">'100'</span>, <span class="string">'url'</span>: <span class="string">'https://www.taobao.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="返回指定条数记录"><a href="#返回指定条数记录" class="headerlink" title="返回指定条数记录"></a>返回指定条数记录</h4><p>如果我们要对查询结果设置指定条数的记录可以使用 limit() 方法，该方法只接受一个数字参数。</p>
<p>以下实例返回 3 条文档记录：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myresult = mycol.find().limit(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myresult:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72852'</span>), <span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'alexa'</span>: <span class="string">'100'</span>, <span class="string">'url'</span>: <span class="string">'https://www.taobao.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72853'</span>), <span class="string">'name'</span>: <span class="string">'QQ'</span>, <span class="string">'alexa'</span>: <span class="string">'101'</span>, <span class="string">'url'</span>: <span class="string">'https://www.qq.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72854'</span>), <span class="string">'name'</span>: <span class="string">'Facebook'</span>, <span class="string">'alexa'</span>: <span class="string">'10'</span>, <span class="string">'url'</span>: <span class="string">'https://www.facebook.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><p>我们可以在 MongoDB 中使用 update_one() 方法修改文档中的记录。该方法第一个参数为查询的条件，第二个参数为要修改的字段。<br><strong>如果查找到的匹配数据多余一条，则只会修改第一条。</strong><br>以下实例将 alexa 字段的值为 100 的改为 12345:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myquery = &#123; <span class="string">"alexa"</span>: <span class="string">"100"</span> &#125;</span><br><span class="line">newvalues = &#123; <span class="string">"$set"</span>: &#123; <span class="string">"alexa"</span>: <span class="string">"12345"</span> &#125; &#125;</span><br><span class="line">mycol.update_one(myquery, newvalues)</span><br><span class="line"><span class="comment"># 输出修改后的  "sites"  集合</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mycol.find():</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72852'</span>), <span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'alexa'</span>: <span class="string">'12345'</span>, <span class="string">'url'</span>: <span class="string">'https://www.taobao.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72853'</span>), <span class="string">'name'</span>: <span class="string">'QQ'</span>, <span class="string">'alexa'</span>: <span class="string">'101'</span>, <span class="string">'url'</span>: <span class="string">'https://www.qq.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72854'</span>), <span class="string">'name'</span>: <span class="string">'Facebook'</span>, <span class="string">'alexa'</span>: <span class="string">'10'</span>, <span class="string">'url'</span>: <span class="string">'https://www.facebook.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72855'</span>), <span class="string">'name'</span>: <span class="string">'知乎'</span>, <span class="string">'alexa'</span>: <span class="string">'103'</span>, <span class="string">'url'</span>: <span class="string">'https://www.zhihu.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72856'</span>), <span class="string">'name'</span>: <span class="string">'Github'</span>, <span class="string">'alexa'</span>: <span class="string">'109'</span>, <span class="string">'url'</span>: <span class="string">'https://www.github.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>update_one() 方法只能修匹配到的第一条记录，如果要修改所有匹配到的记录，可以使用 update_many()。<br>以下实例将查找所有以 F 或 Q 开头的 name 字段，并将匹配到所有记录的 alexa 字段修改为 123：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myquery = &#123;<span class="string">"name"</span>: &#123;<span class="string">"$regex"</span>: <span class="string">"^F|^Q"</span>&#125;&#125;</span><br><span class="line">newvalues = &#123;<span class="string">"$set"</span>: &#123;<span class="string">"alexa"</span>: <span class="string">"123"</span>&#125;&#125;</span><br><span class="line">x = mycol.update_many(myquery, newvalues)</span><br><span class="line">print(x.modified_count, <span class="string">"文档已修改"</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> 文档已修改</span><br></pre></td></tr></table></figure></p>
<h3 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h3><p>sort() 方法可以指定升序或降序排序。<br>sort() 方法第一个参数为要排序的字段，第二个字段指定排序规则，1 为升序，-1 为降序，默认为升序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mydoc = mycol.find().sort(<span class="string">"alexa"</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mydoc:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72855'</span>), <span class="string">'name'</span>: <span class="string">'知乎'</span>, <span class="string">'alexa'</span>: <span class="string">'103'</span>, <span class="string">'url'</span>: <span class="string">'https://www.zhihu.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72856'</span>), <span class="string">'name'</span>: <span class="string">'Github'</span>, <span class="string">'alexa'</span>: <span class="string">'109'</span>, <span class="string">'url'</span>: <span class="string">'https://www.github.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72852'</span>), <span class="string">'name'</span>: <span class="string">'Taobao'</span>, <span class="string">'alexa'</span>: <span class="string">'1111'</span>, <span class="string">'url'</span>: <span class="string">'https://www.taobao.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72853'</span>), <span class="string">'name'</span>: <span class="string">'QQ'</span>, <span class="string">'alexa'</span>: <span class="string">'123'</span>, <span class="string">'url'</span>: <span class="string">'https://www.qq.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72854'</span>), <span class="string">'name'</span>: <span class="string">'Facebook'</span>, <span class="string">'alexa'</span>: <span class="string">'123'</span>, <span class="string">'url'</span>: <span class="string">'https://www.facebook.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到并不是按数字大小排序，而是字母序排序</p>
<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>我们可以使用 delete_one() 方法来删除一个文档，该方法第一个参数为查询对象，指定要删除哪些数据。<br>以下实例删除 name 字段值为 “Taobao” 的文档：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myquery = &#123; <span class="string">"name"</span>: <span class="string">"Taobao"</span> &#125;</span><br><span class="line">mycol.delete_one(myquery)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mycol.find():</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72853'</span>), <span class="string">'name'</span>: <span class="string">'QQ'</span>, <span class="string">'alexa'</span>: <span class="string">'123'</span>, <span class="string">'url'</span>: <span class="string">'https://www.qq.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72854'</span>), <span class="string">'name'</span>: <span class="string">'Facebook'</span>, <span class="string">'alexa'</span>: <span class="string">'123'</span>, <span class="string">'url'</span>: <span class="string">'https://www.facebook.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72855'</span>), <span class="string">'name'</span>: <span class="string">'知乎'</span>, <span class="string">'alexa'</span>: <span class="string">'103'</span>, <span class="string">'url'</span>: <span class="string">'https://www.zhihu.com'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5c693d21b2871c1be4e72856'</span>), <span class="string">'name'</span>: <span class="string">'Github'</span>, <span class="string">'alexa'</span>: <span class="string">'109'</span>, <span class="string">'url'</span>: <span class="string">'https://www.github.com'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除多个文档"><a href="#删除多个文档" class="headerlink" title="删除多个文档"></a>删除多个文档</h4><p>我们可以使用 delete_many() 方法来删除多个文档，该方法第一个参数为查询对象，指定要删除哪些数据。<br>删除所有 name 字段中以 F 开头的文档:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myquery = &#123;<span class="string">"name"</span>: &#123;<span class="string">"$regex"</span>: <span class="string">"^F"</span>&#125;&#125;</span><br><span class="line">x = mycol.delete_many(myquery)</span><br><span class="line">print(x.deleted_count, <span class="string">"个文档已删除"</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 个文档已删除</span><br></pre></td></tr></table></figure></p>
<h4 id="删除集合中所有文档"><a href="#删除集合中所有文档" class="headerlink" title="删除集合中所有文档"></a>删除集合中所有文档</h4><p>delete_many() 方法如果传入的是一个空的查询对象，则会删除集合中的所有文档：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = mycol.delete_many(&#123;&#125;)</span><br><span class="line">print(x.deleted_count, <span class="string">"个文档已删除"</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> 个文档已删除</span><br></pre></td></tr></table></figure></p>
<h4 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h4><p>我们可以使用 drop() 方法来删除一个集合。<br>以下实例删除了 sites 集合：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycol.drop()</span><br></pre></td></tr></table></figure></p>
<p>如果删除成功 drop() 返回 true，如果删除失败(集合不存在)则返回 false。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2019/01/15/论文翻译之A-Survey-on-Learning-to-Hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/15/论文翻译之A-Survey-on-Learning-to-Hash/" itemprop="url">
                  论文翻译之A Survey on Learning to Hash
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-15T09:06:36+08:00">
                2019-01-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/15/论文翻译之A-Survey-on-Learning-to-Hash/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/01/15/论文翻译之A-Survey-on-Learning-to-Hash/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>声明：作者翻译论文仅为学习，如有侵权请联系作者删除博文，谢谢！</strong></p>
<h3 id="A-Survey-on-Learning-to-Hash"><a href="#A-Survey-on-Learning-to-Hash" class="headerlink" title="A Survey on Learning to Hash"></a>A Survey on Learning to Hash</h3><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Nearest neighbor search is a problem of ﬁnding the data points from a database such that the distances from them to the query point are the smallest. Learning to hash is one of the major solutions to this problem and has been widely studied recently. In this paper, we present a comprehensive survey of the learning to hash algorithms, categorize them according to the manners of preserving the similarities into: pairwise similarity preserving, multiwise similarity preserving, implicit similarity preserving, as well as quantization, and discuss their relations. We separate quantization from pairwise similarity preserving as the objective function is very different though quantization, as we show, can be derived from preserving the pairwise similarities. In addition, we present the evaluation protocols, and the general performance analysis and point out that the quantization algorithms perform superiorly in terms of search accuracy, search time cost, and space cost. Finally, we introduce a few future directions.</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>最邻近搜索是从数据库里面查找数据点的问题，使他们到查询点的距离最小。学习哈希是这个问题的主要解决方案之一，并且最近被广泛研究，在本文中，我们对哈希算法的学习进行了全面的调查，并根据保持相似性的方式对它们进行分类:成对相似性保持、多向相似性保持，隐式相似性保持以及量化，并讨论它们之间的关系。我们将量化和成对相似性保持分开，因为目标函数是完全不同的，正如我们所示，量化可以从保成对相似性得出，此外，我们提出了评估协议和一般性能分析，并指出量化算法在搜索精度，搜索时间和空间成本方面表现优异，最后我们介绍一些未来的方向。</p>
<p>Index Terms—Similarity search, approximate nearest neighbor search, hashing, learning to hash, quantization, pairwise similarity preserving, multiwise similarity preserving, implicit similarity preserving.<br>索引词：相似性搜索，近似最近邻搜索，散列，学习哈希，量化，保成对相似性，保多向相似性，保隐含相似性</p>
<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p>the problem of nearest neighbor search, also known as similarity search, proximity search, or close item search, is aimed at ﬁnding an item, called nearest neighbor, which is the nearest to a query item under a certain distance measure from a search (reference) database. The cost of ﬁnding the exact nearest neighbor is prohibitively high in the case that the reference database is very large or that computing the distance between the query item and the database item is costly. The alternative approach, approximate nearest neighbor search, is more efﬁcient and is shown to be enough and useful for many practical problems, thus attracting an enormous number of research efforts.<br>最近邻搜索问题，也称为相似性搜索，邻近搜索或者关闭项搜索，旨在找到一个称为最近邻的项，该项在特定距离度量方法上与数据库的查询项最近。在参考数据库非常大或者计算查询量和数据库项之间的距离的代价很高的情况下，找到确切的最邻近的代价非常高。替代方法就是最近邻搜索，它更有效，并且被证明足以用于许多实际问题，因此有大量的研究工作。</p>
<p>Hashing, a widely-studied solution to approximate nearest neighbor search, aims to transforming the data item to a low-dimensional representation, or equivalently a short code consisting of a sequence of bits, called hash code. There are two main categories of hashing algorithms: locality sensitive hashing [29] and learning to hash. Locality sensitive hashing (LSH) is data-independent. The research efforts mainly come from the theory community, such as proposing random hash functions satisfying the local sensitive property for various distance measures [5], [6], [7], [10], [11], [69], [78], proving better search efﬁciency and accuracy [10], [80], and developing better search schemes [15], [67], and the machine learning community, such as developing hash functions providing a similarity estimator with smaller variance [47], [37], [51], [36], or smaller storage [49], [50], or faster computation of hash functions [48], [51], [36], [88].<br>哈希是一种广泛研究的最近邻搜索的解决方案，旨在将数据项转换成低维表示，或者等效成一个短的比特序列，称为哈希码。哈希算法主要有两类：局部敏感哈希和学习哈希算法，局部敏感哈希与数据无关。研究工作主要来自理论界，比如提出满足各种距离测量的局部铭感哈希性的随机哈希函数[5], [6], [7], [10], [11], [69], [78]，证明了更好的搜索效率和准确性[10], [80],并开发了更好的搜索方案[15], [67]和机器学习社区，例如开发哈希函数，提供具有较小方差的相似性估计更快地哈希函数计算[48], [51], [36], [88].</p>
<p>Learning to hash, the interest in this survey, is a datadependent hashing approach, which aims to learn hash functions from a speciﬁc dataset so that the nearest neighbor search result in the hash coding space is as close to the search result in the original space as possible, and the search cost and the space cost are also small. Since the pioneering algorithm, spectral hashing [107], learning to hash has been attracting a large amount of research interests in computer visionand machine learningand has beenappliedto a widerange of applications such as large scale object retrieval [33], image classiﬁcation and detection [85] [94], and so on.<br>学习哈希，是一种数据相关的哈希方法，旨在从特定的数据集中学习哈希函数，使哈希编码空间中最近邻搜索结果和原始空间中搜索结果尽可能接近，并且搜索成本和空间成本很小。自从开创算法，谱哈希以来没学习哈希已经吸引了大量计算机视觉和机器学习的研究，并且已经被广泛应用，如大规模检索，图像分类和检测等。</p>
<p>The main methodology of learning to hash is similarity preserving, i.e., minimizing the gap between the similarities or similarity orders computed/given in the original space and in the hash coding space in various forms. The similarity in the original space might be from the semantic (class) information, or from the distance (e.g., Euclidean distance) computed in the original space, which is more widely interested and studied in most real applications, e.g., large scale search by image and image classiﬁcation, and thus the main focus in this paper.<br>学习哈希的主要方法是保相似性，即以各种形式最小化在初始空间和哈希编码空间中计算得相似性或相似性次序之间的距离。原始空间中的相似性可以来自语义信息，或者来自原始空间中的计算的距离，其在大多数实际应用中被广泛的研究，例如大规模搜索图像和图像分类，因而是本文的主要焦点</p>
<p>This survey categorizes the algorithms according to the similarity preserving manners into: pairwise similarity preserving, multiwise similarity preserving, implicit similarity preserving, and quantization that, we show, is a form of pairwise similarity preserving, and discusses other problems, including evaluation datasets and schemes, online search given the hash codes, and so on. In addition, we present the empirical observation that the quantization approach outperforms other approaches and give some analysis about this observation. Finally, we point out the future directions, such as an end-to-end learning strategy for real applications, directly learning the hash codes from the object, e.g., image, instead of ﬁrst learning the representations and then learning the hash codes from the representations.<br>该调查根据相似性保持方法吧算法分类为：成对相似性保持、多向相似性保持，隐式相似性保持以及量化，我们表明，这是一种成对相似性保持的形式，并讨论了其他问题，包括评估数据集和方案，在线搜索出哈希码，等等。此外，我们提出了经验观察，即量化方法优于其他方法，并对此观察进行了一些分析。最后，我们指出未来的方向，例如实际应用端到端学习策略，直接从对象学习哈希码，例如图像，而不是先学习表示，然后从表示中学习哈希码。</p>
<h4 id="1-1-Organization-of-This-Paper"><a href="#1-1-Organization-of-This-Paper" class="headerlink" title="1.1 Organization of This Paper"></a>1.1 Organization of This Paper</h4><p>The organization of the remaining part is given as the following. Section 2 introduces the exact and approximate nearest neighbor searchproblems,and the searchalgorithms with hashing. Section 3 provides the basic concepts in the learning-to-hashing approach and categorizes the existing algorithms from the perspective of loss function into four main classes: pairwise alignment, multiple-wise alignment,implicit alignment and quantization, which are discussed in Sections 4, 5, 6, and 7, respectively. Section 8 presents other works in learning to hash. Sections 9 and 10 gives some evaluation protocols and performance analysis. Finally, Sections 11 and 12 point out the future research trends and conclude this survey, respectively.</p>
<h4 id="1-1-本文的组织"><a href="#1-1-本文的组织" class="headerlink" title="1.1 本文的组织"></a>1.1 本文的组织</h4><p>其余部分的组织如下，第2节介绍精确和近似的最近邻搜索问题，以及使用哈希的搜索算法，第3节提供了学习哈希的基本概念，并将现有算法从损失函数的角度分为四类，成对对齐,多向对齐，隐式对齐和量化，分别在第4,5,6，7节中讨论。第8节介绍了学习哈希的其他工作。第9节和第10节中给出了评估协议和性能分析。最后在11和12节分别指出了未来的研究趋势并总结了这项研究。</p>
<h3 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2 BACKGROUND"></a>2 BACKGROUND</h3><h4 id="2-1-Nearest-Neighbor-Search"><a href="#2-1-Nearest-Neighbor-Search" class="headerlink" title="2.1 Nearest Neighbor Search"></a>2.1 Nearest Neighbor Search</h4><p>Exact nearest neighbor search is deﬁned as searching an item NN(q) (called nearest neighbor) for a query N item q from a set of items X = {x1,x2,··· ,xN} so that NN(q) = argminx∈X dist(q,x), where dist(q,x) is a distance computed between q and x. A straightforward generalization is K-NN search, where K nearest neighbors (KNN(q)) are needed to be found.</p>
<h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2 背景"></a>2 背景</h3><h4 id="2-1-最近邻搜索"><a href="#2-1-最近邻搜索" class="headerlink" title="2.1 最近邻搜索"></a>2.1 最近邻搜索</h4><p>精确最近邻搜索被定义为搜索一个项NN(q)(称为最近邻居),从一组项$\chi=\{x_1,x_2,……,x_n\}$查询N项得到$NN(q) = argmin_{x\in \chi}dist(q,x)$,其中$dist(q,x)$是q和x之间计算的距离，简单的推广是KNN搜索，其中需要找到K个最近邻居$(KNN(q))$。</p>
<p>The distance between an arbitrary pair of items x and q depends on the speciﬁc nearest search problem. A typical example is that the search (reference) database X lies in a d-dimensional space Rd and the distance is induced by an ls norm, kx − qks = (Pd i=1 |xi − qi|s)1/s. The search problem under the Euclidean distance, i.e., the l2 norm, is widely studied. Other notions of the search database, for example, the data item is formed by a set, and distance measures,such as ℓ1 distance, cosine similarity and so on, are also possible.<br>任意一对项x和q之间的距离取决于特定的最近搜索问题。一个典型的例子就是搜索数据库$\chi$位于d维空间$\mathbb{R}^d$,距离是由$l_s$范数引起，$\left|x-q\right|_s = (\sum_{i=1}^{d}{\left|x_i-q_i\right|}^s)^{1/s}$。欧几里得距离下的搜索问题，即$l_2$范数，是广泛的研究。搜索数据库的其他概念，如数据项是由一组形成的，距离测量例如$l_1$距离，余弦相似性等等也是可能的。</p>
<p>There exist efﬁcient algorithms (e.g., k-d trees and its variants) for exact nearest neighbor search in lowdimensional cases. In large scale high-dimensional cases, it turns out that the problems become hard and most algorithms even take higher computational cost than the naive solution, linear scan. Therefore, a lot of recent efforts are moved to search approximate nearest neighbors: (1 + ǫ)approximate nearest neighbor search [29], which is studied mainly in the theory community, and time-ﬁxed approximate nearest neighbor search. Other nearest neighbor search problems include (approximate) ﬁxed-radius near neighbor (R-near neighbor) problem, and randomized nearest neighbor search which the locality sensitive hashing research community is typical interested in.<br>在低维情况下存在用于精确最近邻搜索的有效算法，例如k-d树及其变体。在大规模的高维情况下，事实证明问题变得困难，并且大多数算法甚至比简单的解决方案线性扫描花费更高的计算成本。因此，最近很多工作转移到搜索近似最近邻：$(1+\epsilon)$-近似最近邻搜索，其主要在理论界研究，并且时间固定近似最近邻走索。其他最近邻搜索问题包括(近似)固定半径近邻(R近邻)问题，以及局部敏感哈希研究社区通常感兴趣的随机最近邻搜索</p>
<p>Time-ﬁxed approximate nearest neighbor search is studied mainly in machine learning and computer vision for real applications, such as the learning to hash approach, though there is usually lack of elegant theory. The goal is to make the average search as accurate as possible by comparing the returned K approximate nearest neighbors and the K exact nearest neighbors, and the query cost as small as possible.<br>时间固定近似最近邻搜索主要在及其学习和计算机视觉中用于实际应用，例如学习哈希方法，尽管通常缺乏理论基础，目标是通过比较返回的K近似最近邻和K精确最近邻来使得平均搜索尽可能准确，并且查询成本尽可能小。</p>
<h4 id="2-2-Search-with-Hashing"><a href="#2-2-Search-with-Hashing" class="headerlink" title="2.2 Search with Hashing"></a>2.2 Search with Hashing</h4><p>The hashing approach aims to map the reference (and query) items to the target items so that approximate nearest neighbor search is efﬁciently and accurately performed by resorting to the target items and possibly a small subset of the raw reference items. The target items are called hash codes (also known as hash values, simply hashes). In this paper, we may also call it short/compact codes interchangeably.</p>
<h4 id="2-2-使用哈希搜索"><a href="#2-2-使用哈希搜索" class="headerlink" title="2.2 使用哈希搜索"></a>2.2 使用哈希搜索</h4><p>哈希方法旨在将参考（和查询）项映射到目标项，以便通过目标项和可能的原始参考项的一小部分来有效且准确地执行近似最近邻搜索。目标项被称为哈希码。在本文中，我们也可以将他称为短/紧凑码。</p>
<p>The hash function is formally deﬁned as: y = h(x), where y is the hash code, and may be a binary value, 1 and 0 (or −1) or an integer, and h(·) is the hash function. In the application to approximate nearest neighbor search, usually several hash functions are used together to compute the compound hash code: y = h(x), where y = [y1 y2 ··· yM]T and h(x) = [h1(x) h2(x) ··· hM(x)]T . Here we use a vector y to represent the compound hash code for convenience.<br>哈希函数形式上定义为：$y = h(x)$,其中y是哈希码，也可能是二进制值，1和0或证书，h(*)是哈希函数。在近似最近邻搜索的应用中，通常使用几个哈希函数来计算复合哈希码：$y = h(x)$,其中$y = {[y_1,y_2,\cdots,y_m]}^t$,并且$h(x) = [h_1(x)h_2(x)\cdots h_M(x)]^t$，为了方便起见这里我们使用一个向量来表示复合哈希码。</p>
<p>There are two basic strategies for using hash codes to perform nearest (near) neighbor search: hash table lookup and hash code ranking. The search strategies are illustrated in Figure 1.<br>使用哈希码有两种最基本的策略执行最近邻搜索：哈希表查找和哈希码排名。搜索策略如图1所示。<br><img src="/assets/图1.png" alt="图1"><br>Fig. 1. Illustrating the search strategies. (a) Multi table lookup: the list corresponding to the hash code of the query in each table is retrieved. (b) Single table lookup: the lists corresponding to and near to the hash code of the query are retrieved. (c) Hash code ranking: compare the query with each reference item in the coding space. (d) Non exhaustive search: hash table lookup (or other inverted index struture) retrieves the candidates, followed by hash code ranking over the candidates. The hash codes are different in two stages.<br>图1。说明搜索策略。（a）多表查找：检索与每个表中的查询的哈希码对应的列表。（b）单表查找：检索与查询的哈希码对应和接近的列表。（c）哈希码排名：将查询与编码空间中的每个参考项进行比较。（d）非穷举搜索：哈希表查找（或其他反向索引结构）检索候选者，然后对候选者进行哈希码排名。 哈希码在两个阶段中是不同的。</p>
<p>The main idea of hash table lookup for accelerating the search is to reduce the number of the distance computations from N to N′ (N ≫ N′), and thus the time complexity is reduced from O(Nd) to O(N′d). The data structure, called hash table (a form of inverted index), is composed of buckets with each indexed by a hash code. Each reference item x is placed into a bucket h(x). Different from the conventional hashing algorithm in computer science that avoids collisions (i.e., avoids mapping two items into some same bucket), the hashing approach using a hash table aims to maximize the probability of collision of near items. Given the query q, the items lying in the bucket h(q) are retrieved as the candidates of the nearest items of q, usually followed by a reranking step: rerank the retrieved nearest neighbor candidates according to the true distances computed using the original features and attain the K nearest neighbors or R-near neighbors<br>用于加速搜索的哈希表查找的主要思想是将距离计算的数量从$N$减少到$N’(N\to N’)$,从而减少时间复杂度，从$O(Nd)$减少到$O(N’d)$。数据结构称为哈希表（一种倒排索引的形式），由组成每个桶由哈希码索引。每个参考项目x被放入桶$h(x)$中。与避免冲突的计算机科学中的传统哈希算法不同（即避免两个项映射到同一个桶中），使用哈希表的哈希方法旨在最大化近项目的冲突概率。给定查询q，检索位于h(q)中的项作为q的最近项的候选，通常接着的是重新排名的步骤：重新排名被检索到的最近邻候选，根据使用原始特征计算的真实距离并获得K个最近邻或R近邻。</p>
<p>To improve the recall, two ways are often adopted. The ﬁrst way is to visit a few more buckets (but with a single hash table), whose corresponding hash codes are the nearest to (the hash code of) the query h(q) in terms of the distances in the coding space. The second way is to construct more hash tables. The items lying in the L hash buckets h1(q),··· ,hL(q) are retrieved as the candidates of near items of q. To guarantee the high precision, each of the L hash codes, yi, needs to be a long code. This means that the total number of the buckets is too large to index directly, and thus, the buckets that are nonempty are retained by using conventional hashing of the hash codes hl(x).<br>为了改善召回率，通常采用两种方式。第一种方法是访问几个桶（使用单个哈希表），其对应的哈希码就编码空间的距离而言最接近查询h(q)的哈希码。第二种方法是构造更多的哈希表。位于L哈希桶$h_1(q),h_2(q) \cdots,h_L(q)$中的项被检索为最靠近q的项目。为了保证高精度，每个L哈希码$y_i$需要是长码。这意味着桶的总数太大而不能直接索引，因此，通过使用散列码$h_1(x)$的常规哈希来保留非空的桶。</p>
<p>The second way essentially stores multiple copies of the id for each reference item. Consequently, the space cost is larger. In contrast, the space cost for the ﬁrst way is smaller as it only uses a single table and stores one copy of the id for each reference item, but it needs to access more buckets to guarantee the same recall with the second way. The multiple assignment scheme is also studied: construct a single table, but assign a reference item to multiple hash buckets. In essence, it is shown that the second way, multiple hash tables, can be regarded as a form of multiple assignment.<br>第二种方法基本上存储了多个副本和每个参考项的id，因此，空间成本更大。相比之下，第一种方式的空间成本较小，因为它只使用一个表并为每个参考项存储一个id的副本，但它需要访问更多的桶来保证与第二种方式相同的召回率。还研究了多重分配方案：构造单个表，但将参考项分配给多个哈希桶。本质上，它表明多个哈希表的方式可以被视为多重赋值的一种形式。</p>
<p>Hash code ranking performs an exhaustive search: compare the query with each reference item by fast evaluating their distance (e.g., using distance table lookup or using the function popcnt for Hamming distance) according to (the hash code of) the query and the hash code of the reference item, and retrieve the reference items with the smallest distances as the candidates of nearest neighbors. Usually this is followed by a reranking step: rerank the retrieved nearest neighbor candidates according to the true distances computed using the original features and attain the K nearest neighbors or R-near neighbors.<br>哈希码排名执行穷举搜索：通过快速评估距离，将查询与每个参考项进行比较，（例如，根据查询的哈希码和参考项的哈希码，使用距离表查找或使用popcnt函数计算汉明距离），并检索具有最小距离的参考项作为最近邻居的候选者。通常，这之后是重新排名步骤：根据使用原始特征计算的真实距离重新获得检索的最近邻居候选者，并获得K个最近邻居或R邻近邻居。</p>
<p>This strategy exploits one main advantage of hash codes: the distance using hash codes is efﬁciently computed and the cost is much smaller than that of the computation in the original input space, reduced from d to d′ where d ≫ d′ and the whole cost is reduced from Nd to Nd′.<br>该策略利用哈希码的一个主要优点：使用哈希码的距离得到有效计算，成本远小于原始输入空间中的计算成本，从$d$减少到$d’$，其中$d\to d’$和整个成本从$Nd$减少到$Nd’$。</p>
<p>Comments: Hash table lookup is mainly used in locality sensitive hashing, and has been used for evaluating learning to hash in a few publications. It is observed that hash table lookup with binary hash codes shows inferior performance and hence rarely adopted in reality, while hash table lookup with quantization-based hash codes, is widely used in the non-exhaustive strategy to retrieve coarse candidates. In comparison to hash table lookup, hash code ranking is superior in search accuracy while inferior in search efﬁciency, and overall performs better, and thus more widely used in real applications and in experimental evaluations.<br>注释：哈希表查找主要用于局部敏感哈希，并在一些出版物中已用于评估学习哈希。 据观察，使用二进制哈希码的哈希表查找显示出较差的性能，因此在现实中很少采用，而基于量化的哈希码的哈希表查找被广泛用于非穷举策略以检索粗略候选。与哈希表查找相比，哈希码排名在搜索精度方面优越，而在搜索效率方面较差，并且整体表现更好，因此在实际应用和实验评估中更广泛地使用。<br>A practical way is to do a non-exhaustive search: ﬁrst retrieve a small set of candidates using inverted index, and then compute the distances of the query with the candidates using the hash codes, providing the top candidates subsequently reranked using the original features. Other research efforts include organizing the hash codes to avoid exhaustive search with a data structure, such as a tree or a graph structure [73].<br>一种实用的方法是进行非详尽搜索：首先使用倒排索引检索一小组候选，然后使用哈希码计算查询与候选的距离，提供随后使用原始特征重新排序的顶级候选。其他研究工作包括组织哈希码以避免使用数据结构进行穷举搜索，例如树或图结构[73]。</p>
<h3 id="3-LEARNING-TO-HASH"><a href="#3-LEARNING-TO-HASH" class="headerlink" title="3 LEARNING TO HASH"></a>3 LEARNING TO HASH</h3><p>Learning to hash is a task of learning a (compound) hash function, y = h(x), mapping an input item x to a compact<br>code y, with the goals: the nearest neighbor search result for a query q is as close to the true nearest search result as possible and the search in the coding space is also efﬁcient. A learning-to-hash approach needs to consider three problems for computing the hash codes: what hash function h(x) is adopted, what similarity in the coding space is used and what similarity is provided in the input space, what loss function is chosen for the optimization objective.</p>
<h3 id="学习哈希"><a href="#学习哈希" class="headerlink" title="学习哈希"></a>学习哈希</h3><p>学习哈希是学习（复合）哈希函数的任务，y = h（x），将输入项x映射到紧凑码y，具有目标：查询q的最近邻搜索结果尽可能接近真实的最近搜索结果，并且在编码空间中的搜索也是有效的。学习哈希方法需要考虑计算哈希码的三个问题：采用什么哈希函数h（x），在编码空间中使用什么相似性以及在输入空间中提供什么相似性，什么是损失函数 被选择用于优化目标。</p>
<h4 id="3-1-Hash-Function"><a href="#3-1-Hash-Function" class="headerlink" title="3.1 Hash Function"></a>3.1 Hash Function</h4><p>The hash function can be a form based on linear projection, kernels, spherical function, neural network, a nonparametric function, and so on. One popular hash function is the linear hash function: <script type="math/tex">y = h(x) = sgn(w^Tx + b). (1)</script>where sgn(z) = 1 if z &gt; 0 and sgn(z) = 0 (or equivalently −1) otherwise, w is the projection vector, and b is the bias variable. The kernel function,<script type="math/tex">y = h(x) = sgn(\sum_{t=1}^{T}w_tK(s_t,x)+b.(2)</script>is also adopted in some approaches, where {st} is a set of representative samples that are randomly drawn from the dataset or cluster centers of the dataset. and {wt} are the weights. The non-parametric function based on nearest vector assignment is widely used for quantization-based solutions:<script type="math/tex">y = arg\min_{k\in\{1,···,K\}}\|x-c_k\|_2.(3)</script>where {c1,··· ,cK} is a set of centers computed by some algorithm, e.g., K-means and $y\in Z$ is an integer. In contrast to other hashing algorithms in which the distance, e.g., Hamming distance, is often directly computed from hash codes, the hash codes generated from the nearest vector assignment-based hash function are the indices of the nearest vectors, and the distance is computed using the centers corresponding to the hash codes.<br>哈希函数可以是基于线性投影，核函数，球函数，神经网络,非参数函数等形式，一种流行的哈希函数是线性哈希函数<script type="math/tex">y = h(x) = sgn(w^Tx + b). (1)</script>其中如果z&gt; 0，sgn(z)= 1否则sgn（z）= 0（或等效-1），w是投影矢量，b是偏差变量。内核函数<script type="math/tex">y = h(x) = sgn(\sum_{t=1}^{T}w_tK(s_t,x)+b.(2)</script>在一些方法中也被采用，其中{st}是从数据集的数据集或聚类中心随机抽取的一组代表性样本。 和{wt}是权重。 基于最近矢量分配的非参数函数广泛用于基于量化的解决方案：<script type="math/tex">y = arg\min_{k\in\{1,···,K\}}\|x-c_k\|_2.(3)</script>其中$\{c_1,\cdots,c_K\}$是由一些算法计算的一组中心，例如，K-means和$y\in Z$是整数。 与通常直接从哈希码计算距离（例如汉明距离）的其他哈希算法相比，从最近的基于向量分配的哈希函数生成的哈希码是最近向量的索引，并且计算距离使用与哈希码对应的中心。</p>
<p>Hash functions are an important factor inﬂuencing the search accuracy using the hash codes, as well as the time cost of computing hash codes. A linear function is efﬁciently evaluated, while the kernel function and the nearest vector assignment based function leads to better search accuracy as they are more ﬂexible. Almost all the methods using a linear hash function can be extended to kernelized hash functions. Thus we do not use hash functions to categorize the hash algorithms.<br>哈希函数是使用哈希码影响搜索准确性的重要因素，以及计算哈希码的时间成本。线性函数被有效地评估，而核函数和最近的基于向量分配的函数导致更好的搜索准确性，因为它们更灵活。几乎所有使用线性哈希函数的方法都可以扩展到内核哈希函数。因此，我们不使用哈希函数来分类哈希算法。<br>There are various algorithms developed and exploited to optimize the hash function parameters. We summarize the common ways to handle the sgn function which is a main factor leading to the difﬁculty of estimating the parameters (e.g., the projection vector w in the linear hash function). There are roughly three approximation estimation schemes. The ﬁrst one is a continuous relaxation, e.g., sigmoid relaxation sgn(z) ≈ φα(z) = 1 1+e−αz . The second one is directly dropping the sign function sgn(z) ≈ z. The third one is a two-step scheme [53], [54] with its extension to iterative two step optimization [17]: optimizing the binary codes without considering the hash function, followed by estimating the function parameters from the optimized hash codes.<br>开发并利用各种算法来优化哈希函数参数。我们总结了处理sgn函数的常用方法，这是导致估计参数的困难的主要因素（例如，线性散列函数中的投影向量w）。大致有三种近似估计方案。 第一个是连续松弛，例如，S形弛豫sgn（z）≈φα（z）= 11 + e-αz。 第二个是直接丢弃符号函数sgn（z）≈z。 第三个是两步方案[53]，[54]，它扩展到迭代两步优化[17]：优化二进制代码而不考虑哈希函数，然后从优化的哈希码估计函数参数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2019/01/11/文本向量化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/11/文本向量化/" itemprop="url">
                  文本向量化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T10:18:42+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/11/文本向量化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/01/11/文本向量化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>文本向量化是将文本表示成一系列能够表达文本语义的向量</p>
<h3 id="向量化算法word2vec"><a href="#向量化算法word2vec" class="headerlink" title="向量化算法word2vec"></a>向量化算法word2vec</h3><p>词袋模型是最早的以词语为基本单位的文本向量化方法，下面举例说明改方法的原理。首先给出两个简单的文本如下<br>John likes to watch movies, Mary likes too.<br>John also likes to watch football games.</p>
<p>基于上述文档中出现的单词构建如下词典(dictionary)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"John"</span>:<span class="number">1</span>,<span class="string">"likes"</span>:<span class="number">2</span>,<span class="string">"to"</span>:<span class="number">3</span>,<span class="string">"watch"</span>:<span class="number">4</span>,<span class="string">"movies"</span>:<span class="number">5</span>,<span class="string">"also"</span>:<span class="number">6</span>,<span class="string">"football"</span>:<span class="number">7</span>,<span class="string">"games"</span>:<span class="number">8</span>,<span class="string">"Mary"</span>:<span class="number">9</span>,<span class="string">"too"</span>:<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面词典中包含10个单词，每个单词有唯一的索引，那么每个文本我们可以使用一个10维的向量来表示。如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>上面是每个单词在文本中出现的频率，和原本文本中单词出现的顺序没有关系</p>
<p><strong>缺点：</strong><br>1.唯独灾难，如果有10000个单词，需要10000维的向量表示<br>2.无法保留词序信息<br>3.存在语义鸿沟的问题</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2018/07/26/改善深层神经网络之深度学习的实用层面/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/26/改善深层神经网络之深度学习的实用层面/" itemprop="url">
                  改善深层神经网络之深度学习的实用层面
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-26T09:40:53+08:00">
                2018-07-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/26/改善深层神经网络之深度学习的实用层面/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/26/改善深层神经网络之深度学习的实用层面/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Settiing-up-your-ML-application"><a href="#Settiing-up-your-ML-application" class="headerlink" title="Settiing up your ML application"></a>Settiing up your ML application</h3><p>Train/dev/test sets<br>应用型机器学习是一个高度的迭代过程</p>
<p>训练神经网络时通常要做出很多决策：<br>神经网络分多少层<br>每层有多少个隐藏单元<br>学习速率是多少<br>各层采用哪种激活函数</p>
<p>为了找到更好的神经网络需要不断迭代更新自己的方案</p>
<p>数据集通常被分为数据集 验证集 测试集</p>
<p>数据集规模较小时，适用传统的划分比例<br>数据集规模较大时，验证集和测试集可以占到数据总量的10%以下</p>
<p>要确保训练和测试集来自同一分布</p>
<h3 id="Bias-and-Variance"><a href="#Bias-and-Variance" class="headerlink" title="Bias and Variance"></a>Bias and Variance</h3><p><img src="/2018/07/26/改善深层神经网络之深度学习的实用层面/拟合.png" alt="拟合"><br>欠拟合，适度拟合和过拟合</p>
<p>可以通过几个指标来研究偏差和方差<br>理解偏差和方差两个关键指标数据是训练集误差和验证集误差<br>训练集误差小，验证集误差大：过拟合，高方差<br>训练集误差大，验证集误差大：欠拟合，高偏差<br>训练集误差大，验证集误差更大：可能部分过拟合部分欠拟合，高方差高偏差<br>最优误差/贝叶斯误差：如果最优误差很高，训练集误差验证集误差大也很正常</p>
<h3 id="Basic-recipe-for-machine-learning"><a href="#Basic-recipe-for-machine-learning" class="headerlink" title="Basic recipe for machine learning"></a>Basic recipe for machine learning</h3><p>高偏差：规模更大的网络结构，延长训练时间<br>高方差：采集更多数据，正则化减少过拟合</p>
<h3 id="Regularizing-your-neural-network"><a href="#Regularizing-your-neural-network" class="headerlink" title="Regularizing your neural network"></a>Regularizing your neural network</h3><h4 id="Logistic-regression"><a href="#Logistic-regression" class="headerlink" title="Logistic regression"></a>Logistic regression</h4><script type="math/tex; mode=display">\min_{w,b} J(w,b)</script><script type="math/tex; mode=display">J(w,b) = \frac {1}{m} \sum_{i=1}^{m} L({\hat{y}^{(i)},y^{(i)}}) + \frac{\lambda}{2m}{\left\|w\right\|}^2_2</script><script type="math/tex; mode=display">{\left\|w\right\|}^2_2 = \sum_{j=1}^{n_x}w^2_j = w^Tw</script><p>L2正则化</p>
<h3 id="Neural-network"><a href="#Neural-network" class="headerlink" title="Neural network"></a>Neural network</h3><p>在神经网络中实现正则化</p>
<script type="math/tex; mode=display">J(w^{[1]},b^{[1]},...,w^{[L]},b^{[L]},) = \frac{1}{m}\sum_{i=1}^{m}L({\hat{y}^{(i)},y^{(i)}})+\frac{\lambda}{2m}\sum_{l=1}^{L}{\left\|w^{[l]}\right\|}^2_F</script><script type="math/tex; mode=display">{\left\|w^{[l]}\right\|}^2_F = \sum_{i=1}^{n^{[l-1]}}\sum_{j=1}^{n^{[l]}}(w^{[l]}_{ij})^2</script><script type="math/tex; mode=display">w:(n^{[l-1]},n^{[l]})</script><p>L是网络层数。下面的矩阵范数被定义为矩阵中所有元素的平方求和。这个范数被称为Frobenius norm</p>
<p>如何使用该范数进行梯度下降？用backprop计算出$\frac{\partial J}{\partial w^{[L]}}$</p>
<p>然后加上正则项：</p>
<script type="math/tex; mode=display">dw^{[l]} = (form backup) +\frac{\lambda}{m}w^{[l]}</script><p>然后更新权重</p>
<script type="math/tex; mode=display">w^{[l]} := w^{[l]} - \alpha dw^{[l]}</script><p>这就是L2正则化有时被称为权重衰减的原因</p>
<h3 id="Why-regularization-reduces-overfitting"><a href="#Why-regularization-reduces-overfitting" class="headerlink" title="Why regularization reduces overfitting"></a>Why regularization reduces overfitting</h3><p>假设我们面对的是这样一个网络模型<br><img src="/2018/07/26/改善深层神经网络之深度学习的实用层面/网络模型.jpg" alt="网络模型"><br>如果正则话$\lambda$设置足够大，那么会导致权重矩阵W被设置为接近0的值，即$W[l] \approx 0$。本质上就是把许多隐藏层的权值设为0，尝试消除隐藏层对整个网络的影响。可以看作<br><img src="/2018/07/26/改善深层神经网络之深度学习的实用层面/网络模型2.jpg" alt="网络模型2"><br>这个被大大简化的网络会变成一个很小的网络，能小到如同线性单元，但深度还是很大，网络会从过拟合状态变得更接近高偏差的状态</p>
<p><img src="/2018/07/26/改善深层神经网络之深度学习的实用层面/fitting.jpg" alt="fitting"><br>过拟合和欠拟合都有些极端，需要找到一个这种的$\lambda$，使得拟合成拟合适中的情况</p>
<h3 id="Dropout-Regularization"><a href="#Dropout-Regularization" class="headerlink" title="Dropout Regularization"></a>Dropout Regularization</h3><p>随机失活<br>原理：随机删除神经网络单元，具体做法是对神经网络的各个单元，以抛硬币的方式来决定其去留，这样会大大简化神经网络，对简化后的神经网络进行训练</p>
<p>如何实施Dropout正则化？<br>Inverted dropout(反向随机失活)</p>
<p>举例在一层中如何实现的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># keep_prob表示保留某个隐藏单元的概率</span></span><br><span class="line">l = <span class="number">3</span>,keep_prob = <span class="number">0.8</span></span><br><span class="line"><span class="comment"># 向量d3表示第三层的dropout向量：是一个随机矩阵，决定哪些单元归零</span></span><br><span class="line">d3 = np.random.rand(a3.shape[<span class="number">0</span>],a3.shape[<span class="number">1</span>])</span><br><span class="line">a3 = np.multiply(a3,d3)</span><br><span class="line"><span class="comment"># 通过除以keep_prob来确保a3的期望值不变</span></span><br><span class="line">a3 /= keep_prob</span><br></pre></td></tr></table></figure></p>
<h3 id="Understanding-Dropout"><a href="#Understanding-Dropout" class="headerlink" title="Understanding Dropout"></a>Understanding Dropout</h3><p>为什么随机失活会起作用</p>
<p><strong>第一种理解：</strong> Drop通过每次迭代时，神经网络都会变得比以前小，使用一个更小的神经网络看起来和正则化是一样的</p>
<p><strong>第二种理解：</strong> 从单个神经元的角度，神经元的作用是接收输入并生成一些有意义的输出，而通过dropout，神经元会随机删除，也就是当前神经元不能依赖任一输入神经元，所以不会给任何一个输入加上太多权重，因此单元将通过这种方式积极传播开，并为其每个输入单元各加适量权重，通过传播所有权重，dropout将产生压缩权重的平方范数的效果，这就和L2正则化类似，通过压缩权重，防止过拟合，但对不同权重的衰减是不同的，取决于倍增激活函数的大小</p>
<p>dropout正则化是预防过拟合，一般不会应用dropout正则化，而dropout主要应用于计算机视觉，因为这个领域数据量不足够打，且输入层的维度很高，容易存在过拟合的问题。</p>
<p>dropout的一个缺点是成本函数J不再被明确定义，因为每次迭代都会随机删除一些节点，成本函数的计算变得非常困难，所以绘制成本函数和迭代次数的曲线就非常困难，通常的做法是先关掉dropout函数，运行单吗，确保成本函数是单调递减的，然后再打开dropout函数</p>
<h3 id="Other-regularization-methods"><a href="#Other-regularization-methods" class="headerlink" title="Other regularization methods"></a>Other regularization methods</h3><ol>
<li><p>扩增数据<br>如果扩增数据的代价很大，可以增加假数据，比如对于图片数据，可以对其水平翻转或其他角度旋转，剪裁，扭曲，这样既节省花费又能有效预防过拟合。<br><img src="/2018/07/26/改善深层神经网络之深度学习的实用层面/dataaugmentation.png" alt="dataaugmentation"></p>
</li>
<li><p>提早停止训练神经网络<br>在梯度下降中，一般会绘制成本函数和迭代次数的曲线，在early-stopping中需要加上验证集误差Jdev，成本函数应该是单调递减，二验证集误差一般是先下降后上升，一旦验证集误差开始上升，就可以停止梯度下降，选择验证集误差最小的点，即可以认为是最优解。</p>
</li>
</ol>
<p>优点：只运行一次梯度下降，就能找到最合适的参数</p>
<p>缺点：机器学习的步骤中，其中之一是选择一个算法来优化代价函数J，如梯度下降、momentum、RMSprop、Adam等;优化代价函数之后又不想过拟合，在机器学习中已经有很多超参数要选择，要在那么多算法中选出最合适的算法也变得越来越复杂，为了能让问题变得更简单点，当我们用工具优化代价函数J的时候，只关心w和b，使得J越小越好，只要想办法减小J；而防止过拟合，用另外一套工具实现。一个时间只做一件事，这种思路称为正交化，而提前停止训练却将两件事都做了，使得需要考虑的问题变得更复杂，可能使代价函数不够小。</p>
<h3 id="Normalizing-Inputs"><a href="#Normalizing-Inputs" class="headerlink" title="Normalizing Inputs"></a>Normalizing Inputs</h3><p>归一化输入需要两步:</p>
<ol>
<li>均值归零： $x = x - \mu$  $\mu$是均值</li>
<li>归一化方差： $x = \frac{x}{\sigma ^2}$</li>
</ol>
<p><img src="/2018/07/26/改善深层神经网络之深度学习的实用层面/normlize.png" alt="normlize"></p>
<p><strong>为什么要归一化输入数据</strong><br>输入数据取值范围相差大，会导致对应参数w也相差较大，就必须使用一个比较小的学习率，来避免J发生震荡，这样可能需要很多次迭代才能找到最小值，均值归一化之后的在梯度下降算法中可以使用较大的步长。</p>
<h3 id="vanishing-exploding-gradients"><a href="#vanishing-exploding-gradients" class="headerlink" title="vanishing/exploding gradients"></a>vanishing/exploding gradients</h3><p>神经网络中，由于权重的叠加效应，激活函数以及梯度都会随着层数的增加而呈指数增长或降低，当层数较大时，激活函数或梯度就容易出现爆炸或消失的情况</p>
<p>可以通过对权重初始化的优化来改善，输入层神经元越多，得到的z就越大，为了防止梯度消失或爆炸，可以使其权重除以输入层神经元$n^{[l-1]}$的个数</p>
<p>对于ReLU：$W = W <em> \sqrt {\frac {1}{n^{[l-1]}}}$<br>对于tanh：$W = W </em> \sqrt {\frac {2}{n^{[l-1]}}}$<br>还有一种是：$W = W * \sqrt {\frac {2}{n^{[l-1]}+n^{[l]}}}$</p>
<h3 id="Gradient-Checking"><a href="#Gradient-Checking" class="headerlink" title="Gradient Checking"></a>Gradient Checking</h3><ol>
<li><p>梯度的数值逼近<br>双边误差的值近似导数值，所以可以利用这一特征检查梯度正确性</p>
</li>
<li><p>梯度检验<br>可以通过梯度检验来检查backprop的实施是否正确</p>
</li>
</ol>
<p>梯度检查首先要做的是分别将这些矩阵构造成一维向量，然后将这些一维向量组合起来构成一个更大的一维向量。这样cost function 就可以表示成。</p>
<p>然后将反向传播过程通过梯度下降算法得到的按照一样的顺序构造成一个一维向量。的维度与一致。</p>
<p>接着利用对每个计算近似梯度，其值与反向传播算法得到的相比较，检查是否一致。例如，对于第i个元素，近似梯度为：</p>
<p>计算完所有的近似梯度后，可以计算与的欧氏（Euclidean）距离来比较二者的相似度。公式如下：</p>
<p>一般来说，如果欧氏距离越小，例如，甚至更小，则表明与越接近，即反向梯度计算是正确的，没有bugs。如果欧氏距离较大，例如，则表明梯度计算可能出现问题，需要再次检查是否有bugs存在。如果欧氏距离很大，例如，甚至更大，则表明与差别很大，梯度下降计算过程有bugs，需要仔细检查。</p>
<p>3.梯度检查的使用技巧及注意事项</p>
<p>不要在训练过程使用梯度检查！！！因为梯度检查计算量大耗时长，所以一般只在debug的时候使用。</p>
<p>如果梯度检查失败，那么需要检查所有项，并试着找出bug！！ 通过比较与，找到差异较大的dθ[i]，检查其计算导数的过程是否有bug</p>
<p>如果梯度检查中有正则化项，一定要记得正则化项！！  即如果对成本函数进行了正则化，梯度千万不要忘记正则化项。</p>
<p>梯度检查不能与dropout同时使用！！</p>
<p>随机初始化之后进行梯度检查，反复训练网络之后，再重新进行梯度检查（不常用）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2018/07/12/python爬虫之模拟登陆新浪微博/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/12/python爬虫之模拟登陆新浪微博/" itemprop="url">
                  python爬虫之模拟登陆新浪微博
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T16:15:22+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/12/python爬虫之模拟登陆新浪微博/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/12/python爬虫之模拟登陆新浪微博/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>最近在做新浪微博爬虫这一块，准备把此项目遇到的问题写成博客的一个系列，首先遇到的问题就是新浪的登陆问题，现在大概有两种解决方案吗，第一种是使用python中的selenium模块实现模拟登陆，原理就是打开一个真正的浏览器，提取获取到的html页面中的标签实现点击，输入等事件，来实现模拟登录，这个方法的缺点就是要打开一个真正的浏览器，对资源的利用不是很有效，扩展性也不是很好，优点就是比较简单，考虑到之后要爬取微博的量级，我选择采用第二种方法，也就是抓包+模拟网络请求的方法。</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>抓包就采用chrome自带的开发者工具，微博登陆界面如下图<br><img src="/2018/07/12/python爬虫之模拟登陆新浪微博/loginreview.png" alt="login"></p>
<p>在输入账号后回发送prelogin的请求，随意点击任意地方会出现验证码的输入框</p>
<p>在抓包的时候要勾选preserve log选项，防止页面跳转后log消失，抓到log后不难发现其中prelogin是登陆前比较重要的网络请求，pin.php是获取验证码的网络请求，login是真正登陆时的网络请求，如下图所示<br><img src="/2018/07/12/python爬虫之模拟登陆新浪微博/catch.png" alt="抓包"></p>
<p>首先分析prelogin请求，点开请求详情可以看到<br><img src="/2018/07/12/python爬虫之模拟登陆新浪微博/relogin.png" alt="prelogin"></p>
<p>这是一个get请求，请求参数为<br>entry: weibo<br>callback: sinaSSOController.preloginCallBack<br>su: MTUyMDA2MjEwNTk=<br>rsakt: mod<br>checkpin: 1<br>client: ssologin.js(v1.4.19)<br>_: 1531447140449  </p>
<p>其中只有su:MTUyMDA2MjEwNTk=和_:1531447140449,其中su是用base64加密过的用户名，很明显_是时间戳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &apos;retcode&apos;: 0,</span><br><span class="line">    &apos;servertime&apos;: 1531448377,</span><br><span class="line">    &apos;pcid&apos;: &apos;tc-25f15c5d820bebb252b6f3ac5603e30c979d&apos;,</span><br><span class="line">    &apos;nonce&apos;: &apos;FHLJRZ&apos;,</span><br><span class="line">    &apos;pubkey&apos;: &apos;EB2A38568661887FA180BDDB5CABD5F21C7BFD59C090CB2D245A87AC253062882729293E5506350508E7F9AA3BB77F4333231490F915F6D63C55FE2F08A49B353F444AD3993CACC02DB784ABBB8E42A9B1BBFFFB38BE18D78E87A0E41B9B8F73A928EE0CCEE1F6739884B9777E4FE9E88A1BBE495927AC4A799B3181D6442443&apos;,</span><br><span class="line">    &apos;rsakv&apos;: &apos;1330428213&apos;,</span><br><span class="line">    &apos;exectime&apos;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中servertime，pcid，nonce，pubkey，rsakv在后面的请求都会用到。</p>
<p>接下来看第二个获取验证码的网络请求<br><img src="/2018/07/12/python爬虫之模拟登陆新浪微博/pin.png" alt="验证码"></p>
<p>请求参数只有三个r,s,p。<br>r暂时不知道，s是固定的0，p就是之前得到的pcid。<br>分析js代码可以知道<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pinCode: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> codePic = sinaSSOController.getPinCodeUrl();</span><br><span class="line">                nodes.pincode.src = codePic;</span><br><span class="line">                nodes.vcode.value = <span class="string">""</span>;</span><br><span class="line">                vcodeBox.style.display = <span class="string">""</span>;</span><br><span class="line">                checkCode = <span class="literal">true</span>;</span><br><span class="line">                obj &amp;&amp; obj.reason &amp;&amp; tip.setContent(obj.reason).show();</span><br><span class="line">                loginFuns.getAllTabIndexObjects()</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getPinCodeUrl = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        a == <span class="literal">undefined</span> &amp;&amp; (a = <span class="number">0</span>);</span><br><span class="line">        pcid &amp;&amp; (me.loginExtraQuery.pcid = pcid);</span><br><span class="line">        <span class="keyword">return</span> pincodeUrl + <span class="string">"?r="</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">1e8</span>) + <span class="string">"&amp;s="</span> + a + (pcid.length &gt; <span class="number">0</span> ? <span class="string">"&amp;p="</span> + pcid : <span class="string">""</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>r就是一个随机生成的8位的随机数，但实验发现，尽管随机数相同获取到的验证码也是不同的，因此还是需要破解验证码，在目前只是接入阿里云的打码接口进行识别，以后有时间也会发布自己写的打码方法。</p>
<p>最后看第三个网络请求<br><img src="/2018/07/12/python爬虫之模拟登陆新浪微博/login.png" alt="login"></p>
<p>其中pcid，ervertime，nonce，rsakv是之前获取到的参数，door是验证码，其中su是用base64加密过的用户名，sp是base64加密之后的密码<br>返回的是一个html，用正则表达式匹配到其中的链接，然后再进行一次网络请求就可以登陆成功了。  </p>
<p>登陆成功之后可以干的事情就很多了</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>Python版本：3.7<br>由于python版本的关系，，urllib的使用和python有些许区别<br>首先要做的就是设置网络请求中使用cookie<br>代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enableCookies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#建立一个cookies 容器</span></span><br><span class="line">        cookie_container = http.cookiejar.CookieJar()</span><br><span class="line">        <span class="comment">#将一个cookies容器和一个HTTP的cookie的处理器绑定</span></span><br><span class="line">        cookie_support = urllib.request.HTTPCookieProcessor(cookie_container)</span><br><span class="line">        <span class="comment">#创建一个opener,设置一个handler用于处理http的url打开</span></span><br><span class="line">        opener = urllib.request.build_opener(cookie_support, urllib.request.HTTPHandler)</span><br><span class="line">        <span class="comment">#安装opener，此后调用urlopen()时会使用安装过的opener对象</span></span><br><span class="line">        urllib.request.install_opener(opener)</span><br></pre></td></tr></table></figure></p>
<p>然后就是写加密的算法，导入一个base64的包<br>用户名的加密如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encrypted_name</span><span class="params">(self)</span>:</span></span><br><span class="line">    username_urllike   = urllib.request.quote(self.username)</span><br><span class="line">    username_encrypted = base64.b64encode(bytes(username_urllike,encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">return</span> username_encrypted.decode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure></p>
<p>密码的加密更复杂，混合了servertime和nonce<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encrypted_pw</span><span class="params">(self,data)</span>:</span></span><br><span class="line">    rsa_e = <span class="number">65537</span> <span class="comment">#0x10001</span></span><br><span class="line">    pw_string = str(data[<span class="string">'servertime'</span>]) + <span class="string">'\t'</span> + str(data[<span class="string">'nonce'</span>]) + <span class="string">'\n'</span> + str(self.password)</span><br><span class="line">    key = rsa.PublicKey(int(data[<span class="string">'pubkey'</span>],<span class="number">16</span>),rsa_e) <span class="comment">#创建公钥</span></span><br><span class="line">    pw_encypted = rsa.encrypt(pw_string.encode(<span class="string">'utf-8'</span>), key)  <span class="comment">#加密</span></span><br><span class="line">    self.password = <span class="string">''</span>   <span class="comment">#清空password</span></span><br><span class="line">    passwd = binascii.b2a_hex(pw_encypted) <span class="comment">#加密信息转化为16进制</span></span><br><span class="line">    print(passwd)</span><br><span class="line">    <span class="keyword">return</span> passwd</span><br></pre></td></tr></table></figure></p>
<p>然后进行第一个网络请求<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prelogin_args</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment">#该函数用于模拟预登录过程,并获取服务器返回的 nonce , servertime , pub_key 等信息  </span></span><br><span class="line">    json_pattern = re.compile(<span class="string">'\((.*)\)'</span>)</span><br><span class="line">    url = <span class="string">'http://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=&amp;'</span> + self.get_encrypted_name() + <span class="string">'&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.19)'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = urllib.request.Request(url)</span><br><span class="line">        response = urllib.request.urlopen(request)</span><br><span class="line">        raw_data = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        json_data = json_pattern.search(raw_data).group(<span class="number">1</span>)</span><br><span class="line">        data = json.loads(json_data)</span><br><span class="line">        print(data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> urllib.error <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"%d"</span>%e.code)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>得到服务器返回的nonce , servertime , pub_key等信息</p>
<p>进行第二个网络请求，获取验证码，并接入识别验证码平台，得到验证码的字符串<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_door</span><span class="params">(self,pcid)</span>:</span></span><br><span class="line">    url = <span class="string">"https://login.sina.com.cn/cgi/pin.php?r="</span>+str(random.randint(<span class="number">10000000</span>,<span class="number">99999999</span>))+<span class="string">"&amp;s=0&amp;p="</span>+pcid</span><br><span class="line">    print(url)</span><br><span class="line">    r= urllib.request.Request(url)</span><br><span class="line">    res = urllib.request.urlopen(r)</span><br><span class="line">    content = res.read()</span><br><span class="line">    print(base64.b64encode(content))                 </span><br><span class="line">    host = <span class="string">'http://txyzmsb.market.alicloudapi.com'</span></span><br><span class="line">    path = <span class="string">'/yzm'</span></span><br><span class="line">    appcode = <span class="string">'你的应用密钥'</span></span><br><span class="line">    fields = urllib.parse.urlencode(&#123;</span><br><span class="line">        <span class="string">'v_pic'</span>:base64.b64encode(content),</span><br><span class="line">        <span class="string">'v_type'</span>:<span class="string">'ne5'</span></span><br><span class="line">    &#125;).encode(encoding=<span class="string">'UTF8'</span>)</span><br><span class="line">    url = host + path</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'Authorization'</span>: <span class="string">'APPCODE '</span> + appcode,</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded; charset=UTF-8'</span></span><br><span class="line">    &#125;</span><br><span class="line">    req = urllib.request.Request(url, fields,headers)</span><br><span class="line">    f = urllib.request.urlopen(req)</span><br><span class="line">    content = f.read()</span><br><span class="line">    print(content)</span><br><span class="line">    data = json.loads(content)</span><br><span class="line">    <span class="keyword">return</span> data[<span class="string">'v_code'</span>]</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">进行第三个网络请求，完成登陆</span><br><span class="line">```Python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_post_data</span><span class="params">(self,raw)</span>:</span></span><br><span class="line">    door = self.get_door(raw[<span class="string">'pcid'</span>])</span><br><span class="line">    post_data = &#123;</span><br><span class="line">        <span class="string">"entry"</span>:<span class="string">"weibo"</span>,</span><br><span class="line">        <span class="string">"gateway"</span>:<span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"from"</span>:<span class="string">""</span>,</span><br><span class="line">        <span class="string">"savestate"</span>:<span class="string">"7"</span>,</span><br><span class="line">        <span class="string">"qrcode_flag"</span>:<span class="string">"false"</span>,</span><br><span class="line">        <span class="string">"useticket"</span>:<span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"pagerefer"</span>:<span class="string">"https://login.sina.com.cn/crossdomain2.php?action=logout&amp;r=https%3A%2F%2Fweibo.com%2Flogout.php%3Fbackurl%3D%252F"</span>,</span><br><span class="line">        <span class="string">"pcid"</span>:raw[<span class="string">'pcid'</span>],</span><br><span class="line">        <span class="string">"door"</span>:door,</span><br><span class="line">        <span class="string">"vsnf"</span>:<span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"su"</span>:self.get_encrypted_name(),</span><br><span class="line">        <span class="string">"service"</span>:<span class="string">"miniblog"</span>,</span><br><span class="line">        <span class="string">"servertime"</span>:raw[<span class="string">'servertime'</span>],</span><br><span class="line">        <span class="string">"nonce"</span>:raw[<span class="string">'nonce'</span>],</span><br><span class="line">        <span class="string">"pwencode"</span>:<span class="string">"rsa2"</span>,</span><br><span class="line">        <span class="string">"rsakv"</span>:raw[<span class="string">'rsakv'</span>],</span><br><span class="line">        <span class="string">"sp"</span>:self.get_encrypted_pw(raw),</span><br><span class="line">        <span class="string">"sr"</span>:<span class="string">"1920*1080"</span>,</span><br><span class="line">        <span class="string">"encoding"</span>:<span class="string">"UTF-8"</span>,</span><br><span class="line">        <span class="string">"prelt"</span>:<span class="string">"25"</span>,</span><br><span class="line">        <span class="string">"url"</span>:<span class="string">"https://weibo.com/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack"</span>,</span><br><span class="line">        <span class="string">"returntype"</span>:<span class="string">"META"</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = urllib.parse.urlencode(post_data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span><br><span class="line">    url = <span class="string">'http://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19)'</span></span><br><span class="line">    self.enableCookies()</span><br><span class="line">    data = self.get_prelogin_args()</span><br><span class="line">    post_data = self.build_post_data(data)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = urllib.request.Request(url=url,data=post_data,headers=headers)</span><br><span class="line">        response = urllib.request.urlopen(request)</span><br><span class="line">        html = response.read().decode(<span class="string">'GBK'</span>)</span><br><span class="line">        print(html)</span><br><span class="line">    <span class="keyword">except</span> urllib.error <span class="keyword">as</span> e:</span><br><span class="line">        print(e.code)</span><br><span class="line"></span><br><span class="line">    p = re.compile(<span class="string">'location\.replace\(\'(.*?)\'\)'</span>)</span><br><span class="line">    p2 = re.compile(<span class="string">r'"userdomain":"(.*?)"'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        login_url = p.search(html).group(<span class="number">1</span>)</span><br><span class="line">        print(login_url)</span><br><span class="line">        request = urllib.request.Request(login_url)</span><br><span class="line">        response = urllib.request.urlopen(request)</span><br><span class="line">        page = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        print(page)</span><br><span class="line">        login_url = <span class="string">'http://weibo.com/'</span> + p2.search(page).group(<span class="number">1</span>)</span><br><span class="line">        request = urllib.request.Request(login_url)</span><br><span class="line">        response = urllib.request.urlopen(request)</span><br><span class="line">        final = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        print(<span class="string">"Login success!"</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'Login error!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://andeper.cn/2018/02/21/深层神经网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andeper">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/update/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andeper的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/21/深层神经网络/" itemprop="url">
                  深层神经网络
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-21T18:20:38+08:00">
                2018-02-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/21/深层神经网络/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/21/深层神经网络/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上节课我们主要介绍了浅层神经网络。首先介绍神经网络的基本结构，包括输入层，隐藏层和输出层。然后以简单的2 layer NN为例，详细推导了其正向传播过程和反向传播过程，使用梯度下降的方法优化神经网络参数。同时，我们还介绍了不同的激活函数，比较各自优缺点，讨论了激活函数必须是非线性的原因。最后介绍了神经网络参数随机初始化的必要性，特别是权重W，不同神经元的W不能初始化为同一零值。本节课是对上节课的延伸和扩展，讨论更深层的神经网络。</p>
<h3 id="Deep-L-layer-neural-network"><a href="#Deep-L-layer-neural-network" class="headerlink" title="Deep L-layer neural network"></a>Deep L-layer neural network</h3><p>深层神经网络其实就是包含更多的隐藏层神经网络。如下图所示，分别列举了逻辑回归、1个隐藏层的神经网络、2个隐藏层的神经网络和5个隐藏层的神经网络它们的模型结构。<br><img src="/2018/02/21/深层神经网络/deepLNN" alt="deepLNN"></p>
<p>命名规则上，一般只参考隐藏层个数和输出层。例如，上图中的逻辑回归又叫1 layer NN，1个隐藏层的神经网络叫做2 layer NN，2个隐藏层的神经网络叫做3 layer NN，以此类推。如果是L-layer NN，则包含了L-1个隐藏层，最后的L层是输出层。</p>
<p>下面以一个4层神经网络为例来介绍关于神经网络的一些标记写法。如下图所示，首先，总层数用L表示，L=4。输入层是第0层，输出层是第L层。$n^{[l]}$表示第l层包含的单元个数，l=0,1,⋯,L。这个模型中，$n^{[0]}=n_x=3$，表示三个输入特征$x_1,x_2,x_3$。$n^{[1]}=5$，$n^{[2]}=5$，$n^{[3]}=3$，$n^{[4]}=n^{[L]}=1$。第l层的激活函数输出用$a^{[l]}$表示，$a^{[l]}=g^{[l]}(z^{[l]})$。$W^{[l]}$表示第l层的权重，用于计算$z^{[l]}$。另外，我们把输入x记为$a^{[0]}$，把输出层$\hat{y}$记为$a^{[L]}$。</p>
<p>注意，$a^{[l]}$和$W^{[l]}$中的上标l都是从1开始的，l=1,⋯,L。<br><img src="/2018/02/21/深层神经网络/DNNN" alt="DNNN"></p>
<h3 id="Forward-Propagation-in-a-Deep-Network"><a href="#Forward-Propagation-in-a-Deep-Network" class="headerlink" title="Forward Propagation in a Deep Network"></a>Forward Propagation in a Deep Network</h3><p>接下来，我们来推导一下深层神经网络的正向传播过程。仍以上面讲过的4层神经网络为例，对于单个样本：</p>
<p>第1层，l=1：</p>
<script type="math/tex; mode=display">z^{[1]}=W^{[1]}x+b^{[1]}=W^{[1]}a^{[0]}+b^{[1]}</script><script type="math/tex; mode=display">a^{[1]}=g^{[1]}(z^{[1]})</script><p>第2层，l=2：</p>
<script type="math/tex; mode=display">z^{[2]}=W^{[2]}a^{[1]}+b^{[2]}</script><script type="math/tex; mode=display">a^{[2]}=g^{[2]}(z^{[2]})</script><p>第3层，l=3：</p>
<script type="math/tex; mode=display">z^{[3]}=W^{[3]}a^{[2]}+b^{[3]}</script><script type="math/tex; mode=display">a^{[3]}=g^{[3]}(z^{[3]})</script><p>第4层，l=4：</p>
<script type="math/tex; mode=display">z^{[4]}=W^{[4]}a^{[3]}+b^{[4]}</script><script type="math/tex; mode=display">a^{[4]}=g^{[4]}(z^{[4]})</script><p>如果有m个训练样本，其向量化矩阵形式为：</p>
<p>第1层，l=1：</p>
<script type="math/tex; mode=display">Z^{[1]}=W^{[1]}X+b^{[1]}=W^{[1]}A^{[0]}+b^{[1]}</script><script type="math/tex; mode=display">A^{[1]}=g^{[1]}(Z^{[1]})</script><p>第2层，l=2：</p>
<script type="math/tex; mode=display">Z^{[2]}=W^{[2]}A^{[1]}+b^{[2]}</script><script type="math/tex; mode=display">A^{[2]}=g^{[2]}(Z^{[2]})</script><p>第3层，l=3：</p>
<script type="math/tex; mode=display">Z^{[3]}=W^{[3]}A^{[2]}+b^{[3]}</script><script type="math/tex; mode=display">A^{[3]}=g^{[3]}(Z^{[3]})</script><p>第4层，l=4：</p>
<script type="math/tex; mode=display">Z^{[4]}=W^{[4]}A^{[3]}+b^{[4]}</script><script type="math/tex; mode=display">A^{[4]}=g^{[4]}(Z^{[4]})</script><p>综上所述，对于第l层，其正向传播过程的Z[l]和A[l]可以表示为：</p>
<script type="math/tex; mode=display">Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}</script><script type="math/tex; mode=display">A^{[l]}=g^{[l]}(Z^{[l]})</script><p>其中l=1,⋯,L</p>
<h3 id="Getting-your-matrix-dimensions-right"><a href="#Getting-your-matrix-dimensions-right" class="headerlink" title="Getting your matrix dimensions right"></a>Getting your matrix dimensions right</h3><p>对于单个训练样本，输入x的维度是$(n^{[0]},1)$,神经网络的参数$W^{[l]}$和$b^{[l]}$的维度分别是：</p>
<script type="math/tex; mode=display">W^{[l]}:\ (n^{[l]},n^{[l-1]})</script><script type="math/tex; mode=display">b^{[l]}:\ (n^{[l]},1)</script><p>其中，l=1,⋯,L，$n^{[l]}$和$n^{[l−1]}$分别表示第l层和l−1层的所含单元个数。$n^{[0]}=n_x$，表示输入层特征数目。</p>
<p>顺便提一下，反向传播过程中的$dW^{[l]}$和$db^{[l]}$的维度分别是：</p>
<script type="math/tex; mode=display">dW^{[l]}:\ (n^{[l]},n^{[l-1]})</script><script type="math/tex; mode=display">db^{[l]}:\ (n^{[l]},1)</script><p>注意到，$W^{[l]}$与$dW^{[l]}$维度相同，$b^{[l]}$与$db^{[l]}$维度相同。这很容易理解。</p>
<p>正向传播过程中的$z^{[l]}$和$a^{[l]}$的维度分别是：</p>
<script type="math/tex; mode=display">z^{[l]}:\ (n^{[l]},1)</script><script type="math/tex; mode=display">a^{[l]}:\ (n^{[l]},1)</script><p>$z^{[l]}$和$a^{[l]}$的维度是一样的，且$dz^{[l]}$和$da^{[l]}$的维度均与$z^{[l]}$和$a^{[l]}$的维度一致。</p>
<p>对于m个训练样本，输入矩阵X的维度是$(n^{[0]},m)$。需要注意的是$W^{[l]}$和$b^{[l]}$的维度与只有单个样本是一致的：</p>
<script type="math/tex; mode=display">W^{[l]}:\ (n^{[l]},n^{[l-1]})</script><script type="math/tex; mode=display">b^{[l]}:\ (n^{[l]},1)</script><p>只不过在运算$Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}$中，$b^{[l]}$会被当成$(n^{[l]},m)$矩阵进行运算，这是因为python的广播性质，且$b^{[l]}$每一列向量都是一样的。$dW^{[l]}$和$db^{[l]}$的维度分别与$W^{[l]}$和$b^{[l]}$的相同。</p>
<p>但是，$Z^{[l]}$和$A^{[l]}$的维度发生了变化：</p>
<script type="math/tex; mode=display">Z^{[l]}:\ (n^{[l]},m)</script><script type="math/tex; mode=display">A^{[l]}:\ (n^{[l]},m)</script><p>$dZ^{[l]}$和$dA^{[l]}$的维度分别与$Z^{[l]}$和$A^{[l]}$的相同。</p>
<h3 id="Why-deep-representations"><a href="#Why-deep-representations" class="headerlink" title="Why deep representations?"></a>Why deep representations?</h3><p>我们都知道神经网络能处理很多问题，而且效果显著。其强大能力主要源自神经网络足够“深”，也就是说网络层数越多，神经网络就更加复杂和深入，学习也更加准确。接下来，我们从几个例子入手，看一下为什么深度网络能够如此强大。</p>
<p>先来看人脸识别的例子，如下图所示。经过训练，神经网络第一层所做的事就是从原始图片中提取出人脸的轮廓与边缘，即边缘检测。这样每个神经元得到的是一些边缘信息。神经网络第二层所做的事情就是将前一层的边缘进行组合，组合成人脸一些局部特征，比如眼睛、鼻子、嘴巴等。再往后面，就将这些局部特征组合起来，融合成人脸的模样。可以看出，随着层数由浅到深，神经网络提取的特征也是从边缘到局部特征到整体，由简单到复杂。可见，如果隐藏层足够多，那么能够提取的特征就越丰富、越复杂，模型的准确率就会越高。</p>
<p>语音识别模型也是这个道理。浅层的神经元能够检测一些简单的音调，然后较深的神经元能够检测出基本的音素，更深的神经元就能够检测出单词信息。如果网络够深，还能对短语、句子进行检测。记住一点，神经网络从左到右，神经元提取的特征从简单到复杂。特征复杂度与神经网络层数成正相关。特征越来越复杂，功能也越来越强大。<br><img src="/2018/02/21/深层神经网络/intutition" alt="intutition"></p>
<p>除了从提取特征复杂度的角度来说明深层网络的优势之外，深层网络还有另外一个优点，就是能够减少神经元个数，从而减少计算量。例如下面这个例子，使用电路理论，计算逻辑输出：</p>
<script type="math/tex; mode=display">y=x_1\oplus x_2\oplus x_3\oplus\cdots\oplus x_n</script><p>其中，$\oplus$表示异或操作。对于这个逻辑运算，如果使用深度网络，深度网络的结构是每层将前一层的两两单元进行异或，最后到一个输出，如下图左边所示。这样，整个深度网络的层数是$log_2(n)$，不包含输入层。总共使用的神经元个数为：</p>
<script type="math/tex; mode=display">1+2+\cdots+2^{log_2(n)-1}=1\cdot\frac{1-2^{log_2(n)}}{1-2}=2^{log_2(n)}-1=n-1</script><p>可见，输入个数是n，这种深层网络所需的神经元个数仅仅是n-1个。</p>
<p>如果不用深层网络，仅仅使用单个隐藏层，那么需要的神经元个数将是指数级别那么大。Andrew指出，由于包含了所有的逻辑位（0和1），则需要$2^{n-1}$ ?个神经元。</p>
<p>比较下来，处理同一逻辑问题，深层网络所需的神经元个数比浅层网络要少很多。这也是深层神经网络的优点之一。</p>
<p>尽管深度学习有着非常显著的优势，Andrew还是建议对实际问题进行建模时，尽量先选择层数少的神经网络模型，这也符合奥卡姆剃刀定律（Occam’s Razor）。对于比较复杂的问题，再使用较深的神经网络模型。</p>
<h3 id="Building-blocks-of-deep-neural-networks"><a href="#Building-blocks-of-deep-neural-networks" class="headerlink" title="Building blocks of deep neural networks"></a>Building blocks of deep neural networks</h3><p>下面用流程块图来解释神经网络正向传播和反向传播过程。如下图所示，对于第l层来说，正向传播过程中：</p>
<p>输入：$a^{[l-1]}$<br>输出：$a^{[l]}$<br>参数：$W^{[l]}$,$b^{[l]}$<br>缓存变量：$z^{[l]}$</p>
<p>反向传播过程中：<br>输入：$da^{[l]}$<br>输出：$da^{[l-1]}$,$dW^{[l]}$,$db^{[l]}$<br>参数：$W^{[l]}$,$b^{[l]}$<br><img src="/2018/02/21/深层神经网络/Ilayer" alt="Ilayer"></p>
<p>刚才这是第l层的流程块图，对于神经网络所有层，整体的流程块图正向传播过程和反向传播过程如下所示：<br><img src="/2018/02/21/深层神经网络/Ilayer2" alt="Ilayer2"></p>
<h3 id="Forward-and-Backward-Propagation"><a href="#Forward-and-Backward-Propagation" class="headerlink" title="Forward and Backward Propagation"></a>Forward and Backward Propagation</h3><p>我们继续接着上一部分流程块图的内容，推导神经网络正向传播过程和反向传播过程的具体表达式。</p>
<p>首先是正向传播过程，令层数为第l层，输入是$a^{[l-1]}$，输出是$a^{[l]}$，缓存变量是$z^{[l]}$。其表达式如下：</p>
<script type="math/tex; mode=display">z^{[l]}=W^{[l]}a^{[l-1]}+b^{[l]}</script><script type="math/tex; mode=display">a^{[l]}=g^{[l]}(z^{[l]})</script><p>m个训练样本，向量化形式为：</p>
<script type="math/tex; mode=display">Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}</script><script type="math/tex; mode=display">A^{[l]}=g^{[l]}(Z^{[l]})</script><p>然后是反向传播过程，输入是$da^{[l]}$，输出是$da^{[l-1]}$,$dw^{[l]}$,$db^{[l]}$。其表达式如下：</p>
<script type="math/tex; mode=display">dz^{[l]}=da^{[l]}\ast g^{[l]'}(z^{[l]})</script><script type="math/tex; mode=display">dW^{[l]}=dz^{[l]}\cdot a^{[l-1]}</script><script type="math/tex; mode=display">db^{[l]}=dz^{[l]}</script><script type="math/tex; mode=display">da^{[l-1]}=W^{[l]T}\cdot dz^{[l]}</script><p>由上述第四个表达式可得$da^{[l]}=W^{[l+1]T}\cdot dz^{[l+1]}$，将$da^{[l]}$代入第一个表达式中可以得到：</p>
<script type="math/tex; mode=display">dz^{[l]}=W^{[l+1]T}\cdot dz^{[l+1]}\ast g^{[l]'}(z^{[l]})</script><p>该式非常重要，反映了$dz^{[l+1]}$与<script type="math/tex">dz^{[l]}</script>的递推关系。</p>
<p>m个训练样本，向量化形式为：</p>
<script type="math/tex; mode=display">dZ^{[l]}=dA^{[l]}\ast g^{[l]'}(Z^{[l]})</script><script type="math/tex; mode=display">dW^{[l]}=\frac1mdZ^{[l]}\cdot A^{[l-1]T}</script><script type="math/tex; mode=display">db^{[l]}=\frac1mnp.sum(dZ^{[l]},axis=1,keepdim=True)</script><script type="math/tex; mode=display">dA^{[l-1]}=W^{[l]T}\cdot dZ^{[l]}</script><script type="math/tex; mode=display">dZ^{[l]}=W^{[l+1]T}\cdot dZ^{[l+1]}\ast g^{[l]'}(Z^{[l]})</script><h3 id="Parameters-vs-Hyperparameters"><a href="#Parameters-vs-Hyperparameters" class="headerlink" title="Parameters vs Hyperparameters"></a>Parameters vs Hyperparameters</h3><p>该部分介绍神经网络中的参数（parameters）和超参数（hyperparameters）的概念。</p>
<p>神经网络中的参数就是我们熟悉的$W^{[l]}$和$b^{[l]}$。而超参数则是例如学习速率$\alpha$，训练迭代次数N，神经网络层数L，各层神经元个数$n^{[l]}$，激活函数g(z)等。之所以叫做超参数的原因是它们决定了参数$W^{[l]}$和$b^{[l]}$的值。在后面的第二门课我们还将学习其它的超参数，这里先不讨论。</p>
<p>如何设置最优的超参数是一个比较困难的、需要经验知识的问题。通常的做法是选择超参数一定范围内的值，分别代入神经网络进行训练，测试cost function随着迭代次数增加的变化，根据结果选择cost function最小时对应的超参数值。这类似于validation的方法。</p>
<h3 id="What-does-this-have-to-do-with-the-brain"><a href="#What-does-this-have-to-do-with-the-brain" class="headerlink" title="What does this have to do with the brain?"></a>What does this have to do with the brain?</h3><p>那么，神经网络跟人脑机制到底有什么联系呢？究竟有多少的相似程度？神经网络实际上可以分成两个部分：正向传播过程和反向传播过程。神经网络的每个神经元采用激活函数的方式，类似于感知机模型。这种模型与人脑神经元是类似的，可以说是一种非常简化的人脑神经元模型。如下图所示，人脑神经元可分为树突、细胞体、轴突三部分。树突接收外界电刺激信号（类比神经网络中神经元输入），传递给细胞体进行处理（类比神经网络中神经元激活函数运算），最后由轴突传递给下一个神经元（类比神经网络中神经元输出）。</p>
<p>值得一提的是，人脑神经元的结构和处理方式要复杂的多，神经网络模型只是非常简化的模型。人脑如何进行学习？是否也是通过反向传播和梯度下降算法现在还不清楚，可能会更加复杂。这是值得生物学家探索的事情。也许发现重要的新的人脑学习机制后，让我们的神经网络模型抛弃反向传播和梯度下降算法，能够实现更加准确和强大的神经网络模型！</p>
<p><img src="/2018/02/21/深层神经网络/propagation" alt="propagation"></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本节课主要介绍了深层神经网络，是上一节浅层神经网络的拓展和归纳。首先，我们介绍了建立神经网络模型一些常用的标准的标记符号。然后，用流程块图的方式详细推导正向传播过程和反向传播过程的输入输出和参数表达式。我们也从提取特征复杂性和计算量的角度分别解释了深层神经网络为什么优于浅层神经网络。接着，我们介绍了超参数的概念，解释了超参数与参数的区别。最后，我们将神经网络与人脑做了类别，人工神经网络是简化的人脑模型。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/update/avatar.jpg"
               alt="Andeper" />
          <p class="site-author-name" itemprop="name">Andeper</p>
           
              <p class="site-description motion-element" itemprop="description">欢迎来到我的技术博客</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/tags/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andeper</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"andeper"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.0"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  

</body>
</html>
