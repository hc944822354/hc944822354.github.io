<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andeper的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://andeper.cn/"/>
  <updated>2018-07-12T08:15:22.851Z</updated>
  <id>http://andeper.cn/</id>
  
  <author>
    <name>Andeper</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python爬虫之模拟登陆新浪微博</title>
    <link href="http://andeper.cn/2018/07/12/python%E7%88%AC%E8%99%AB%E4%B9%8B%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A/"/>
    <id>http://andeper.cn/2018/07/12/python爬虫之模拟登陆新浪微博/</id>
    <published>2018-07-12T08:15:22.000Z</published>
    <updated>2018-07-12T08:15:22.851Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深层神经网络</title>
    <link href="http://andeper.cn/2018/02/21/%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://andeper.cn/2018/02/21/深层神经网络/</id>
    <published>2018-02-21T10:20:38.000Z</published>
    <updated>2018-02-21T12:39:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>上节课我们主要介绍了浅层神经网络。首先介绍神经网络的基本结构，包括输入层，隐藏层和输出层。然后以简单的2 layer NN为例，详细推导了其正向传播过程和反向传播过程，使用梯度下降的方法优化神经网络参数。同时，我们还介绍了不同的激活函数，比较各自优缺点，讨论了激活函数必须是非线性的原因。最后介绍了神经网络参数随机初始化的必要性，特别是权重W，不同神经元的W不能初始化为同一零值。本节课是对上节课的延伸和扩展，讨论更深层的神经网络。</p><h3 id="Deep-L-layer-neural-network"><a href="#Deep-L-layer-neural-network" class="headerlink" title="Deep L-layer neural network"></a>Deep L-layer neural network</h3><p>深层神经网络其实就是包含更多的隐藏层神经网络。如下图所示，分别列举了逻辑回归、1个隐藏层的神经网络、2个隐藏层的神经网络和5个隐藏层的神经网络它们的模型结构。<br><img src="/2018/02/21/深层神经网络/deepLNN" alt="deepLNN"></p><p>命名规则上，一般只参考隐藏层个数和输出层。例如，上图中的逻辑回归又叫1 layer NN，1个隐藏层的神经网络叫做2 layer NN，2个隐藏层的神经网络叫做3 layer NN，以此类推。如果是L-layer NN，则包含了L-1个隐藏层，最后的L层是输出层。</p><p>下面以一个4层神经网络为例来介绍关于神经网络的一些标记写法。如下图所示，首先，总层数用L表示，L=4。输入层是第0层，输出层是第L层。$n^{[l]}$表示第l层包含的单元个数，l=0,1,⋯,L。这个模型中，$n^{[0]}=n_x=3$，表示三个输入特征$x_1,x_2,x_3$。$n^{[1]}=5$，$n^{[2]}=5$，$n^{[3]}=3$，$n^{[4]}=n^{[L]}=1$。第l层的激活函数输出用$a^{[l]}$表示，$a^{[l]}=g^{[l]}(z^{[l]})$。$W^{[l]}$表示第l层的权重，用于计算$z^{[l]}$。另外，我们把输入x记为$a^{[0]}$，把输出层$\hat{y}$记为$a^{[L]}$。</p><p>注意，$a^{[l]}$和$W^{[l]}$中的上标l都是从1开始的，l=1,⋯,L。<br><img src="/2018/02/21/深层神经网络/DNNN" alt="DNNN"></p><h3 id="Forward-Propagation-in-a-Deep-Network"><a href="#Forward-Propagation-in-a-Deep-Network" class="headerlink" title="Forward Propagation in a Deep Network"></a>Forward Propagation in a Deep Network</h3><p>接下来，我们来推导一下深层神经网络的正向传播过程。仍以上面讲过的4层神经网络为例，对于单个样本：</p><p>第1层，l=1：</p><script type="math/tex; mode=display">z^{[1]}=W^{[1]}x+b^{[1]}=W^{[1]}a^{[0]}+b^{[1]}</script><script type="math/tex; mode=display">a^{[1]}=g^{[1]}(z^{[1]})</script><p>第2层，l=2：</p><script type="math/tex; mode=display">z^{[2]}=W^{[2]}a^{[1]}+b^{[2]}</script><script type="math/tex; mode=display">a^{[2]}=g^{[2]}(z^{[2]})</script><p>第3层，l=3：</p><script type="math/tex; mode=display">z^{[3]}=W^{[3]}a^{[2]}+b^{[3]}</script><script type="math/tex; mode=display">a^{[3]}=g^{[3]}(z^{[3]})</script><p>第4层，l=4：</p><script type="math/tex; mode=display">z^{[4]}=W^{[4]}a^{[3]}+b^{[4]}</script><script type="math/tex; mode=display">a^{[4]}=g^{[4]}(z^{[4]})</script><p>如果有m个训练样本，其向量化矩阵形式为：</p><p>第1层，l=1：</p><script type="math/tex; mode=display">Z^{[1]}=W^{[1]}X+b^{[1]}=W^{[1]}A^{[0]}+b^{[1]}</script><script type="math/tex; mode=display">A^{[1]}=g^{[1]}(Z^{[1]})</script><p>第2层，l=2：</p><script type="math/tex; mode=display">Z^{[2]}=W^{[2]}A^{[1]}+b^{[2]}</script><script type="math/tex; mode=display">A^{[2]}=g^{[2]}(Z^{[2]})</script><p>第3层，l=3：</p><script type="math/tex; mode=display">Z^{[3]}=W^{[3]}A^{[2]}+b^{[3]}</script><script type="math/tex; mode=display">A^{[3]}=g^{[3]}(Z^{[3]})</script><p>第4层，l=4：</p><script type="math/tex; mode=display">Z^{[4]}=W^{[4]}A^{[3]}+b^{[4]}</script><script type="math/tex; mode=display">A^{[4]}=g^{[4]}(Z^{[4]})</script><p>综上所述，对于第l层，其正向传播过程的Z[l]和A[l]可以表示为：</p><script type="math/tex; mode=display">Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}</script><script type="math/tex; mode=display">A^{[l]}=g^{[l]}(Z^{[l]})</script><p>其中l=1,⋯,L</p><h3 id="Getting-your-matrix-dimensions-right"><a href="#Getting-your-matrix-dimensions-right" class="headerlink" title="Getting your matrix dimensions right"></a>Getting your matrix dimensions right</h3><p>对于单个训练样本，输入x的维度是$(n^{[0]},1)$,神经网络的参数$W^{[l]}$和$b^{[l]}$的维度分别是：</p><script type="math/tex; mode=display">W^{[l]}:\ (n^{[l]},n^{[l-1]})</script><script type="math/tex; mode=display">b^{[l]}:\ (n^{[l]},1)</script><p>其中，l=1,⋯,L，$n^{[l]}$和$n^{[l−1]}$分别表示第l层和l−1层的所含单元个数。$n^{[0]}=n_x$，表示输入层特征数目。</p><p>顺便提一下，反向传播过程中的$dW^{[l]}$和$db^{[l]}$的维度分别是：</p><script type="math/tex; mode=display">dW^{[l]}:\ (n^{[l]},n^{[l-1]})</script><script type="math/tex; mode=display">db^{[l]}:\ (n^{[l]},1)</script><p>注意到，$W^{[l]}$与$dW^{[l]}$维度相同，$b^{[l]}$与$db^{[l]}$维度相同。这很容易理解。</p><p>正向传播过程中的$z^{[l]}$和$a^{[l]}$的维度分别是：</p><script type="math/tex; mode=display">z^{[l]}:\ (n^{[l]},1)</script><script type="math/tex; mode=display">a^{[l]}:\ (n^{[l]},1)</script><p>$z^{[l]}$和$a^{[l]}$的维度是一样的，且$dz^{[l]}$和$da^{[l]}$的维度均与$z^{[l]}$和$a^{[l]}$的维度一致。</p><p>对于m个训练样本，输入矩阵X的维度是$(n^{[0]},m)$。需要注意的是$W^{[l]}$和$b^{[l]}$的维度与只有单个样本是一致的：</p><script type="math/tex; mode=display">W^{[l]}:\ (n^{[l]},n^{[l-1]})</script><script type="math/tex; mode=display">b^{[l]}:\ (n^{[l]},1)</script><p>只不过在运算$Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}$中，$b^{[l]}$会被当成$(n^{[l]},m)$矩阵进行运算，这是因为python的广播性质，且$b^{[l]}$每一列向量都是一样的。$dW^{[l]}$和$db^{[l]}$的维度分别与$W^{[l]}$和$b^{[l]}$的相同。</p><p>但是，$Z^{[l]}$和$A^{[l]}$的维度发生了变化：</p><script type="math/tex; mode=display">Z^{[l]}:\ (n^{[l]},m)</script><script type="math/tex; mode=display">A^{[l]}:\ (n^{[l]},m)</script><p>$dZ^{[l]}$和$dA^{[l]}$的维度分别与$Z^{[l]}$和$A^{[l]}$的相同。</p><h3 id="Why-deep-representations"><a href="#Why-deep-representations" class="headerlink" title="Why deep representations?"></a>Why deep representations?</h3><p>我们都知道神经网络能处理很多问题，而且效果显著。其强大能力主要源自神经网络足够“深”，也就是说网络层数越多，神经网络就更加复杂和深入，学习也更加准确。接下来，我们从几个例子入手，看一下为什么深度网络能够如此强大。</p><p>先来看人脸识别的例子，如下图所示。经过训练，神经网络第一层所做的事就是从原始图片中提取出人脸的轮廓与边缘，即边缘检测。这样每个神经元得到的是一些边缘信息。神经网络第二层所做的事情就是将前一层的边缘进行组合，组合成人脸一些局部特征，比如眼睛、鼻子、嘴巴等。再往后面，就将这些局部特征组合起来，融合成人脸的模样。可以看出，随着层数由浅到深，神经网络提取的特征也是从边缘到局部特征到整体，由简单到复杂。可见，如果隐藏层足够多，那么能够提取的特征就越丰富、越复杂，模型的准确率就会越高。</p><p>语音识别模型也是这个道理。浅层的神经元能够检测一些简单的音调，然后较深的神经元能够检测出基本的音素，更深的神经元就能够检测出单词信息。如果网络够深，还能对短语、句子进行检测。记住一点，神经网络从左到右，神经元提取的特征从简单到复杂。特征复杂度与神经网络层数成正相关。特征越来越复杂，功能也越来越强大。<br><img src="/2018/02/21/深层神经网络/intutition" alt="intutition"></p><p>除了从提取特征复杂度的角度来说明深层网络的优势之外，深层网络还有另外一个优点，就是能够减少神经元个数，从而减少计算量。例如下面这个例子，使用电路理论，计算逻辑输出：</p><script type="math/tex; mode=display">y=x_1\oplus x_2\oplus x_3\oplus\cdots\oplus x_n</script><p>其中，$\oplus$表示异或操作。对于这个逻辑运算，如果使用深度网络，深度网络的结构是每层将前一层的两两单元进行异或，最后到一个输出，如下图左边所示。这样，整个深度网络的层数是$log_2(n)$，不包含输入层。总共使用的神经元个数为：</p><script type="math/tex; mode=display">1+2+\cdots+2^{log_2(n)-1}=1\cdot\frac{1-2^{log_2(n)}}{1-2}=2^{log_2(n)}-1=n-1</script><p>可见，输入个数是n，这种深层网络所需的神经元个数仅仅是n-1个。</p><p>如果不用深层网络，仅仅使用单个隐藏层，那么需要的神经元个数将是指数级别那么大。Andrew指出，由于包含了所有的逻辑位（0和1），则需要$2^{n-1}$ ?个神经元。</p><p>比较下来，处理同一逻辑问题，深层网络所需的神经元个数比浅层网络要少很多。这也是深层神经网络的优点之一。</p><p>尽管深度学习有着非常显著的优势，Andrew还是建议对实际问题进行建模时，尽量先选择层数少的神经网络模型，这也符合奥卡姆剃刀定律（Occam’s Razor）。对于比较复杂的问题，再使用较深的神经网络模型。</p><h3 id="Building-blocks-of-deep-neural-networks"><a href="#Building-blocks-of-deep-neural-networks" class="headerlink" title="Building blocks of deep neural networks"></a>Building blocks of deep neural networks</h3><p>下面用流程块图来解释神经网络正向传播和反向传播过程。如下图所示，对于第l层来说，正向传播过程中：</p><p>输入：$a^{[l-1]}$<br>输出：$a^{[l]}$<br>参数：$W^{[l]}$,$b^{[l]}$<br>缓存变量：$z^{[l]}$</p><p>反向传播过程中：<br>输入：$da^{[l]}$<br>输出：$da^{[l-1]}$,$dW^{[l]}$,$db^{[l]}$<br>参数：$W^{[l]}$,$b^{[l]}$<br><img src="/2018/02/21/深层神经网络/Ilayer" alt="Ilayer"></p><p>刚才这是第l层的流程块图，对于神经网络所有层，整体的流程块图正向传播过程和反向传播过程如下所示：<br><img src="/2018/02/21/深层神经网络/Ilayer2" alt="Ilayer2"></p><h3 id="Forward-and-Backward-Propagation"><a href="#Forward-and-Backward-Propagation" class="headerlink" title="Forward and Backward Propagation"></a>Forward and Backward Propagation</h3><p>我们继续接着上一部分流程块图的内容，推导神经网络正向传播过程和反向传播过程的具体表达式。</p><p>首先是正向传播过程，令层数为第l层，输入是$a^{[l-1]}$，输出是$a^{[l]}$，缓存变量是$z^{[l]}$。其表达式如下：</p><script type="math/tex; mode=display">z^{[l]}=W^{[l]}a^{[l-1]}+b^{[l]}</script><script type="math/tex; mode=display">a^{[l]}=g^{[l]}(z^{[l]})</script><p>m个训练样本，向量化形式为：</p><script type="math/tex; mode=display">Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}</script><script type="math/tex; mode=display">A^{[l]}=g^{[l]}(Z^{[l]})</script><p>然后是反向传播过程，输入是$da^{[l]}$，输出是$da^{[l-1]}$,$dw^{[l]}$,$db^{[l]}$。其表达式如下：</p><script type="math/tex; mode=display">dz^{[l]}=da^{[l]}\ast g^{[l]'}(z^{[l]})</script><script type="math/tex; mode=display">dW^{[l]}=dz^{[l]}\cdot a^{[l-1]}</script><script type="math/tex; mode=display">db^{[l]}=dz^{[l]}</script><script type="math/tex; mode=display">da^{[l-1]}=W^{[l]T}\cdot dz^{[l]}</script><p>由上述第四个表达式可得$da^{[l]}=W^{[l+1]T}\cdot dz^{[l+1]}$，将$da^{[l]}$代入第一个表达式中可以得到：</p><script type="math/tex; mode=display">dz^{[l]}=W^{[l+1]T}\cdot dz^{[l+1]}\ast g^{[l]'}(z^{[l]})</script><p>该式非常重要，反映了$dz^{[l+1]}$与<script type="math/tex">dz^{[l]}</script>的递推关系。</p><p>m个训练样本，向量化形式为：</p><script type="math/tex; mode=display">dZ^{[l]}=dA^{[l]}\ast g^{[l]'}(Z^{[l]})</script><script type="math/tex; mode=display">dW^{[l]}=\frac1mdZ^{[l]}\cdot A^{[l-1]T}</script><script type="math/tex; mode=display">db^{[l]}=\frac1mnp.sum(dZ^{[l]},axis=1,keepdim=True)</script><script type="math/tex; mode=display">dA^{[l-1]}=W^{[l]T}\cdot dZ^{[l]}</script><script type="math/tex; mode=display">dZ^{[l]}=W^{[l+1]T}\cdot dZ^{[l+1]}\ast g^{[l]'}(Z^{[l]})</script><h3 id="Parameters-vs-Hyperparameters"><a href="#Parameters-vs-Hyperparameters" class="headerlink" title="Parameters vs Hyperparameters"></a>Parameters vs Hyperparameters</h3><p>该部分介绍神经网络中的参数（parameters）和超参数（hyperparameters）的概念。</p><p>神经网络中的参数就是我们熟悉的$W^{[l]}$和$b^{[l]}$。而超参数则是例如学习速率$\alpha$，训练迭代次数N，神经网络层数L，各层神经元个数$n^{[l]}$，激活函数g(z)等。之所以叫做超参数的原因是它们决定了参数$W^{[l]}$和$b^{[l]}$的值。在后面的第二门课我们还将学习其它的超参数，这里先不讨论。</p><p>如何设置最优的超参数是一个比较困难的、需要经验知识的问题。通常的做法是选择超参数一定范围内的值，分别代入神经网络进行训练，测试cost function随着迭代次数增加的变化，根据结果选择cost function最小时对应的超参数值。这类似于validation的方法。</p><h3 id="What-does-this-have-to-do-with-the-brain"><a href="#What-does-this-have-to-do-with-the-brain" class="headerlink" title="What does this have to do with the brain?"></a>What does this have to do with the brain?</h3><p>那么，神经网络跟人脑机制到底有什么联系呢？究竟有多少的相似程度？神经网络实际上可以分成两个部分：正向传播过程和反向传播过程。神经网络的每个神经元采用激活函数的方式，类似于感知机模型。这种模型与人脑神经元是类似的，可以说是一种非常简化的人脑神经元模型。如下图所示，人脑神经元可分为树突、细胞体、轴突三部分。树突接收外界电刺激信号（类比神经网络中神经元输入），传递给细胞体进行处理（类比神经网络中神经元激活函数运算），最后由轴突传递给下一个神经元（类比神经网络中神经元输出）。</p><p>值得一提的是，人脑神经元的结构和处理方式要复杂的多，神经网络模型只是非常简化的模型。人脑如何进行学习？是否也是通过反向传播和梯度下降算法现在还不清楚，可能会更加复杂。这是值得生物学家探索的事情。也许发现重要的新的人脑学习机制后，让我们的神经网络模型抛弃反向传播和梯度下降算法，能够实现更加准确和强大的神经网络模型！</p><p><img src="/2018/02/21/深层神经网络/propagation" alt="propagation"></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本节课主要介绍了深层神经网络，是上一节浅层神经网络的拓展和归纳。首先，我们介绍了建立神经网络模型一些常用的标准的标记符号。然后，用流程块图的方式详细推导正向传播过程和反向传播过程的输入输出和参数表达式。我们也从提取特征复杂性和计算量的角度分别解释了深层神经网络为什么优于浅层神经网络。接着，我们介绍了超参数的概念，解释了超参数与参数的区别。最后，我们将神经网络与人脑做了类别，人工神经网络是简化的人脑模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上节课我们主要介绍了浅层神经网络。首先介绍神经网络的基本结构，包括输入层，隐藏层和输出层。然后以简单的2 layer NN为例，详细推导了其正向传播过程和反向传播过程，使用梯度下降的方法优化神经网络参数。同时，我们还介绍了不同的激活函数，比较各自优缺点，讨论了激活函数必须是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅层神经网络</title>
    <link href="http://andeper.cn/2018/02/19/%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://andeper.cn/2018/02/19/浅层神经网络/</id>
    <published>2018-02-19T12:37:59.000Z</published>
    <updated>2018-02-23T07:18:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Neural-Network-Overview"><a href="#Neural-Network-Overview" class="headerlink" title="Neural Network Overview"></a>Neural Network Overview</h3><p>前面的课程中，我们已经使用计算图的方式介绍了逻辑回归梯度下降算法的正向传播和反向传播。神经网络的结构与逻辑回归类似，只是神经网络的层数比逻辑回归多一层，多出来的中间那层称为隐藏层或中间层。这样从计算上来说，神经网络的正向传播和反向传播过程只是比逻辑回归多了一次重复的计算。正向传播过程分为两层，第一层是出入层到隐藏层，用上标[1]来表示：</p><script type="math/tex; mode=display">z^{[1]}=W^{[1]}x + b^{[1]}</script><script type="math/tex; mode=display">a^{[1]}=\sigma(z^{[1]})</script><p>第二层是隐藏层到输出层，用上标[2]来表示：</p><script type="math/tex; mode=display">z^{[2]} = W^{[2]}a^{[1]} + b^{[2]}</script><script type="math/tex; mode=display">a^{[2]} = \sigma(z^{[2]})</script><p>在写法上值得注意的是，方括号上标[i]表示当前所处的层数；圆括号上标(i)表示第i个样本。</p><p>同样，反向传播过程也分成两层。第一层是输出层到隐藏层，第二层是隐藏层到输入层。其细节部分我们之后再来讨论。<br><img src="/2018/02/19/浅层神经网络/neuralnetwork" alt="neuralnetwork"></p><h3 id="Neural-Network-Representation"><a href="#Neural-Network-Representation" class="headerlink" title="Neural Network Representation"></a>Neural Network Representation</h3><p>下面我们以图示的方式来介绍单隐藏层的神经网络结构。如下图所示，单隐藏神经网络就是典型的浅层(shallow)神经网络<br><img src="/2018/02/19/浅层神经网络/shallowneuralnetwork" alt="shallowneuralnetwork"><br>结构上，从左到右，可以分为三层：输入层(Input layer),隐藏层(Hidden layer)和输出层(Output layer)。输入层和输出层，顾名思义，对应训练样本的输入和输出，隐藏层是抽象的非线性的中间层，在训练集中，这些中间节点的真正数值我们是不知道的，我们在训练集中看不到它们的数值，这也是被命名为隐藏层的原因。<br>在写法上，我们通常吧输入矩阵X记为$a^{[0]}$,把隐藏层输出记为$a^{[1]}$,上标从0开始。用下标表示第几个神经元，注意下标从1开始。例如$a_1^{[1]}$表示隐藏层第1个神经元，$a_2^{[1]}$表示隐藏层第二个神经元，等等。这样，隐藏层有4个神经元就可以将其输出$a^{[1]}$写成矩阵的形式：</p><script type="math/tex; mode=display">{a^{[1]}}= \left[ \begin{matrix} a_1^{[1]} \\ a_2^{[1]} \\ a_3^{[1]} \\ a_4^{[1]} \end{matrix} \right]</script><p>最后相应的输出层记为$a^{[2]}$,即$\hat y$。这种单隐藏层神经网络也被称为两层神经网络(2 layer NN)。之所以叫两层神经网络是因为，通常我们只会计算隐藏层输出和输出层的输出，输入层是不用计算的。这也是我们把输入层层数上标记为0的原因(a^{[0]})</p><p>关于隐藏层对应的权重$W^{[1]}$和常数项$b^{[1]}$,$W^{[1]}$的维度是(4,3)。这里的4对应着隐藏层神经元个数，3对应这输入层x特征向量包含元素个数。常数项$b^{[1]}$的维度是(4,1),这里的4同样对应着隐藏层神经元个数。关于输出层对应的权重$W^{[2]}$和常数项$b^{[2]}$，$W^{[2]}$的维度是(1,4),这里的1对应着输出层神经元个数，4对应着隐藏层神经元个数。常数项$b^{[2]}$的维度是(1,1),因为输出只有一个神经元。总结一下，第i层的权重$W^{[i]}$维度的行等于i层神经元的个数，列等于i-1层神经元的个数；第i层常数项$b^{[i]}$维度的行等于i层神经元的个数，列始终为1。</p><h3 id="Computing-a-Neural-Network’s-Output"><a href="#Computing-a-Neural-Network’s-Output" class="headerlink" title="Computing a Neural Network’s Output"></a>Computing a Neural Network’s Output</h3><p>接下来我们详细推导神经网络的计算过程。回顾一下，我们前面讲过两层神经网络可以看成是逻辑回归再重复计算一次。如下图所示，逻辑回归的正向计算可以分解成z和a的两部分：</p><script type="math/tex; mode=display">z=w^Tx+b</script><script type="math/tex; mode=display">a= \sigma(z)</script><p><img src="/2018/02/19/浅层神经网络/ComputingNNoutput" alt="ComputingNNoutput"></p><p>对于两层神经网络，从输入层到隐藏层对应一次逻辑回归运算；从隐藏层到输出层对应一次逻辑回归运算。每层计算时，要主义对应的上标和下标，一般我们记上标方括号表示layer，下标表示第几个神经元。例如$a_i^{[I]}$表示第I层的第i个神经元，注意，i从1开始，I从0开始。</p><p>下面，我们将从输入层到输出层的计算公式列出来</p><script type="math/tex; mode=display">z_1^{[1]}=w_1^{[1]T}x+b_1^{[1]},\ a_1^{[1]}=\sigma(z_1^{[1]})</script><script type="math/tex; mode=display">z_2^{[1]}=w_2^{[1]T}x+b_2^{[1]},\ a_2^{[1]}=\sigma(z_2^{[1]})</script><script type="math/tex; mode=display">z_3^{[1]}=w_3^{[1]T}x+b_3^{[1]},\ a_3^{[1]}=\sigma(z_3^{[1]})</script><script type="math/tex; mode=display">z_4^{[1]}=w_4^{[1]T}x+b_4^{[1]},\ a_4^{[1]}=\sigma(z_4^{[1]})</script><p>然后，从隐藏层到输出层的计算公式为：</p><script type="math/tex; mode=display">z_1^{[2]}=w_1^{[2]T}a^{[1]}+b_1^{[2]},\ a_1^{[2]}=\sigma(z_1^{[2]})</script><p>其中$a^{[1]}$为：</p><script type="math/tex; mode=display">{a^{[1]}}= \left[ \begin{matrix} a_1^{[1]} \\ a_2^{[1]} \\ a_3^{[1]} \\ a_4^{[1]} \end{matrix} \right]</script><p>上述每个节点的计算都对应着一次逻辑运算的过程，分别由计算z和a两部分组成。</p><p>为了提高程序的运算速度，我们引入向量化和矩阵运算的思想，将上述表达式转换成矩阵运算的形式：</p><script type="math/tex; mode=display">z^{[1]}=W^{[1]}x+b^{[1]}</script><script type="math/tex; mode=display">a^{[1]}=\sigma(z^{[1]})</script><script type="math/tex; mode=display">z^{[2]}=W^{[2]}a^{[1]}+b^{[2]}</script><script type="math/tex; mode=display">a^{[2]}=\sigma(z^{[2]})</script><p><img src="/2018/02/19/浅层神经网络/ComputingNNoutput2" alt="ComputingNNoutput2"><br>之前也介绍过，$W^{[1]}$的维度是(4,3),$b^{[1]}$的维度是(4,1),$W^{[2]}$的维度是(1,4),$b^{[2]}$的维度是(1,1)。</p><h3 id="Vectorizing-across-multiple-examples"><a href="#Vectorizing-across-multiple-examples" class="headerlink" title="Vectorizing across multiple examples"></a>Vectorizing across multiple examples</h3><p>上一部分我们介绍了单个样本的神经网络正向传播矩阵运算过程。而对于m个训练样本，我们也可以使用矩阵相乘的形式来提高计算效率。而且它的形式与上一部分单个样本的矩阵运算十分相似。</p><p>用上标(i)来表示第i个样本，例如$X^{(i)},Z^{(i)},a^{<a href="i">2</a>}$。对于每个样本i，可以使用for循环来求解其正向输出。</p><p>for i=1 to m:<br>    $z^{<a href="i">1</a>}=W^{[1]}x^{(i)}+b^{[1]}$<br>    $a^{<a href="i">1</a>}=\sigma(z^{<a href="i">1</a>})$<br>    $z^{<a href="i">2</a>}=W^{[2]}a^{<a href="i">1</a>}+b^{[2]}$<br>    $a^{<a href="i">2</a>}=\sigma(z^{<a href="i">2</a>})$</p><p>不使用for循环，利用矩阵运算的思想，输入矩阵X的维度为(n_x,m)。这样，我们可以把上面的for循环写成矩阵运算的形式：</p><script type="math/tex; mode=display">Z^{[1]}=W^{[1]}X+b^{[1]}</script><script type="math/tex; mode=display">A^{[1]}=\sigma(Z^{[1]})</script><script type="math/tex; mode=display">Z^{[2]}=W^{[2]}A^{[1]}+b^{[2]}</script><script type="math/tex; mode=display">A^{[2]}=\sigma(Z^{[2]})</script><p>其中，$Z^{[1]}$的维度是（4,m），4是隐藏层神经元的个数；$A^{[1]}$的维度与$Z^{[1]}$相同；$Z^{[2]}$和$A^{[2]}$的维度均为（1,m）。对上面这四个矩阵来说，均可以这样来理解：行表示神经元个数，列表示样本数目m。</p><h3 id="Explanation-for-Vectorized-Implementation"><a href="#Explanation-for-Vectorized-Implementation" class="headerlink" title="Explanation for Vectorized Implementation"></a>Explanation for Vectorized Implementation</h3><p>只要记住上述四个矩阵的行表示神经元个数，列表示样本数目m就行了。</p><h3 id="Activation-functions"><a href="#Activation-functions" class="headerlink" title="Activation functions"></a>Activation functions</h3><p>神经网络隐藏层和输出层都需要激活函数（activation function），在之前的课程中我们都默认使用Sigmoid函数$\sigma(X)$作为激活函数。其实，还有其它激活函数可供使用，不同的激活函数有各自的优点。下面我们就来介绍几个不同的激活函数g(x)。</p><p><strong>sigmoid函数</strong><br><img src="/2018/02/19/浅层神经网络/sigmoid" alt="sigmoid"></p><p><strong>tanh函数</strong><br><img src="/2018/02/19/浅层神经网络/tanh" alt="tanh"></p><p><strong>ReLU函数</strong><br><img src="/2018/02/19/浅层神经网络/ReLU" alt="ReLU"></p><p><strong>Leaky ReLU</strong><br><img src="/2018/02/19/浅层神经网络/LeakyReLU" alt="LeakyReLU"></p><p>如上图所示，不同激活函数形状不同，a的取值范围也有差异。</p><p>如何选择合适的激活函数呢？首先我们来比较sigmoid函数和tanh函数。对于隐藏层的激活函数，一般来说，tanh函数要比sigmoid函数表现更好一些。因为tanh函数的取值范围在[-1,+1]之间，隐藏层的输出被限定在[-1,+1]之间，可以看成是在0值附近分布，均值为0。这样从隐藏层到输出层，数据起到了归一化（均值为0）的效果。因此，隐藏层的激活函数，tanh比sigmoid更好一些。而对于输出层的激活函数，因为二分类问题的输出取值为{0,+1}，所以一般会选择sigmoid作为激活函数。</p><p>观察sigmoid函数和tanh函数，我们发现有这样一个问题，就是当|z|很大的时候，激活函数的斜率（梯度）很小。因此，在这个区域内，梯度下降算法会运行得比较慢。在实际应用中，应尽量避免使z落在这个区域，使|z|尽可能限定在零值附近，从而提高梯度下降算法运算速度。</p><p>为了弥补sigmoid函数和tanh函数的这个缺陷，就出现了ReLU激活函数。ReLU激活函数在z大于零时梯度始终为1；在z小于零时梯度始终为0；z等于零时的梯度可以当成1也可以当成0，实际应用中并不影响。对于隐藏层，选择ReLU作为激活函数能够保证z大于零时梯度始终为1，从而提高神经网络梯度下降算法运算速度。但当z小于零时，存在梯度为0的缺点，实际应用中，这个缺点影响不是很大。为了弥补这个缺点，出现了Leaky ReLU激活函数，能够保证z小于零是梯度不为0。</p><p>最后总结一下，如果是分类问题，输出层的激活函数一般会选择sigmoid函数。但是隐藏层的激活函数通常不会选择sigmoid函数，tanh函数的表现会比sigmoid函数好一些。实际应用中，通常会会选择使用ReLU或者Leaky ReLU函数，保证梯度下降速度不会太小。其实，具体选择哪个函数作为激活函数没有一个固定的准确的答案，应该要根据具体实际问题进行验证（validation）。</p><h3 id="Why-do-you-need-non-linear-activation-functions"><a href="#Why-do-you-need-non-linear-activation-functions" class="headerlink" title="Why do you need non-linear activation functions"></a>Why do you need non-linear activation functions</h3><p>为什么不能用线性激活函数</p><p>假设所有激活函数都是线性的，为了简化计算，我们直接令激活函数g(z)=z,即a=z。那么，浅层神经网络的各层输出为：</p><script type="math/tex; mode=display">z^{[1]}=W^{[1]}x+b^{[1]}</script><script type="math/tex; mode=display">a^{[1]}=z^{[1]}</script><script type="math/tex; mode=display">z^{[2]}=W^{[2]}a^{[1]}+b^{[2]}</script><script type="math/tex; mode=display">a^{[2]}=z^{[2]}</script><p>我们对上式中$a^{[2]}$进行化简计算：</p><script type="math/tex; mode=display">a^{[2]}=z^{[2]}=W^{[2]}a^{[1]}+b^{[2]}=W^{[2]}(W^{[1]}x+b^{[1]})+b^{[2]}=(W^{[2]}W^{[1]})x+(W^{[2]}b^{[1]}+b^{[2]})=W'x+b'</script><p>经过推导我们发现$a^{[2]}$仍是输入变量x的线性组合。这表明，使用神经网络与直接使用线性模型的效果并没有什么两样。即便是包含多层隐藏层的神经网络，如果使用线性函数作为激活函数，最终的输出仍然是输入x的线性模型。这样的话神经网络就没有任何作用了。因此，隐藏层的激活函数必须要是非线性的。</p><p>另外，如果所有的隐藏层全部使用线性激活函数，只有输出层使用非线性激活函数，那么整个神经网络的结构就类似于一个简单的逻辑回归模型，而失去了神经网络模型本身的优势和价值。</p><p>值得一提的是，如果是预测问题而不是分类问题，输出y是连续的情况下，输出层的激活函数可以使用线性函数。如果输出y恒为正值，则也可以使用ReLU激活函数，具体情况，具体分析。</p><h3 id="Derivatives-of-activation-functions"><a href="#Derivatives-of-activation-functions" class="headerlink" title="Derivatives of activation functions"></a>Derivatives of activation functions</h3><p>在梯度下降反向计算过程中少不了计算激活函数的导数即梯度。</p><p>我们先来看一下sigmoid函数的导数：</p><script type="math/tex; mode=display">g(z)=\frac{1}{1+e^{(-z)}}</script><script type="math/tex; mode=display">g'(z)=\frac{d}{dz}g(z)=g(z)(1-g(z))=a(1-a)</script><p>tanh函数的导数：</p><script type="math/tex; mode=display">g(z)=\frac{e^{(z)}-e^{(-z)}}{e^{(z)}+e^{(-z)}}</script><script type="math/tex; mode=display">g'(z)=\frac{d}{dz}g(z)=1-(g(z))^2=1-a^2</script><p>ReLU函数的导数</p><script type="math/tex; mode=display">g(z)=max(0,z)</script><script type="math/tex; mode=display">g'(z)=\begin{cases} 0, & z<0\\ 1, & z\geq0 \end{cases}</script><p>LeakyReLU函数的导数</p><script type="math/tex; mode=display">g(z)=max(0.01z,z)</script><script type="math/tex; mode=display">g'(z)=\begin{cases} 0.01, & z<0\\ 1, & z\geq0 \end{cases}</script><h3 id="Gradient-descent-for-neural-networks"><a href="#Gradient-descent-for-neural-networks" class="headerlink" title="Gradient descent for neural networks"></a>Gradient descent for neural networks</h3><p>在神经网络中进行梯度计算</p><p>仍然是浅层神经网络，包含的参数为$W^{[1]}$，$b^{[1]}$，$W^{[2]}$，$b^{[2]}$。令输入层的特征向量个数$n_x=n^{[0]}$，隐藏层神经元个数为$n^{[1]}$，输出层神经元个数为$n^{[2]}=1$。则$W^{[1]}$的维度为$(n^{[1]},n^{[0]})$，$b^{[1]}$的维度为$(n^{[1]},1)$，$W^{[2]}$的维度为$(n^{[2]},n^{[1]})$，b[2]的维度为$(n^{[2]},1)$。</p><p>该神经网络正向传播过程为：</p><script type="math/tex; mode=display">Z^{[1]}=W^{[1]}X+b^{[1]}</script><script type="math/tex; mode=display">A^{[1]}=g(Z^{[1]})</script><script type="math/tex; mode=display">Z^{[2]}=W^{[2]}A^{[1]}+b^{[2]}</script><script type="math/tex; mode=display">A^{[2]}=g(Z^{[2]})</script><p>其中，g(⋅)表示激活函数。</p><p>反向传播是计算导数（梯度）的过程，这里先列出来Cost function对各个参数的梯度：</p><script type="math/tex; mode=display">dZ^{[2]}=A^{[2]}-Y</script><script type="math/tex; mode=display">dW^{[2]}=\frac1mdZ^{[2]}A^{[1]T}</script><script type="math/tex; mode=display">db^{[2]}=\frac1mnp.sum(dZ^{[2]},axis=1,keepdim=True)</script><script type="math/tex; mode=display">dZ^{[1]}=W^{[2]T}dZ^{[2]}\ast g'(Z^{[1]})</script><script type="math/tex; mode=display">dW^{[1]}=\frac1mdZ^{[1]}X^T</script><p>$db^{[1]}=\frac1mnp.sum(dZ^{[1]},axis=1,keepdim=True)$$</p><p>反向传播的具体推导过程下一部分进行详细说明</p><h3 id="Backpropagation-intuition-optional"><a href="#Backpropagation-intuition-optional" class="headerlink" title="Backpropagation intuition(optional)"></a>Backpropagation intuition(optional)</h3><p>我们仍然使用计算图的方式来推导神经网络反向传播过程。记得之前介绍逻辑回归时，我们就引入了计算图来推导正向传播和反向传播，其过程如下图所示：<br><img src="/2018/02/19/浅层神经网络/logisticregressiongradients" alt="logisticregressiongradients"></p><p>由于多了一个隐藏层，神经网络的计算图要比逻辑回归的复杂一些，如下图所示。对于单个训练样本，正向过程很容易，反向过程可以根据梯度计算方法逐一推导。</p><script type="math/tex; mode=display">dz^{[2]}=a^{[2]}-y</script><script type="math/tex; mode=display">dW^{[2]}=dz^{[2]}\cdot \frac{\partial z^{[2]}}{\partial W^{[2]}}=dz^{[2]}a^{[1]T}</script><script type="math/tex; mode=display">db^{[2]}=dz^{[2]}\cdot \frac{\partial z^{[2]}}{\partial b^{[2]}}=dz^{[2]}\cdot 1=dz^{[2]}</script><script type="math/tex; mode=display">dz^{[1]}=dz^{[2]}\cdot \frac{\partial z^{[2]}}{\partial a^{[1]}}\cdot \frac{\partial a^{[1]}}{\partial z^{[1]}}=W^{[2]T}dz^{[2]}\ast g^{[1]'}(z^{[1]})</script><script type="math/tex; mode=display">dW^{[1]}=dz^{[1]}\cdot \frac{\partial z^{[1]}}{\partial W^{[1]}}=dz^{[1]}x^T</script><script type="math/tex; mode=display">db^{[1]}=dz^{[1]}\cdot \frac{\partial z^{[1]}}{\partial b^{[1]}}=dz^{[1]}\cdot 1=dz^{[1]}</script><p><img src="/2018/02/19/浅层神经网络/neuralnetworkgradients" alt="neuralnetworkgradients"><br>浅层神经网络（包含一个隐藏层），m个训练样本的正向传播过程和反向传播过程分别包含了6个表达式，其向量化矩阵形式如下图所示：<br><img src="/2018/02/19/浅层神经网络/summary" alt="summary"></p><h3 id="Random-Initialization"><a href="#Random-Initialization" class="headerlink" title="Random Initialization"></a>Random Initialization</h3><p>神经网络模型中的参数权重W是不能全部初始化为零的，接下来我们分析一下原因。</p><p>举个简单的例子，一个浅层神经网络包含两个输入，隐藏层包含两个神经元。如果权重$W^{[1]}$和$W^{[2]}$都初始化为零，即：</p><script type="math/tex; mode=display">W^{[1]}= \left[ \begin{matrix} 0 & 0 \\ 0 & 0 \end{matrix} \right]</script><script type="math/tex; mode=display">W^{[2]}= \left[ \begin{matrix} 0 & 0 \end{matrix} \right]</script><p>这样使得隐藏层第一个神经元的输出等于第二个神经元的输出，即$a_1^{[1]}=a_2^{[1]}$。经过推导得到$dz_1^{[1]}=dz_2^{[1]}$，以及$W_1^{[1]}=dW_2^{[1]}$。因此，这样的结果是隐藏层两个神经元对应的权重行向量$W_1^{[1]}$和$W_2^{[1]}$每次迭代更新都会得到完全相同的结果，$W_1^{[1]}$始终等于$W_2^{[1]}$，完全对称。这样隐藏层设置多个神经元就没有任何意义了。值得一提的是，参数b可以全部初始化为零，并不会影响神经网络训练效果。<br><img src="/2018/02/19/浅层神经网络/initialization" alt="initialization"></p><p>我们把这种权重W全部初始化为零带来的问题称为symmetry breaking problem。解决方法也很简单，就是将W进行随机初始化（b可初始化为零）。python里可以使用如下语句进行W和b的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">W_1 = np.random.randn((2,2))*0.01</span><br><span class="line">b_1 = np.zero((2,1))</span><br><span class="line">W_2 = np.random.randn((1,2))*0.01</span><br><span class="line">b_2 = 0</span><br></pre></td></tr></table></figure></p><p>这里我们将$W_1^{[1]}$和$W_2^{[1]}$乘以0.01的目的是尽量使得权重W初始化比较小的值。之所以让W比较小，是因为如果使用sigmoid函数或者tanh函数作为激活函数的话，W比较小，得到的|z|也比较小（靠近零点），而零点区域的梯度比较大，这样能大大提高梯度下降算法的更新速度，尽快找到全局最优解。如果W较大，得到的|z|也比较大，附近曲线平缓，梯度较小，训练过程会慢很多。</p><p>当然，如果激活函数是ReLU或者Leaky ReLU函数，则不需要考虑这个问题。但是，如果输出层是sigmoid函数，则对应的权重W最好初始化到比较小的值。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本节课主要介绍了浅层神经网络。首先，我们简单概述了神经网络的结构：包括输入层，隐藏层和输出层。然后，我们以计算图的方式推导了神经网络的正向输出，并以向量化的形式归纳出来。接着，介绍了不同的激活函数并做了比较，实际应用中根据不同需要选择合适的激活函数。激活函数必须是非线性的，不然神经网络模型起不了任何作用。然后，我们重点介绍了神经网络的反向传播过程以及各个参数的导数推导，并以矩阵形式表示出来。最后，介绍了权重随机初始化的重要性，必须对权重W进行随机初始化操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Neural-Network-Overview&quot;&gt;&lt;a href=&quot;#Neural-Network-Overview&quot; class=&quot;headerlink&quot; title=&quot;Neural Network Overview&quot;&gt;&lt;/a&gt;Neural Network Ov
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>神经网络基础之Python与向量化</title>
    <link href="http://andeper.cn/2018/02/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BPython%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96/"/>
    <id>http://andeper.cn/2018/02/19/神经网络基础之Python与向量化/</id>
    <published>2018-02-18T19:31:26.000Z</published>
    <updated>2018-02-19T12:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vectorization"><a href="#Vectorization" class="headerlink" title="Vectorization"></a>Vectorization</h3><p>深度学习算法中，数据量很大，在程序中尽量减少使用loop循环语句，而可以使用向量运算来提高程序运行速度。</p><p>向量化(Vectorization)就是利用矩阵运算的思想，大大提高运算速度。例如下面所示在Python中使用向量化要比使用循环计算速度快得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">a = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line">b = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">tic = time.time()</span><br><span class="line">c = np.dot(a,b)</span><br><span class="line">toc = time.time()</span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">print(<span class="string">"Vectorized version:"</span> + str(<span class="number">1000</span>*(toc-tic)) + <span class="string">"ms"</span>)</span><br><span class="line"></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line">tic = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    c += a[i]*b[i]</span><br><span class="line">toc = time.time()</span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">print(<span class="string">"for loop:"</span> + str(<span class="number">1000</span>*(toc-tic)) + <span class="string">"ms"</span>)</span><br></pre></td></tr></table></figure><p>输出结果类似于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">250286.989866</span><br><span class="line">Vectorized version:1.5027523040771484ms</span><br><span class="line">250286.989866</span><br><span class="line">For loop:474.29513931274414ms</span><br></pre></td></tr></table></figure></p><p>从程序运行结果上来看，该例子使用for循环运行时间是使用向量运算运行时间的约300倍。因此，深度学习算法中，使用向量化矩阵运算的效率要高得多。</p><p>为了加快深度学习神经网络运算速度，可以使用比CPU运算能力更强大的GPU。事实上，GPU和CPU都有并行指令(parallelization instructions),称为Single Instruction Multiple Data(SIMD)。SIMD是单指令多数据流，能够复制多个操作数，并把它们打包在大型寄存器的一组指令集。SIMD能够大大提高程序运行速度，例如python的numpy库中的内建函数(build-in function) 就是使用了SIMD指令。相比而言，GPU的SIMD要比CPU更强大一些。</p><h3 id="More-Vectorization-Examples"><a href="#More-Vectorization-Examples" class="headerlink" title="More Vectorization Examples"></a>More Vectorization Examples</h3><p>尽量避免使用for循环而使用向量化矩阵运算。在python的numpy库中，我们通常使用np.dot()函数来进行矩阵运算。</p><p>我们将向量化的思想使用在逻辑回归算法，尽可能减少for循环，而只使用矩阵运算。值得注意的是，算法最顶层的迭代训练的for循环是不能替换的。而每次迭代过程对J，dw，b的计算是可以直接使用矩阵运算。</p><h3 id="Vectorizing-Logistic-Regression"><a href="#Vectorizing-Logistic-Regression" class="headerlink" title="Vectorizing Logistic Regression"></a>Vectorizing Logistic Regression</h3><p>整个训练样本构成的输入矩阵X的维度是$(n_X,1)$,b是一个常数值，而整个训练忘本构成的输出矩阵Y的维度是(1,m)。利用向量化的思想，所有m个样本的线性输出Z可以用矩阵表示：</p><script type="math/tex; mode=display">Z=w^TX+b</script><p>在python的numpy库中可以表示为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.dot(w.T,X) + b</span><br><span class="line">A = sigmoid(Z)</span><br></pre></td></tr></table></figure></p><p>其中，w，T表示w的转置</p><p>这样，我们就能够使用向量化矩阵运算代替for循环，对所有m个样本同时运算，大大提高了运算速度。</p><h3 id="Vectorizing-Logistic-Regression’s-Gradient-Output"><a href="#Vectorizing-Logistic-Regression’s-Gradient-Output" class="headerlink" title="Vectorizing Logistic Regression’s Gradient Output"></a>Vectorizing Logistic Regression’s Gradient Output</h3><p>再来看逻辑回归中的梯度下降算法如何转化为向量化的矩阵形式。对于所有m个样本，db可表示为：</p><script type="math/tex; mode=display">dZ=A-Y</script><p>db可表示为：</p><script type="math/tex; mode=display">db=\frac{1}{m}\sum\limits_{i=1}^mdz^{(i)}</script><p>对应的程序为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db=1/m*np.sum(dZ)</span><br></pre></td></tr></table></figure></p><p>dw课表示为：</p><script type="math/tex; mode=display">dw=\frac{1}{m}X\cdot dZ^{T}</script><p>对应的程序为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dw=1/m*np.dot(X,dZ,T)</span><br></pre></td></tr></table></figure></p><p>这样，我们把整个逻辑回归中的for循环尽可能用矩阵运算代替，对于单次迭代，梯度下降算法流程如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Z=np.dot(w.T,X)+b</span><br><span class="line">A= sigmoid(Z)</span><br><span class="line">dZ= A-Y</span><br><span class="line">dw = 1/m*np.dot(X,dZ.T)</span><br><span class="line">db = 1/m*np.sum(dZ)</span><br><span class="line"></span><br><span class="line">w = w - alpha*dw</span><br><span class="line">b = b - alpha*db</span><br></pre></td></tr></table></figure></p><p>其中，alpha是学习因子，决定w和b的更新速度。上述代码只是单次训练更新而言的，外层还需要一个for循环，代表迭代次数。</p><h3 id="Broadcasting-in-Python"><a href="#Broadcasting-in-Python" class="headerlink" title="Broadcasting in Python"></a>Broadcasting in Python</h3><p>下面介绍使用python的另一种技巧：广播(Broadcasting).python中的广播机制可以由下面四条表示：<br><strong>·让所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐</strong><br><strong>·输出数组的shape是输入数组shape的各轴上的最大值</strong><br><strong>·如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为1时，这个数组能够用来计算，否则出错</strong><br><strong>·当输入数组的某个轴的长度为1时，沿着此轴运算时都用此轴上的第一组值</strong><br>简而言之，就是用python中可以对不同维度的矩阵进行四则混合运算，但至少保证有一个维度是相同的。下面给出几个广播的例子，具体细节可参阅python的相关手册，这里就不赘述了。</p><script type="math/tex; mode=display">Broadcasting examples</script><script type="math/tex; mode=display">\begin{bmatrix} 1\\ 2\\ 3\\ 4 \end{bmatrix} + 100=\begin{bmatrix} 101\\ 102\\ 103\\ 104 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} 1&2&3\\ 4&5&6 \end{bmatrix} + \begin{bmatrix} 100&200&300\end{bmatrix} = \begin{bmatrix} 101&202&303\\ 104&205&306 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}1&2&3\\4&5&6\end{bmatrix} + \begin{bmatrix} 100\\200\end{bmatrix} = \begin{bmatrix} 101&102&103\\ 204&205&206 \end{bmatrix}</script><p>在python程序中为了保证矩阵运算正确，可以使用reshape()函数来对矩阵设定所需的维度。这是一个很好且有用的习惯。</p><h3 id="A-note-on-python-numpy-vectors"><a href="#A-note-on-python-numpy-vectors" class="headerlink" title="A note on python/numpy vectors"></a>A note on python/numpy vectors</h3><p>总结一些python的小技巧，避免不必要的code bug<br>python中，如果我们用下列语句来定义一个变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.randn(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>这条语句生成的a维度是(5, )。它既不是行向量也不是列向量，我们把a叫做rank 1 array。这种定义会带来一些问题。例如我们对a进行转置，还会得到a本身。所以，如果我们要定义(5,1)的列向量，最好使以下标准语句，避免使用rank 1 array。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.randn(<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">b = np.random.randn(<span class="number">1</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>除此之外，我们还可以使用assert语句对向量或者数组的维度进行判断，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(a.shape == (<span class="number">5</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p>assert语句会对内嵌语句进行判断，即判断a的维度是不是(5,1)的。如果不是，则程序在此处停止。使用assert语句也是一种很好的习惯，能够帮我们及时检查、发现语句是否正确。<br>另外，还可以使用reshape函数对数组设定所需的维度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.shape((<span class="number">5</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><h3 id="Quick-tour-of-Jupyter-iPython-Notebooks"><a href="#Quick-tour-of-Jupyter-iPython-Notebooks" class="headerlink" title="Quick tour of Jupyter/iPython Notebooks"></a>Quick tour of Jupyter/iPython Notebooks</h3><p>Jupyter notebook是一个交互笔记本，支持运行40中编程语言，本课程所有的编程练习题都将在Jupyter notebook上进行，使用语言是python。</p><h3 id="Explanation-of-logistic-regression-cost-function-optional"><a href="#Explanation-of-logistic-regression-cost-function-optional" class="headerlink" title="Explanation of logistic regression cost function(optional)"></a>Explanation of logistic regression cost function(optional)</h3><p>接下来简要介绍逻辑回归的Cost function是怎么来的<br>首先，预测输出$\hat{y}$的表达式可以写成:</p><script type="math/tex; mode=display">\hat{y}=\sigma(w^Tx+b)</script><p>其中，$\sigma(z)=\frac{1}{1+exp(-z)}$。$\hat{y}$可以看成是预测输出为正类(+1)的概率：</p><script type="math/tex; mode=display">\hat{y}=P(y=1|X)</script><p>那么，当y=1时：</p><script type="math/tex; mode=display">p(y|x)= \hat{y}</script><p>当y= 0时：</p><script type="math/tex; mode=display">p(y|x)=\hat{y}^y(1-\hat{y})^{(1-y)}</script><p>我们把上面两个式子整合到一个式子中，得到：</p><script type="math/tex; mode=display">P(y|x)=\hat{y}^y(1-\hat{y})^{(1-y)}</script><p>由于log函数的单调性，可以对上式P(y|x)进行log处理</p><script type="math/tex; mode=display">logP(y|x)=log\hat{y}^y(1-\hat{y})^{(1-y)}=ylog\hat{y}+(1-y)log(1-\hat{y})</script><p>我们希望上述概率P(y|x)越大越好，对上式加上负号，则转化成额单个样本的Loss function，越小越好，也iu得到了我们之前介绍的逻辑回归的Loss function形式</p><script type="math/tex; mode=display">L=-(ylog\hat{y}+(1-y)log(1-\hat{y}))</script><p>如果对于所有m个训练样本，假设样本之间是独立同分布的(iid),我们希望总的概率越大越好：</p><script type="math/tex; mode=display">max\ \prod_{i=1}^m\ P(y^{(i)}|x^{(i)})</script><p>同样引入log函数，加上负号，将上式转化为Cost function：</p><script type="math/tex; mode=display">J(w,b)=-\frac1m\sum_{i=1}^mL(\hat y^{(i)},y^{(i)})=-\frac 1m\sum_{i=1}^my^{(i)}\ log\ \hat y^{(i)}+(1-y^{(i)})log(1-\hat y^{(i)})</script><p>上式中，$\frac{1}{m}$表示对所有m个样本的Cost function求平均，是缩放因子。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本节课我们主要介绍了神经网络基础————python和向量话。在深度学习程序中，使用向量化和矩阵运算的方法能够大大提高运行速度，节省时间。以逻辑回归威力，我们将算法流程包括梯度下降转化为向量化的形式，同时，我们也介绍了python的相关编程方法和技巧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vectorization&quot;&gt;&lt;a href=&quot;#Vectorization&quot; class=&quot;headerlink&quot; title=&quot;Vectorization&quot;&gt;&lt;/a&gt;Vectorization&lt;/h3&gt;&lt;p&gt;深度学习算法中，数据量很大，在程序中尽量减少使用lo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>神经网络基础之逻辑回归</title>
    <link href="http://andeper.cn/2018/01/26/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://andeper.cn/2018/01/26/神经网络基础之逻辑回归/</id>
    <published>2018-01-26T09:11:36.000Z</published>
    <updated>2018-02-19T10:58:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>附：从本章开始常用到数学符号和公式，这里贴出在md中写公式的方法，<a href="http://blog.csdn.net/zryxh1/article/details/53161011" target="_blank" rel="noopener">md语法|LaTex数学公式</a>。遇到不知道的符号可以去在线编辑器选择查看代码 <a href="http://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">Latex在线编辑器</a></strong></p><h3 id="Binary-Classification"><a href="#Binary-Classification" class="headerlink" title="Binary Classification"></a>Binary Classification</h3><p>逻辑回归模型一般是用来解决二分类(Binary Classification)问题。二分类就是输出y只有{0，1}两个离散值(也有{1,-1}的情况)。<br>我们以一个图像识别问题为例，判断图片中是否有猫的存在，0代表no cat，1代表cat，如下图所示。<br><img src="/2018/01/26/神经网络基础之逻辑回归/binaryclassification.png" alt="binaryclassification"><br>主要通过这个例子简要介绍神经网络模型中的一些标准化的、有效率的处理方法和notations。<br><img src="/2018/01/26/神经网络基础之逻辑回归/binaryclassification2.png" alt="binaryclassification2"><br>如上图所示，这是一个典型的二分类问题。一般来说，彩色图片包含RGB三个通道。例如该cat的图片尺寸为(64,64,3)。在神经网络模型中，我们首先要将图片输入x转化为一维的特征向量(feature vector)。方法是每个通道一行一行取，再连接起来。由于$64\times 64\times 3= 12288$，转化后的输入特征向量维度为(12288,1)。此特征向量x是列向量，维度一般记为$n_x$。<br>如果训练样本共有m张图片，那么整个训练样本X组成了矩阵，维度是$(n_x,1)$。注意，这里的矩阵X的行$n_x$代表了每个样本$x^{(i)}$特征个数，列m代表了样本个数。这里Andrew解释了X的维度之所以是$(n_x,m)$而不是$(m,n_x)$是为了之后矩阵运算的方便。而所有的训练样本的输出Y也组成了一维的行向量，写成矩阵的形式后，它的维度就是$(1,m)$。</p><h3 id="Logistic-regression"><a href="#Logistic-regression" class="headerlink" title="Logistic regression"></a>Logistic regression</h3><p>如何使用逻辑回归来解决二分类问题。逻辑回归中，预测值$\hat{h}=P(y=1|x)$表示为1的概率，取值范围在[0,1]之间。这是其与二分类模型不同的地方。使用线性模型，引入参数w和b。权重w的维度是$(n_x,1)$,b是一个常数项。这样，逻辑回归的线性预测输出可以写成：</p><script type="math/tex; mode=display">\hat{h}=w^{T}x+b</script><p>值得注意的是，很多其他机器学习资料中，可能吧常数b当作$w_0$处理，并引入$x_0=1$,这样从维度上来看，x和w都会增加一维，但在本课程中，为了简化计算和便于理解，Andrew建议还是用上式这种形式将w和b分开比较好。<br>上式的线性输出区间为整个实数范围，而逻辑回归要求输出范围在[0,1]之间，所以还需要对上式的线性函数输出进行处理，方法是引入Sigmoid函数，让输出限定在[0,1]之间。这样，逻辑回归的预测输出就可以完整写成：</p><script type="math/tex; mode=display">\hat{y}=Sigmoid(w^{T}x+b)=\sigma(w^{T}+b)</script><p>Sigmoid函数是一种非线性的S型函数，输出被限定在[0,1]之间，通常被用在神经网络中当作激活函数(Activation function)使用。Sigmoid函数的表达式和曲线如下：</p><script type="math/tex; mode=display">Sigmoid(z)=\frac{1}{1+e^{-z}}</script><p><img src="/2018/01/26/神经网络基础之逻辑回归/Sigmoid" alt="sigmoid"><br>从Sigmoid函数可以看出，当z值很大时，函数值趋向于1；当z值很小时，函数值趋向于0.且当z=0时，函数值为0.5。Sigmoid函数的一阶导数可以用其自身表示：</p><script type="math/tex; mode=display">\sigma(z)=\sigma(z)(1-\sigma(z))</script><p>这样，通过Sigmoid函数，就能够将逻辑回归的输出限定在[0,1]之间了。</p><h3 id="Logistic-Regression-Cost-Function"><a href="#Logistic-Regression-Cost-Function" class="headerlink" title="Logistic Regression Cost Function"></a>Logistic Regression Cost Function</h3><p>逻辑回归中，w和b都是未知参数，需要反复训练和优化得到。因此，我们需要定义一个cost function，包含了参数w和b。通过优化cost function ，当cost function取值最小时，得到对应的w和b</p><p>对于m个训练样本，我们通常使用上标来表示对应的样本，例如$(x^{(i)},y^{(i)})$来表示第i个样本。</p><p>如何定义所有m个样本的cost function呢，先从单个样本出发，我们希望该样本的预测值$\hat{y}$与真实值越相似越好。我们把单个样本的cost function用Loss function来表示，根据以往经验，如果使用平方误差(squared error)来衡量，如下所示：</p><script type="math/tex; mode=display">L(\hat{y},y) = \frac{1}{2}(\hat{y}-y)^{2}</script><p>但是对于逻辑回归，我们一般不用平方误差来衡量，因为这种Loss function一般是non-convex(非凸性)的。non-convex函数在使用梯度下降法时，容易得到局部最小值(local minmum),即局部最优化。而我们的目标是计算得到全局最优化(Global optimization).因此，我们一般选择的Loss function应该是convex的。</p><p>Loss function的原则和目的是衡量预测输出$\hat(y)$与真实样本输出y的接近程度。平方误差其实也可以，只是它是non-convex的，不利于使用梯度下降法来进行全局优化。因此，我们可以构建另外一种Loss function，且是convex的，如下所示：</p><script type="math/tex; mode=display">L(\hat{y},y)=-(ylog\hat{y}+(1-y)log(1-\hat{y}))</script><p>这个Loss function。它是衡量误差大小的，Loss function越小越好。</p><p>当y=1时，$L(\hat{y},y)=-log\hat{y}$,如果$\hat{y}$越接近1，$L(\hat{y},y)\approx0$,表示预测效果越好；如果$\hat{y}$越接近0，$L(\hat{y},y)\approx+\infty$,表示预测效果越差。这正是我们希望Loss function所实现的功能。</p><p>当y=0时，$L(\hat{y},y)=-log(1-\hat{y})$.如果$\hat{y}$越接近于0，$L(\hat{y},y)\approx0$,表示预测效果越好；如果$\hat{y}$越接近于1，$L(\hat{y},y)\approx+\infty$,表示预测效果越差。这也正是我们希望Loss function所实现的功能。</p><p>因此，这个Loss function能够很好地反映预测输出$\hat{y}$与真实样本输出y的接近程度，越接近的话，其Loss function的值越小。而且这个函数是convex的。上面我们只是简要分析为什么要使用这个Loss function后面的课程将详细推导这个Loss function是如何得到的</p><p>Loss function是针对单个样本的，对于m个样本，我们定义Cost function。Cost function是m的样本的Loss function的平均值，反映了m个样本的预测输出$\hat{y}$与真实样本输出y的平均接近程度。Cost function可表示为：</p><script type="math/tex; mode=display">J(w,b)=\frac{1}{m}\sum\limits_{k=1}^m[y^{(i)}log\hat{y}^{(i)}+(1-y^{(i)})log(1-\hat{y}^{(i)})]</script><p>Cost function已经推导出来了，Cost function是关于待求系数w和b的函数。我们的目标是迭代计算出最佳的w和b值，最小化Cost function，让Cost function尽可能接近于零。</p><p>其实逻辑回归问题可以看成是一个简单的神经网络，只包含一个神经元。这也是我们先介绍逻辑回归的原因。</p><h3 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h3><p>我们已经掌握Cost function的表达式，接下来将使用梯度下降(Gradient Descent)算法计算出合适的w和b值，从而最小化m个训练样本的Cost function，即J(w,b)。</p><p>由于J(w,b)是convex function，梯度下降算法是先随机选择一组参数w和b值，然后每次迭代的过程中分别沿着w和b的梯度(偏导数)的反方向前进一小步，不断修正w和b。每次迭代更新w和b后，都能让J(w,b)更接近全局最小值。梯度下降的过程如下图所示<br><img src="/2018/01/26/神经网络基础之逻辑回归/GradientDescent" alt="GradientDescent"><br>梯度下降算法每次迭代更新，w和b的修正表达式为</p><script type="math/tex; mode=display">w:=w-\alpha\frac{\partial J(w,b)}{\partial w}</script><script type="math/tex; mode=display">b:=b-\alpha\frac{\partial J(w,b)}{\partial b}</script><p>上式中，$\alpha$是学习因子(learning rate),表示梯度下降的步进长度。$\alpha$越大，w和b每次更新的“步伐”更大一些；$\alpha$越小，w和b每次更新的“步伐”更小一些。在程序代码中，我们通常使用dw来表示$frac{\partial J(w,b)}{\partial w}$，用db来表示$\frac{\partial J(w,b)}{\partial b}$。微积分里，$\frac{df}{dx}$表示对单一变量求导数，$\frac{\partial f}{\partial x}$表示对多个变量中的某个变量求偏导数。</p><p>梯度下降算法能够保证每次迭代w和b都能向着J(w,b)全局最小化的方向进行，其数学原理主要是运用泰勒一阶展开来证明的</p><h3 id="Derivatives"><a href="#Derivatives" class="headerlink" title="Derivatives"></a>Derivatives</h3><p>这一部分内容主要是Andrew对微积分、求导数进行介绍。梯度或者导数一定程度上可以看成斜率，这里不再赘述。</p><h3 id="More-Derivatives-Examples"><a href="#More-Derivatives-Examples" class="headerlink" title="More Derivatives Examples"></a>More Derivatives Examples</h3><p>Andrew给出更复杂求导数的例子。</p><h3 id="Computation-graph"><a href="#Computation-graph" class="headerlink" title="Computation graph"></a>Computation graph</h3><p>整个神经网络的训练过程实际上包含了两个过程：正向传播(Forward Propagation)和反向传播(Back Propagation)。正向传播是从输入到输出，由神经网络计算的到预测输出的过程，反向传播是从输出到输入，对参数w和b计算梯度的过程。下面，我们用计算图(Computation graph)的形式来理解这两个过程。</p><p>举个简单的例子，假如Cost function为J(a,b,c)=3(a+bc),包含啊a,b,c三个变量。我们用u表示bc，v表示a+u,则J=3v。它的计算图可以写成如下图所示：<br><img src="/2018/01/26/神经网络基础之逻辑回归/Computationgraph" alt="Computationgraph"><br>令a=5,b=3,c=2,则u=bc=6，v=a+u=11，J=3v=33。计算图中，这种从左到右，从输入到输出的过程就对应着神经网络或者逻辑回归中输入与权重经过运算计算得到Cost function的正向过程。</p><h3 id="Derivatives-with-a-Computation-Graph"><a href="#Derivatives-with-a-Computation-Graph" class="headerlink" title="Derivatives with a Computation Graph"></a>Derivatives with a Computation Graph</h3><p>上一部分介绍的是计算图的正向传播(Forward Propagation),下面我们来介绍其反向传播(Back Propagation),即计算输出对输入的偏导数。</p><p>还是上个计算图的例子，输入参数有3个，分别是a，b，c。</p><p>首先计算J对参数a的偏导数。从计算图上来看，从右到左，J是v的函数，v是a的函数，则利用求导技巧，可以得到：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial a}=\frac{\partial J}{\partial v}\cdot\frac{\partial v}{\partial a}=3\cdot1=3</script><p>根据这种思想，然后计算J对参数b的偏导数。从计算图上来看，从右到左，J是v的函数，v是u的函数，u是b的函数。可以推导：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial b}=\frac{\partial J}{\partial v}\cdot\frac{\partial v}{\partial u}\cdot\frac{\partial u}{\partial b}=3\cdot 1\cdot c=3\cdot 1\cdot 2=6</script><p>最后计算J对参数c的偏导数。仍从计算图上来看，从右到左，J是v的函数，v是u的函数，u是c的函数。可以推导：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial c}=\frac{\partial J}{\partial v}\cdot\frac{\partial v}{\partial u}\cdot\frac{\partial u}{\partial c}=3\cdot 1\cdot b=3\cdot 1\cdot 3=9</script><p>为了同一格式，在程序代码中，我们使用da，db，dc来表示J对参数a，b，c的偏导数。<br><img src="/2018/01/26/神经网络基础之逻辑回归/Computationgraph2" alt="Computationgraph2"></p><h3 id="Logistic-Regression-Gradient-Descent"><a href="#Logistic-Regression-Gradient-Descent" class="headerlink" title="Logistic Regression Gradient Descent"></a>Logistic Regression Gradient Descent</h3><p>现在，我们将对逻辑回归进行梯度计算。对单个样本而言，逻辑回归Loss function表达式如下：</p><script type="math/tex; mode=display">z=w^{T}x+b</script><script type="math/tex; mode=display">\hat{y}=a=\sigma(z)</script><script type="math/tex; mode=display">L(a,y)=-(ylog(a)+(1-y)log(1-a))</script><p>首先，该逻辑回归的正向传播过程非常简单。根据上述公式，例如输入样本x有两个特征(x1,x2),相应的权重w维度也是2，即(w1,w2)。则$z=w_1x_1+w_2x_2+b$,最后的Loss function如下所示：<br><img src="/2018/01/26/神经网络基础之逻辑回归/Logisticregression" alt="Logisticregression"><br>然后，计算该逻辑回归的反向传播过程，即由Loss function计算参数w和b的偏导数。推导过程如下：</p><script type="math/tex; mode=display">da=\frac{\partial L}{\partial a}= -\frac{y}{a}+\frac{1-y}{1-a}</script><script type="math/tex; mode=display">dz=\frac{\partial L}{\partial z}=\frac{\partial L}{\partial a}\cdot\frac{\partial a}{\partial z}= (-\frac{y}{a}+\frac{1-y}{1-a})\cdot a(1-a)= a-y</script><p>知道了dz之后，就可以直接对$W_1,W_2$和b进行求导了。</p><script type="math/tex; mode=display">dw_1=\frac{\partial L}{\partial w_1}=\frac{\partial L}{\partial z}\cdot\frac{\partial z}{\partial w_1}=x_1\cdot dz=x_1(a-y)</script><script type="math/tex; mode=display">dw_2=\frac{\partial L}{\partial w_2}=\frac{\partial L}{\partial z}\cdot\frac{\partial z}{\partial w_2}=x_2\cdot dz=x_2(a-y)</script><script type="math/tex; mode=display">db=\frac{\partial L}{\partial b}=\frac{\partial L}{\partial z}\cdot\frac{\partial z}{\partial b}=1\cdot dz=a-y</script><p>则梯度下降算法可以表示为：</p><script type="math/tex; mode=display">w_1:=w_1-\alpha dw_1</script><script type="math/tex; mode=display">w_2:=w_2-\alpha dw_2</script><script type="math/tex; mode=display">b:=b-\alpha db</script><p><img src="/2018/01/26/神经网络基础之逻辑回归/Logisticregression2" alt="Logisticregression2"></p><h3 id="Gradient-Descent-on-m-examples"><a href="#Gradient-Descent-on-m-examples" class="headerlink" title="Gradient Descent on m examples"></a>Gradient Descent on m examples</h3><p>上一部分讲的是对单个样本求偏导和梯度下降。如果有m个样本，其Cost function 表达式如下：</p><script type="math/tex; mode=display">z^{(i)}=w^{T}x^{(i)}+b</script><script type="math/tex; mode=display">\hat{y}^{(i)}=a^{(i)}=\sigma(z^{(i)})</script><script type="math/tex; mode=display">J(w,b)=\frac{1}{m}\sum\limits_{i=1}^mL(\hat{y}^{(i)},y^{(i)})=-\frac{1}{m}\sum\limits_{i=1}^m[y^{(i)}log\hat{y}^{(i)}+(1-y^{(i)})log(1-\hat{y}^{(i)})]</script><p>Cost function关于w和b的偏导数可以写成和平均的形式</p><script type="math/tex; mode=display">dw_1=\frac{1}{m}\sum\limits_{i=1}^mx_1^{(i)}(a^{(i)}-y^{(i)})</script><script type="math/tex; mode=display">dw_2=\frac{1}{m}\sum\limits_{i=1}^mx_2^{(i)}(a^{(i)}-y^{(i)})</script><script type="math/tex; mode=display">db=\frac{1}{m}\sum\limits_{i=1}^m(a^{(i)}-y^{(i)})</script><p>这次，每次迭代中w和b的梯度有m个训练样本计算平均值得到。其算法流程图如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">J=0;dw1=0; dw2=0;db=0;</span><br><span class="line">for i = 1 to m</span><br><span class="line">    z(i) = wx(i)+b;</span><br><span class="line">    a(i) = sigmoid(z(i));</span><br><span class="line">    J += -[y(i)log(a(i))+(1-y(i)）log(1-a(i));</span><br><span class="line">    dz(i) = a(i)-y(i);</span><br><span class="line">    dw1 += x1(i)dz(i);</span><br><span class="line">    dw2 += x2(i)dz(i);</span><br><span class="line">    db += dz(i);</span><br><span class="line">J /= m;</span><br><span class="line">dw1 /= m;</span><br><span class="line">dw2 /= m;</span><br><span class="line">db /= m;</span><br></pre></td></tr></table></figure></p><p>这样经过n次迭代后，整个梯度下降算法就完成了。</p><p>在上述的梯度下降算法中，我们是利用for循环对每个样本进行dw1，dw2和db的累加计算最后再求平均数的。在深度学习中，样本数量m通常很大，使用for循环会让神经网络程序运行得很慢。所以，我们应该尽量避免使用for循环操作，而使用矩阵运算，能够大大提高程序运行速度。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本节课主要介绍了神经网络的基础——逻辑回归。首先，我们介绍了二分类问题，以图片为例，将多维输入x转化为feature vector，输出y只有{0，1}两个离散值。介绍了逻辑回归及其对应的Cost function 形式，然后介绍了梯度下降算法，并使用计算图的方式来讲述神经网络的正向传播和反向传播两个过程，总结出最优化参数w和b的算法流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;附：从本章开始常用到数学符号和公式，这里贴出在md中写公式的方法，&lt;a href=&quot;http://blog.csdn.net/zryxh1/article/details/53161011&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;md
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度学习概论</title>
    <link href="http://andeper.cn/2018/01/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/"/>
    <id>http://andeper.cn/2018/01/17/深度学习概论/</id>
    <published>2018-01-17T08:22:22.000Z</published>
    <updated>2018-02-18T18:08:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于毕业设计选择了深度学习相关的选题，我便开始学习深度学习相关的课程，使用的课程资源是吴恩达的《神经网络与深度学习》,<a href="http://mooc.study.163.com/smartSpec/detail/1001319001.htm" target="_blank" rel="noopener">课程链接</a>,最近的博客基本会以这个课程的笔记为主。</p><h3 id="What-is-a-neural-network"><a href="#What-is-a-neural-network" class="headerlink" title="What is a neural network?"></a>What is a neural network?</h3><p>什么是神经网络，下面通过一个简单的例子引入神经网络模型的概念。</p><p>加入我们要建立房价的预测模型，一共有六个房子。我们已知输入x即每个房子的面积，还知道其对应的输出y即每个房子的价格。根据这些输入输出，我们要简历一个函数模型，来预测房价。根据这些输入输出，我们要建立一个函数模型，来预测房价：y=f(x)。首先，我们将已知的六间房子的价格和面积关系绘制在二维平面上，如下图所示：<br><img src="/2018/01/17/深度学习概论/housepriceprediction.png" alt="housepriceprediction"><br>一般地，我们会用一条之间来拟合图中这些离散点，即建立房价与面积的线性模型。但是从实际考虑，我们知道价格永远不会是负数。所以，我们对该之间做一点点修正，让它编程折线的形状，当面积小于某个值时，价格始终为零，如下图蓝色折线所示，这就是我们建立的房价预测模型<br><img src="/2018/01/17/深度学习概论/housepriceprediction2.png" alt="housepriceprediction2"><br>其实这个简单的模型(蓝色折线)就可以看成是一个神经网络，而且几乎是一个最简单的神经网络，我们把房价预测用一个最简单的神经网络模型来表示，如下图所示<br><img src="/2018/01/17/深度学习概论/networkneuron.png" alt="networkneuron"><br>该神经网络的输入x是房屋面积，输入y是房屋价格，中间包含了一个神经元(neuron)，房价预测函数(蓝色折线)。该神经元的功能就是实现函数f(x)的功能。</p><p>上图神经元的预测函数在神经网络应用中比较常见，我们把这个函数称为ReLU函数，即线性整流函数，如下图所示<br><img src="/2018/01/17/深度学习概论/ReLU.png" alt="ReLU"></p><p>上面讲的只是由单个神经元(输入x仅仅是房屋面积一个因素)组成的神经网络，而通常一个大型的神经网络往往由许多个神经元组成。</p><p>现在，我们把上面房价预测例子变得更复杂，而不仅仅使用房屋面积(size)一个判断因素。例如，除了考虑房屋面积之外，我们还考虑卧室数目(bedrooms)。这两点实际上与家庭成员的个数(family size)有关。还有房屋的邮政编码(zip code)，代表着该房屋位置的交通便利性，是否需要步行还是开车？即决定了可步行性(walkability)。另外，还有可能邮政编码和地区财富水平(wealth)共同影响了房屋所在地区的学校质量(school quality)。如下图所示，该神经网络共有三个神经元，分别代表了family size，walkability和school quality。每个神经元都包含了一个ReLU函数(或者其他非线性函数)。那么，根据这个模型，我们可以根据房屋面积和卧室个数来估计family size，根据邮政编码来估计walkability，根据邮政编码和财富水平来估计school quality。最后，由family size，walkability和school quality灯这些人们比较关心的因素来预测最终的房屋价格。<br><img src="/2018/01/17/深度学习概论/housepriceprediction3.png" alt="housepriceprediction3"><br>所以，在这个例子中，x是size，bedrooms，zip code，wealth这四个输入；y是房屋的预测价格。这个神经网络模型包含的神经元个数更多一些，相对之前的单个神经元的模型更加复杂。那么，在建立一个表现良好的神经网络模型之后，在给定输入x时，就能得到比较好的输出y，即房屋的预测价格。</p><p>实际上，上面这个例子神经网络模型结构如下所示，分别是size，bedrooms，zip code和wealth。在给定这四个输入后，神经网络所做的就是输出房屋的预测价格y。图中，三个神经元所在的位置称之称之为中间层或者隐藏层(x所在的称之为输入层，y所在的称之为输出层)，每个神经元与所有的输入x都有关联。<br><img src="/2018/01/17/深度学习概论/housepriceprediction4.png" alt="housepriceprediction4"><br>这就是基本的神经网络模型结构。在训练的过程中，只要有足够的输入x和输出y，就能训练出较好的神经网络模型，该模型在此类房价预测问题中，能够得到比较准确的结果。</p><h3 id="Supervised-Learning-with-Neural-Network"><a href="#Supervised-Learning-with-Neural-Network" class="headerlink" title="Supervised Learning with Neural Network"></a>Supervised Learning with Neural Network</h3><p>目前为止，由神经网络模型创造的价值基本上都是基于监督式学习(Supervised Learning)的，监督式学习与非监督式学习本质区别就是是否已知训练样本的输出y。在实际应用中，机器学习解决的大部分问题都属于监督式学习，神经网络模型也大都属于监督式学习。下面举几个监督式学习在神经网络中应用的例子。<br>第一个例子是房屋价格预测。根据训练样本的输入x和输出y，训练神经网络模型，预测房价。<br>第二个例子是线上广告，输入x是广告和用户个人信息，输入y是用户是否对广告进行点击。神经网络模型经过训练，能够根据广告类型和用户信息对用户的点击行为进行预测，从而向用户提供自己可能感兴趣的广告。<br>第三个例子是电脑视觉(computer vision)。输入x是图片像素值，输出是图片所属的不同类别。<br>第四个例子是语音识别(speech recognition).可以将一段语音信号辨识为相应的文字信息。<br>第五个例子是智能翻译，通过神经网络输入英文，然后直接输出中文。<br>第六个例子是自动驾驶。通过输入一张图片或者汽车雷达信息，神经网络通过训练来告诉你相应的路况并做出相应的决策。<br>如下图所示<br><img src="/2018/01/17/深度学习概论/监督式学习.png" alt="监督式学习"></p><p>对于不同的问题和应用场合，应该使用不同类型的神经网络模型。上面介绍的几个例子中，<br>对于一般的监督式学习(房价预测和线上广告问题)，我们只要使用标准的神经网络模型就可以了。图像识别处理问题，我们则要使用卷积神经网络(Convolution Neural Network)即CNN。而对于处理类似语音这样的序列信号时，则要使用循环神经网络(Recurrent Neural Network),即RNN。还有其他例如自动驾驶这样的复杂问题则需要更加复杂的混合神经网络模型。<br>下面给出Standard NN，Convolutional NN和Recurrent NN的神经网络结构图。<br><img src="/2018/01/17/深度学习概论/CNNRNN.png" alt="CNNRNN"><br>CNN一般处理图像问题，RNN一般处理语音信号。</p><p>数据类型一般分为两种：结构化数据(Structured Data)和非结构化数据(Unstructured Data)。<br><img src="/2018/01/17/深度学习概论/结构化数据与非结构化数据.png" alt="结构化数据与非结构化数据"></p><h3 id="Why-is-Deep-Learning-taking-off"><a href="#Why-is-Deep-Learning-taking-off" class="headerlink" title="Why is Deep Learning taking off?"></a>Why is Deep Learning taking off?</h3><p>深度学习和神经网络背后的技术思想已经出现了数十年了，那么为什么直到现在才开始发挥作用呢？<br>深度学习为什么强大？下面我们用一张图来说明。如下图所示，横坐标x表示数据量(Amount of data),纵坐标y表示机器学习模型的性能表现(Performance)。<br><img src="/2018/01/17/深度学习概论/Performance.png" alt="Performance"><br>上面共有4条曲线。最底下那条红色曲线代表了传统机器学习算法的表现，例如是SVM，logistic regression，decision tree等，当数据量比较小的时候，传统学习模型的表现是比较好的，但是当数据量很大的时候表现很一般。黄色曲线代表了规模较小的神经网络模型(Small NN)。它在数据量大的时候性能优于传统机器学习。蓝色曲线代表了规模中等的神经网络模型(Media NN),它在数据量更大的时候表现比Small NN更好。绿色曲线代表了更大规模的神经网络(Large NN),即深度学习模型。从图中可以看出，在数据量很大的时候，它的表现仍然是最好的，而且基本上保持了较快的上升趋势。<br>深度学习强大的原因归结为3个因素：<br><strong>Data</strong><br><strong>Computation</strong><br><strong>Algorithms</strong><br>数据量的几何级数增加<br>GPU出现，计算机运算能力大大提升。<br>举个算法改进的例子：之前神经网络神经元的激活函数是Sigmoid函数，后来改成了ReLU函数。更改的原因是对于Sigmoid函数，在远离Sigmoid函数，后来改成了ReLU函数。之所以这样更改的原因是对于Sigmoid函数，在远离零点的位置，函数曲线非常平缓，其梯度始终为0，所以造成神经网络模型学习速度变得很慢。然而，ReLU函数在x大于零的区域，其梯度始终为1，尽管x在小于零的区域梯度为0，但是在实际应用中采用ReLU函数确实比Sigmoid函数快很多。<br>构建一个深度学习的流程是首先开始产生Idea，然后把Idea转化为Code，最后进行Experiment。根据结果修改Idea，继续这种循环，直到最终训练得到表现不错的深度学习网络模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于毕业设计选择了深度学习相关的选题，我便开始学习深度学习相关的课程，使用的课程资源是吴恩达的《神经网络与深度学习》,&lt;a href=&quot;http://mooc.study.163.com/smartSpec/detail/1001319001.htm&quot; target=&quot;_b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自顶向下之TCP</title>
    <link href="http://andeper.cn/2017/04/02/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8BTCP/"/>
    <id>http://andeper.cn/2017/04/02/自顶向下之TCP/</id>
    <published>2017-04-02T13:22:00.000Z</published>
    <updated>2018-01-17T07:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h3><h4 id="进程到进程的通信"><a href="#进程到进程的通信" class="headerlink" title="进程到进程的通信"></a>进程到进程的通信</h4><p>TCP通过使用端口号来提供进程到进程间通信</p><h4 id="流传递服务"><a href="#流传递服务" class="headerlink" title="流传递服务"></a>流传递服务</h4><p>TCP是一个面向流的协议,TCP允许发送进程以字节流的形式传递数据，并且接受进程也以字节流的形式接受数据</p><h4 id="全双工通信"><a href="#全双工通信" class="headerlink" title="全双工通信"></a>全双工通信</h4><p>数据可以在同一事件双向流动，每一个方向TCP都有发送和接受缓冲区，他们能双向发送和接受段</p><h4 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h4><p>TCP在发送端执行多路复用，在接收端执行多路分解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP服务&quot;&gt;&lt;a href=&quot;#TCP服务&quot; class=&quot;headerlink&quot; title=&quot;TCP服务&quot;&gt;&lt;/a&gt;TCP服务&lt;/h3&gt;&lt;h4 id=&quot;进程到进程的通信&quot;&gt;&lt;a href=&quot;#进程到进程的通信&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图解TCP/IP之TCP与UDP</title>
    <link href="http://andeper.cn/2017/03/19/%E5%9B%BE%E8%A7%A3TCPIP-TCP%E4%B8%8EUDP/"/>
    <id>http://andeper.cn/2017/03/19/图解TCPIP-TCP与UDP/</id>
    <published>2017-03-19T14:06:00.000Z</published>
    <updated>2017-03-20T06:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h3><h4 id="传输层的作用"><a href="#传输层的作用" class="headerlink" title="传输层的作用"></a>传输层的作用</h4><h5 id="传输层定义"><a href="#传输层定义" class="headerlink" title="传输层定义"></a>传输层定义</h5><p>IP首部有一个协议字段，用来标识网络层的上一层所采用的是哪一种传输层协议</p><h4 id=""><a href="#" class="headerlink" title="#"></a>#</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP与UDP&quot;&gt;&lt;a href=&quot;#TCP与UDP&quot; class=&quot;headerlink&quot; title=&quot;TCP与UDP&quot;&gt;&lt;/a&gt;TCP与UDP&lt;/h3&gt;&lt;h4 id=&quot;传输层的作用&quot;&gt;&lt;a href=&quot;#传输层的作用&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://andeper.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图解TCP/IP-IP协议相关技术</title>
    <link href="http://andeper.cn/2017/03/19/%E5%9B%BE%E8%A7%A3TCPIP-IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    <id>http://andeper.cn/2017/03/19/图解TCPIP-IP协议相关技术/</id>
    <published>2017-03-18T16:28:00.000Z</published>
    <updated>2017-03-20T06:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h3><h4 id="仅凭IP无法完成通信"><a href="#仅凭IP无法完成通信" class="headerlink" title="仅凭IP无法完成通信"></a>仅凭IP无法完成通信</h4><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><h5 id="IP地址不便记忆"><a href="#IP地址不便记忆" class="headerlink" title="IP地址不便记忆"></a>IP地址不便记忆</h5><h5 id="DNS的产生"><a href="#DNS的产生" class="headerlink" title="DNS的产生"></a>DNS的产生</h5><p>当用户输入域名时，DNS会自动检索那个注册了主机名和IP地址 的数据库，并迅速定位对应的IP地址</p><h5 id="域名的构成"><a href="#域名的构成" class="headerlink" title="域名的构成"></a>域名的构成</h5><p>域名的分成结构<br><strong>域名服务器</strong><br>域名服务器值管理域名的主机和相应软件，它可以管理所在分层的域的相关信息<br>其所管理的分层叫做ZONE<br>各个域的分层上都设有各自的域名服务器<br>各层域名服务器都了解以下分层所有域名服务器的IP地址，因此他们从根域名服务器开始呈树状结构相互连接<br>由于所有域名服务器都了解根域名服务器的IP地址，所以从根开始按照顺序追踪，可以访问世界上所有域名服务器的地址<br><strong>根据DNS协议，根域名服务器可以由13个IP地址表示，并且从A到M开始，然后由于IP任播可以为多个结点设置同一个IP地址，为了提高容灾能力和负载均衡能力</strong></p><h5 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h5><p>计算机pepper要访问www.ietf.org</p><ol><li>解析器为了调查IP地址，向域名服务器进行查询处理</li><li>接受到这个查询请求的域名服务器首先在自己的数据库进行查找，如果有则返回，没有则向上一级根域名服务器进行查询<h5 id="DNS如同互联网中的分布式数据库"><a href="#DNS如同互联网中的分布式数据库" class="headerlink" title="DNS如同互联网中的分布式数据库"></a>DNS如同互联网中的分布式数据库</h5><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><h5 id="ARP概要"><a href="#ARP概要" class="headerlink" title="ARP概要"></a>ARP概要</h5>ARP是一种解决地址问题的协议，用来定位下一个应该接受数据分包的网络设备对应的MAC地址<h5 id="ARP的工作机制"><a href="#ARP的工作机制" class="headerlink" title="ARP的工作机制"></a>ARP的工作机制</h5>假定主机A要向主机B发送IP包，主机A的IP地址为172.20.1.1，主机B的IP地址为172.20.1.2<br>主机A为了获得主机B的MAC地址，起初要通过广播发送一个ARP请求，这个包包含了主机的IP地址<br>广播的包可以被同意链路上所有主机或路由器接受，所有主机都会解析这个包，只有当这个包中IP地址和自己的IP地址一致，那么这个结点就将自己的MAC地址塞进ARP响应返回给主机A<h5 id="IP地址和MAC地址缺一不可？"><a href="#IP地址和MAC地址缺一不可？" class="headerlink" title="IP地址和MAC地址缺一不可？"></a>IP地址和MAC地址缺一不可？</h5>数据链路上只要知道接收端的MAC地址不久知道数据是准备发给主机B的吗，那么还需要知道它的IP地址吗？<br>主机A想发送数据报给主机B时必须得经过路由器C，即时知道B的MAC地址没有用，路由器C会隔断来两个网络，此时主机A要先得到C的MAC地址<h5 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h5>从MAC地址定位到IP地址的一种协议，将打印机等小型嵌入式设备连接到网络会用到<h5 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a>代理ARP</h5><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><h5 id="辅助IP的ICMP"><a href="#辅助IP的ICMP" class="headerlink" title="辅助IP的ICMP"></a>辅助IP的ICMP</h5>主要功能：</li><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程中IP包被废弃的具体原因</li><li>改善网络设置<br>ICMP只负责其中IP相关的设置<br>ICMP这种通知消息会使用IP进行发送<br>ICMP的消息大致分为两类：</li><li>通知出错原因的错误消息</li><li>用于诊断的查询消息<h5 id="主要的ICMP消息"><a href="#主要的ICMP消息" class="headerlink" title="主要的ICMP消息"></a>主要的ICMP消息</h5><strong>ICMP目标不可达消息</strong><br><strong>ICMP重定向消息</strong><br><strong>ICMP超时消息</strong><br><strong>ICMP回送消息</strong><h5 id="其他ICMP消息"><a href="#其他ICMP消息" class="headerlink" title="其他ICMP消息"></a>其他ICMP消息</h5><strong>ICMP原点抑制消息</strong><br><strong>ICMP路由探索消息</strong><br><strong>ICMP地址掩码消息</strong><h5 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h5><strong>ICMPv6的作用</strong><br><strong>邻居探索</strong><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><h5 id="NAT定义"><a href="#NAT定义" class="headerlink" title="NAT定义"></a>NAT定义</h5>Network Address Translator是用于本地网络的私有协议，在连接互联网时转而使用全局IP地址的技术，除转换IP地址外，还出现了可以转换TCP，UDP端口号的NAPT技术，由此可以实现用一个全局IP地址与多个主机通信<h5 id="NAT的工作机制"><a href="#NAT的工作机制" class="headerlink" title="NAT的工作机制"></a>NAT的工作机制</h5><h5 id="NAT-PT"><a href="#NAT-PT" class="headerlink" title="NAT-PT"></a>NAT-PT</h5><h5 id="NAT的潜在问题"><a href="#NAT的潜在问题" class="headerlink" title="NAT的潜在问题"></a>NAT的潜在问题</h5><h5 id="解决NAT的潜在问题与NAT穿越"><a href="#解决NAT的潜在问题与NAT穿越" class="headerlink" title="解决NAT的潜在问题与NAT穿越"></a>解决NAT的潜在问题与NAT穿越</h5><h4 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h4><img src="http://omjy3y3o5.bkt.clouddn.com/543a8ec0cfe6ab2940a9881cee2e0685.png" alt="ip"><br>在如图所示的网络环境中，网络A、B使用IPv6，如果处于中间位置的网络C支持使用IPv4的话，网络A与网络B之间将无法直接进行通信，这时候就需要采用IP隧道的功能<br>IP隧道可以降那些从网络A发过来的IPv6的包统和为一个数据，再为之追加一个IPv6的首部以后转发给网络C<br>一般情况下，紧接着IP首部的是TCP或UDP的首部，然而现在的应用中IP首部后面还是IP首部，这种网络层首部后面继续追加网络层首部的通信方法叫做IP隧道<h4 id="其他IP相关技术"><a href="#其他IP相关技术" class="headerlink" title="其他IP相关技术"></a>其他IP相关技术</h4><h5 id="IP多播相关技术"><a href="#IP多播相关技术" class="headerlink" title="IP多播相关技术"></a>IP多播相关技术</h5><h5 id="IP任播"><a href="#IP任播" class="headerlink" title="IP任播"></a>IP任播</h5><h5 id="通信质量控制"><a href="#通信质量控制" class="headerlink" title="通信质量控制"></a>通信质量控制</h5><h5 id="显式拥塞通知"><a href="#显式拥塞通知" class="headerlink" title="显式拥塞通知"></a>显式拥塞通知</h5><h5 id="Mobile-IP"><a href="#Mobile-IP" class="headerlink" title="Mobile IP"></a>Mobile IP</h5></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IP协议相关技术&quot;&gt;&lt;a href=&quot;#IP协议相关技术&quot; class=&quot;headerlink&quot; title=&quot;IP协议相关技术&quot;&gt;&lt;/a&gt;IP协议相关技术&lt;/h3&gt;&lt;h4 id=&quot;仅凭IP无法完成通信&quot;&gt;&lt;a href=&quot;#仅凭IP无法完成通信&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://andeper.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-理解Window和WindowManager</title>
    <link href="http://andeper.cn/2017/03/18/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager/"/>
    <id>http://andeper.cn/2017/03/18/Android开发艺术探索-理解Window和WindowManager/</id>
    <published>2017-03-18T08:53:00.000Z</published>
    <updated>2017-03-20T06:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第八章：理解Window和WindowManager"><a href="#第八章：理解Window和WindowManager" class="headerlink" title="第八章：理解Window和WindowManager"></a>第八章：理解Window和WindowManager</h3><p>Window表示一个窗口的概念。Window是一个抽象类，它的具体实现是PhoneWindow，创建一个Window在WindowManager中完成，但Window的具体实现是在WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。Andorid的所有视图都是通过Window来呈现的</p><h4 id="Window和WindowManager"><a href="#Window和WindowManager" class="headerlink" title="Window和WindowManager"></a>Window和WindowManager</h4><p>下面代码通过WindowManager添加一个Window<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Button mFloatingButton = <span class="keyword">new</span> Button(<span class="keyword">this</span>);</span><br><span class="line">mFloatingButton.setText(<span class="string">"button"</span>);</span><br><span class="line">WindowManager.LayoutParams mLayoutParams = <span class="keyword">new</span> WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT,<span class="number">0</span>,<span class="number">0</span>, PixelFormat.TRANSPARENT);</span><br><span class="line">mLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL| WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line">mLayoutParams.gravity = Gravity.LEFT|Gravity.TOP;</span><br><span class="line">mLayoutParams.x = <span class="number">100</span>;</span><br><span class="line">mLayoutParams.y = <span class="number">300</span>;</span><br><span class="line">WindowManager windowManager = getWindowManager();</span><br><span class="line">windowManager.addView(mFloatingButton,mLayoutParams);</span><br></pre></td></tr></table></figure></p><p>上述代码将Button添加到屏幕坐标为（100，300）的位置上，WindowManager.LayoutParams中的flag和type参数比较重要<br>Flags参数代表Window的属性<br>FLAG_NOT_FOCUSABLE<br>表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL。最终事件会直接传递给下层的具有焦点的Window<br>FLAG_NOT_TOUCH_MODAL<br>再次模式下，系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理，一般需要开启，否则其他Window将无法收到单击事件<br>FLAG_SHOW_WHEN_LOCKED<br>开启此模式可以让Window显示在锁屏的界面上</p><p>Type参数表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window<br>Window是分层的，每个WIndow都有对应的z-ordered，在三类Window中，应用Window的层级范围是1-99，子Window的范围哦是1000-1999，系统Window的层级范围是2000-2999<br>WindowManager只有三个功能。定义在ViewManager中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WindowManager操作Window更像是在操作Window中的View</p><h4 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h4><p>每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，Window是一个抽象的概念，View才是Window存在的实体。</p><h5 id="Window的添加过程"><a href="#Window的添加过程" class="headerlink" title="Window的添加过程"></a>Window的添加过程</h5><p>WindowManager的实现类WindowManagerImpl没有实现Window的三大操作，而是交给WindowManagerGlobal来处理，addView方法主要分为以下几步</p><h6 id="检查参数是否合法，如果是子Window还需要调整布局参数"><a href="#检查参数是否合法，如果是子Window还需要调整布局参数" class="headerlink" title="检查参数是否合法，如果是子Window还需要调整布局参数"></a>检查参数是否合法，如果是子Window还需要调整布局参数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">        <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h6 id="创建ViewRootImpl并将View添加到列表中"><a href="#创建ViewRootImpl并将View添加到列表中" class="headerlink" title="创建ViewRootImpl并将View添加到列表中"></a>创建ViewRootImpl并将View添加到列表中</h6><p>WindowManagerGlobal内部下面几个列表比较重要<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure></p><p>mViews存储所有Window对应的View<br>mRoots存储的是所有Window对应的ViewRootImpl<br>mParams存储所有对应的布局参数<br>mDyingViews则存储那些正在被删除的View对象。<br>addView通过如下方式将Window的一系列对象添加到列表中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">view.setLayoutParams(wparams);</span><br><span class="line">mViews.add(view);</span><br><span class="line">mRoots.add(root);</span><br><span class="line">mParams.add(wparams);</span><br></pre></td></tr></table></figure></p><h6 id="通过ViewRootImpl来更新界面并完成Window的添加过程"><a href="#通过ViewRootImpl来更新界面并完成Window的添加过程" class="headerlink" title="通过ViewRootImpl来更新界面并完成Window的添加过程"></a>通过ViewRootImpl来更新界面并完成Window的添加过程</h6><p>由ViewRootImpl的setView方法来完成.<br>View的绘制过程由ViewRootImpl的setView完成的<br>在setView内部会通过requestLayout来完成异步刷新请求的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>scheduleTraversals是View绘制的入口，接着会通过WindowSession最终来完成Window的添加过程<br>mWindowSession的类型是IWindowSession，它是一个Binder对象，真正的实现类是Session，也就是Window的添加过程是一次IPC调用<br>在Session内部会通过WindowManagerService来实现Window的添加</p><h5 id="Window的删除过程"><a href="#Window的删除过程" class="headerlink" title="Window的删除过程"></a>Window的删除过程</h5><p>真正删除View 的逻辑在dispatchDetachedFromWindow，重要做四件事情</p><ol><li>垃圾回收相关工作，比如清除数据和消息，移除回调</li><li>通过Session的remove方法删除View，这是一个IPC过程，最终会调用WindowManagerService的removeWindow方法</li><li>调用View的dispatchDetachedFromWindow调用回调，让用户在回调方法里做资源回收工作</li><li>调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams、以及mDyingViews</li></ol><h5 id="Window的更新过程"><a href="#Window的更新过程" class="headerlink" title="Window的更新过程"></a>Window的更新过程</h5><p>调用WindowManagerGlobal的updateViewLayout方法，首先更新View的LayoutParams并替换老的LayoutParams，接着再更新ViewRootImpl中的LayoutParams</p><h4 id="Window的创建过程"><a href="#Window的创建过程" class="headerlink" title="Window的创建过程"></a>Window的创建过程</h4><p>View是Android中的师徒的呈现方式，View必须附着在Window这个抽象的概念上面</p><h5 id="Activity的Window创建过程"><a href="#Activity的Window创建过程" class="headerlink" title="Activity的Window创建过程"></a>Activity的Window创建过程</h5><p>PhoneWindow的setContentView方法大致遵循如下几个步骤<br>1.如果没有DecorView，那么创建它<br>DecorView算是一个FrameLayout，它包含标题栏和内容栏，DecorView的创建过程由installDecor方法来完成，再方法内部会通过generateDecor方法来直接创建DecorView，这个时候DecorView还是一个空白的FrameLayout。<br>2.将View添加到DecorView的mContentParent中<br>3.回调Activity的onContentChanged方法通过Activity视图已经发生改变</p><h5 id="Dialog的Window创建过程"><a href="#Dialog的Window创建过程" class="headerlink" title="Dialog的Window创建过程"></a>Dialog的Window创建过程</h5><p>1.创建Window<br>2.初始化DecorView并将Dialog的视图添加到DecorView中<br>3.将DecorView添加到Window中并显示</p><h5 id="Toast的Window创建过程"><a href="#Toast的Window创建过程" class="headerlink" title="Toast的Window创建过程"></a>Toast的Window创建过程</h5><p>再Toast内部有两类IPC过程，第一类是Toast访问NotificationManagerService，第二类是NotificationManagerService回调Toast 的TN接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第八章：理解Window和WindowManager&quot;&gt;&lt;a href=&quot;#第八章：理解Window和WindowManager&quot; class=&quot;headerlink&quot; title=&quot;第八章：理解Window和WindowManager&quot;&gt;&lt;/a&gt;第八章：理解Wi
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://andeper.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-消息机制</title>
    <link href="http://andeper.cn/2017/03/15/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://andeper.cn/2017/03/15/Android开发艺术探索-消息机制/</id>
    <published>2017-03-15T02:51:00.000Z</published>
    <updated>2017-03-20T06:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消息机制概述"><a href="#消息机制概述" class="headerlink" title="消息机制概述"></a>消息机制概述</h3><p>Android访问UI只能在主线程中进行，如果在子线程访问ui就会抛出异常，这个验证工作是在ViewRootImpl中的checkThread中进行，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                    <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>系统为什么不允许在子线程访问UI呢？<br>因为Android的ui线程不是线程安全的<br>那么系统为什么不对UI控件的访问加上锁机制呢？<br>加上锁机制会让UI访问的逻辑变的复杂<br>锁机制会降低UI访问的效率</p><p>Handler工作原理<br>Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程没有Looper，那么就会报错<br>Handler创建完毕后，内部的Looper以及MessageQueue就可以和Handler一起协同工作了，然后通过Handler的post方法将一个Runnable投递到Handler内部的Looper中去处理，也可以通过Handler的send方法发送一个消息，这个消息同样会在Looper中去处理。<br>当Hnadler的sent方法被调用时，它会调用MessageQueue的enqueneMessage方法把这个消息放在消息队列中，然后Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handleMessage方法就会被调用。Looper是运行在创建Handler所在的线程中的，这样以来Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了</p><h3 id="消息机制分析"><a href="#消息机制分析" class="headerlink" title="消息机制分析"></a>消息机制分析</h3><h4 id="ThreadLocal的工作原理"><a href="#ThreadLocal的工作原理" class="headerlink" title="ThreadLocal的工作原理"></a>ThreadLocal的工作原理</h4><p>ThreadLocal是一个线程内部的数据存储类<br>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑使用ThreadLocal。<br>比如对于Handler，Looper的作用域就是线程且不同线程有不同的Looper<br>ThreadLocal的另一个使用场景就是复杂逻辑下的对象传递<br>具体使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">mBooleanThreadLocal.set(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"thread 1"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                mBooleanThreadLocal.set(<span class="keyword">false</span>);</span><br><span class="line">                Log.e(<span class="string">"tag"</span>,mBooleanThreadLocal.get().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"thread 2"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                Log.e(<span class="string">"tag"</span>,mBooleanThreadLocal.get().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br></pre></td></tr></table></figure><p><img src="http://omjy3y3o5.bkt.clouddn.com/f51a5a81197601e2d818ab7fcf2fe0d1.png" alt="result"><br>不同线程访问的是同一个ThreadLocal对象，但他们通过ThreadLocal获取到的值是不一样的<br>不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里源码和书上讲的不一样，数据其实是存在ThreadLocalMap中<br>住上的结论是他们操作的对象都是当前线程的localValues对象的table数组</p><h4 id="消息队列的工作原理"><a href="#消息队列的工作原理" class="headerlink" title="消息队列的工作原理"></a>消息队列的工作原理</h4><p>消息队列值得是MessageQueue，<br>MessageQueue包含两个操作：插入和读取<br>插入和读取方法分别为enqueneMessage和next</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要操作其实是单链表的插入操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">        <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">        <span class="comment">// which is not supported.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Got a message.</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="keyword">return</span> msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No more messages.</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run the idle handlers.</span></span><br><span class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>next是一个无限循环的方法，如果消息队列没有消息，那么next方法会一直阻塞在这里，有新消息到来时，next方法返回这条消息并将其从单链表移除</p><h4 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h4><p>Handler的工作需要Looper，没有Looper的线程会报错，通过Looper.prepared()即可为当前线程创建一个Looper，接着通过Looper.Loop()来开启消息循环<br>loop方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="comment">//不进入死循环，不断取对象</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Handler的工作原理"><a href="#Handler的工作原理" class="headerlink" title="Handler的工作原理"></a>Handler的工作原理</h4><p>Handler的工作主要包含消息的发送和接受过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       MessageQueue queue = mQueue;</span><br><span class="line">       <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">           RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">           Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Hadnler发送消息只是向消息队列插入了一条消息，最终消息由Looper交由Handler处理，即Handler的dispatchMessage会被调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>消息处理流程图如下：<br><img src="http://omjy3y3o5.bkt.clouddn.com/7d2884b24e9ebc2cae44415c4de6e17a.png" alt="流程图"></p><h3 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h3><p>主线程就是ActivityThread，入口方法为main，在main方法中会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepareMainLooper();</span><br><span class="line">ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">    Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">            LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure></p><p>总结<br>当我们调用handler.sendMessage(msg)方法发送一个Message时，实际上这个Message是发送到与当前线程绑定的一个MessageQueue中，然后与当前线程绑定的Looper将会不断的从MessageQueue中取出新的Message，调用msg.target.dispathMessage(msg)方法将消息分发到与Message绑定的handler.handleMessage()方法中。<br>一个Thread对应多个Handler 一个Thread对应一个Looper和MessageQueue，Handler与Thread共享Looper和MessageQueue。 Message只是消息的载体，将会被发送到与线程绑定的唯一的MessageQueue中，并且被与线程绑定的唯一的Looper分发，被与其自身绑定的Handler消费。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;消息机制概述&quot;&gt;&lt;a href=&quot;#消息机制概述&quot; class=&quot;headerlink&quot; title=&quot;消息机制概述&quot;&gt;&lt;/a&gt;消息机制概述&lt;/h3&gt;&lt;p&gt;Android访问UI只能在主线程中进行，如果在子线程访问ui就会抛出异常，这个验证工作是在ViewRoot
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://andeper.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>基础面试题</title>
    <link href="http://andeper.cn/2017/03/14/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://andeper.cn/2017/03/14/基础面试题/</id>
    <published>2017-03-14T12:30:00.000Z</published>
    <updated>2017-03-20T06:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.TCP三次握手、四次挥手<br>2.为什么建立连接是三次，而断开连接要四次？<br>3.HTTP POST 和 GET的区别和联系。<br>4.进程和线程的区别。<br>5.操作系统内存管理。<br>6.进程间如何通信<br>7.操作系统中有几种状态</p><h5 id="8-从下往上说一下OSI七个分层？"><a href="#8-从下往上说一下OSI七个分层？" class="headerlink" title="8.从下往上说一下OSI七个分层？"></a>8.从下往上说一下OSI七个分层？</h5><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><h5 id="TCP、UDP属于哪个层？"><a href="#TCP、UDP属于哪个层？" class="headerlink" title="TCP、UDP属于哪个层？"></a>TCP、UDP属于哪个层？</h5><p>传输   </p><h5 id="FTP在哪个层？"><a href="#FTP在哪个层？" class="headerlink" title="FTP在哪个层？"></a>FTP在哪个层？</h5><p>应用<br>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议（5层）：物理层、数据链路层、网络层、运输层、 应用层。<br>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关）<br>数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p><h5 id="每一层的作用："><a href="#每一层的作用：" class="headerlink" title="每一层的作用："></a>每一层的作用：</h5><p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><h5 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h5><p>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。（TCP发出去还会问候核实一下以确保安全;UDP发出去就不管了 ）<br>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。</p><h5 id="TCP对应的协议"><a href="#TCP对应的协议" class="headerlink" title="TCP对应的协议:"></a>TCP对应的协议:</h5><p>（1）FTP：定义了文件传输协议，使用21端口。<br>（2）Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3）SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4）POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</p><h5 id="TDP对应的协议："><a href="#TDP对应的协议：" class="headerlink" title="TDP对应的协议："></a>TDP对应的协议：</h5><p>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在端口69上使用UDP服务。</p><p>作者：微尘2017<br>链接：<a href="https://www.nowcoder.com/discuss/21845?type=2&amp;order=0&amp;pos=26&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/21845?type=2&amp;order=0&amp;pos=26&amp;page=1</a><br>来源：牛客网</p><p>1.线程通信方式，以及它们的区别</p><pre><code>2.I/O多路复用3.内存管理，我回答的是jvm内存分配、垃圾回收4.TCP连接、断开状态转换，具体细节5.海量数据下，如何做随机抽样？蓄水池抽样（这里感觉面试官题目定义的不清楚）6.海量文本下，字符串匹配，如何利用索引加快查找？（这题真不会，后来查了一下，可能跟lucene有关）7.50亿URL，统计频率在前100位的URL</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.TCP三次握手、四次挥手&lt;br&gt;2.为什么建立连接是三次，而断开连接要四次？&lt;br&gt;3.HTTP POST 和 GET的区别和联系。&lt;br&gt;4.进程和线程的区别。&lt;br&gt;5.操作系统内存管理。&lt;br&gt;6.进程间如何通信&lt;br&gt;7.操作系统中有几种状态&lt;/p&gt;
&lt;h5 i
      
    
    </summary>
    
    
      <category term="面试题" scheme="http://andeper.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题</title>
    <link href="http://andeper.cn/2017/03/14/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://andeper.cn/2017/03/14/Java面试题/</id>
    <published>2017-03-14T12:28:00.000Z</published>
    <updated>2017-03-20T06:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>java的话常规的题目如：抽象，多态，虚拟机双亲模型，gc，内存结构，多线程，线程池，自动装箱，io等。结合数据结构问的重点是容器，抛了引子，会写源码，ok了。 然后并发库，equal方法源码等。之后排序，各种应用场景排序，大规模排序，分桶。<br>偏项目，每一面都会问项目，二面，三面扩展知识比较多，涉及多线程比较多，虚拟机比较多，或者源码。</p><p>1.hashtable和hashmap的区别， hashmap底层的实现机制：负载因子、冲突解决方式。Java 8的优化。<br>2.string 和stringbuffer的区别。<br>3.JVM内存模型，每个区域存放的内容。<br>4.JVM垃圾回收算法。<br>5.JVM类加载机制、双亲委托模型。<br>6.问我notify<br>7.synchronized关键字、Lock，并解释它们之间的区别。</p><h5 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h5><p>底层是数组加链表实现的哈希表。允许null作为键，null作为值。线程不安全。</p><h5 id="为什么用数组-链表实现？"><a href="#为什么用数组-链表实现？" class="headerlink" title="为什么用数组+链表实现？"></a>为什么用数组+链表实现？</h5><p>利用拉链法解决冲突：把所有的同义词用单链表链接起来。该方法下，哈希表每个单元中存放的不再是元素本身，而是相应同义词单链表的头指针。<br>HashMap维护了一个Entry数组，Entry内部类有key,value，hash和next四个字段，其中next也是一个Entry类型。<br>可以将Entry数组理解为一个个的散列桶。每一个桶实际上是一个单链表。当执行put操作时，会根据key的hashcode定位到相应的桶。<br>遍历单链表检查该key是否已经存在，如果存在，覆盖该value，反之，新建一个新的Entry，并放在单链表的头部。<br>当通过传递key调用get方法时，它再次使用key.hashCode()来找到相应的散列桶，然后使用key.equals()方法找出单链表中正确的Entry，然后返回它的值。 </p><h5 id="Java运行时数据区域？"><a href="#Java运行时数据区域？" class="headerlink" title="Java运行时数据区域？"></a>Java运行时数据区域？</h5><h5 id="方法区里存放什么？"><a href="#方法区里存放什么？" class="headerlink" title="方法区里存放什么？"></a>方法区里存放什么？</h5><p>当时只想到常量和静态变量…然后觉得不妥，赶紧补充：由于程序计数器、JVM栈、本地方法栈3个区域随线程而生随线程而灭，对这几个区域内存的回收和分配具有确定性。<br>而方法区和堆则不一样，程序需要在运行时才知道创建哪些对象，对这部分内存的分配是动态的，GC关注的也就是这部分内存。<br>本地方法栈：和jvm栈所发挥的作用类似，区别是jvm栈为jvm执行java方法（字节码）服务，而本地方法栈为jvm使用的native方法服务。<br>JVM栈：局部变量表、操作数栈、动态链接、方法出口。<br>方法区：用于存储已被虚拟机加载的类信息，常量、静态变量、即时编译器编译后的代码等。<br>堆：存放对象实例。</p><h5 id="怎样判断是否需要收集？"><a href="#怎样判断是否需要收集？" class="headerlink" title="怎样判断是否需要收集？"></a>怎样判断是否需要收集？</h5><p>引用计数法：对象没有任何引用与之关联(无法解决循环引用)<br>可达性分析法：通过一组称为GC<br>Root的对象为起点,从这些节点向下搜索，如果某对象不能从这些根对象的一个(至少一个)所到达,则判定该对象应当回收。</p><h5 id="什么可作为GCRoot的对象？"><a href="#什么可作为GCRoot的对象？" class="headerlink" title="什么可作为GCRoot的对象？"></a>什么可作为GCRoot的对象？</h5><p>虚拟机栈中引用的对象。方法区中类静态属性引用的对象，方法区中类常量引用的对象，本地方法栈中JNI引用的对象。<br>总结：JVM这块是由自己读过的书本引出，总的来说，也算是整个面试环节里答得最好的模块了，因为这一周也的确用心准备了这块的知识点。所以大家一定要着重复习JVM这块的知识。</p><h5 id="红黑树数据结构？"><a href="#红黑树数据结构？" class="headerlink" title="红黑树数据结构？"></a>红黑树数据结构？</h5><p>  看见别人的面经里都是问B+树，所以看了一下午B+树，反而红黑树没怎么着重准备。只回答了红黑树的五个性质。本质是二叉搜索树，左节点小于根节点，右节点大于根节点。</p><p>  看看具体具体答案，又是没回答完整…..</p><p>  红黑树本质上是一颗二叉搜索树，它满足二叉搜索树的基本性质——即树中的任何节点的值大于它的左子节点，且小于它的右子节点。<br>  一颗红黑树必须满足以下几点条件：<br>  规则1、根节点必须是黑色。<br>  规则2、任意从根到叶子的路径不包含连续的红色节点。<br>  规则3、任意从根到叶子的路径的黑色节点总数相同。<br>  作为红黑树节点，其基本属性有：节点的颜色、左子节点指针、右子节点指针、父节点指针、节点的值。<br>  这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。<br>  因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限<br>  允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p><p>  在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。</p><p>  为此，本文中我们使用”nil叶子”或”空（null）叶子”，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。<br>  与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。<br>  因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。<br>  然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O(log<br>  n)）的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。<br>  虽然插入和删除很复杂，但操作时间仍可以保持为O(log n)次</p><h5 id="JDK1-8的改进"><a href="#JDK1-8的改进" class="headerlink" title="JDK1.8的改进"></a>JDK1.8的改进</h5><p>（lambda表达式、HashMap升级、ConcurrentHashMap升级、synchronized升级），此处没有答出<br>枚举器的升级（可能是我搞错了），增加了Iteable.forEach方法，Iterator.remove() 现在有一个默认的,会抛出异常的实现,lambda表达式的意义</p><h5 id="快排的思想，Partition"><a href="#快排的思想，Partition" class="headerlink" title="快排的思想，Partition"></a>快排的思想，Partition</h5><h5 id="垃圾回收，是否做过调优，新生代老年代的概念与晋升，以及新生代与老年代的垃圾回收，CMS垃圾收集器"><a href="#垃圾回收，是否做过调优，新生代老年代的概念与晋升，以及新生代与老年代的垃圾回收，CMS垃圾收集器" class="headerlink" title="垃圾回收，是否做过调优，新生代老年代的概念与晋升，以及新生代与老年代的垃圾回收，CMS垃圾收集器"></a>垃圾回收，是否做过调优，新生代老年代的概念与晋升，以及新生代与老年代的垃圾回收，CMS垃圾收集器</h5><p>你Java学的怎么样？<br>    我：</p><p>   还可以，有研究过部分JDK源码，比如常用的集合类如HashMap/Hashtable、ArrayList/LinkedList、Vector等，还有Java5之后的并发包JUC如concurrentHashMap、Executor框架、CopyOnWrite容器等。自己很欣赏Java巧妙的垃圾回收机制，看过周志明的《深入理解Java虚拟机》，因此对JVM相关的知识有所掌握……</p><pre><code>面：</code></pre><p>   嗯，学的挺深的，那你把JVM的结构和类加载原理说下。</p><pre><code>我：</code></pre><p>   马上拿起桌上的笔和纸，把虚拟机运行时包含的几个数据区和执行引擎画了下，包括方法区、虚拟机栈、本地方法栈、堆和程序计数器，然后介绍每个区域有什么作用，最后讲ClassLoader的类加载机制，还顺便说了下双亲委派机制。</p><pre><code>面：</code></pre><p>   （面试官点头表示满意）你刚刚说Java的GC机制很巧妙，那么它的巧妙之处在哪里？</p><pre><code>我：</code></pre><p>   我从两个方面说下自己的理解：一是Java的内存分配原理与C/C++不同，C/C++每次采用malloc或new申请内存时都要进行brk和mmap等系统调用，而系统调用发生在内核空间，每次都要中断进行切换，这需要一定的开销，而Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了，然后我详细介绍了GC原理、画图表示年轻代（Eden区和Survival区）、年老代、比例分配及为啥要这样分代回收（我认为巧妙就在于这里），有了GC基本结构后，我又详述了下GC是具体如何进行内存分配和垃圾回收的。</p><h5 id="简单描述一下多态（接口）在Java里是如何实现的（运行时多态）"><a href="#简单描述一下多态（接口）在Java里是如何实现的（运行时多态）" class="headerlink" title="简单描述一下多态（接口）在Java里是如何实现的（运行时多态）"></a>简单描述一下多态（接口）在Java里是如何实现的（运行时多态）</h5><p>1、对多态理解<br>2、写两个线程，交替打印1到100的奇数和偶数，在纸上写出<br>     3、有没有使用过Lock，怎么使用，和synchronized有什么区别，从jvm角度解释<br>     4、StringBuilder 和 StringBuffer区别，为什么，里面实现<br>     5、ArrayList 和 LinkedList 区别，原理  </p><pre><code> jvm   1、gc垃圾回收   2、静态分派和动态分派   3、四种引用的区别</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java的话常规的题目如：抽象，多态，虚拟机双亲模型，gc，内存结构，多线程，线程池，自动装箱，io等。结合数据结构问的重点是容器，抛了引子，会写源码，ok了。 然后并发库，equal方法源码等。之后排序，各种应用场景排序，大规模排序，分桶。&lt;br&gt;偏项目，每一面都会问项目
      
    
    </summary>
    
    
      <category term="面试题" scheme="http://andeper.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法面试题</title>
    <link href="http://andeper.cn/2017/03/14/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://andeper.cn/2017/03/14/算法面试题/</id>
    <published>2017-03-14T12:24:00.000Z</published>
    <updated>2017-03-20T06:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.爬n阶楼梯，每次只能爬1步或者2步，求总的走法。<br>这个我回答是斐波那契数列<br>2.汉罗塔，让我用算法实现<br>3.50亿qq号排序 这个我感觉也没有回答好<br>4.在一百个数中寻找重复数字，并对自己提出的算法进行更进一步的优化<br>5.判断在一个链表中是否有环<br>6.口述用Java代码去实现利用二叉排序树去排一个无序的一维数组<br>对动态规划的理解<br>最优子结构+重叠子问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.爬n阶楼梯，每次只能爬1步或者2步，求总的走法。&lt;br&gt;这个我回答是斐波那契数列&lt;br&gt;2.汉罗塔，让我用算法实现&lt;br&gt;3.50亿qq号排序 这个我感觉也没有回答好&lt;br&gt;4.在一百个数中寻找重复数字，并对自己提出的算法进行更进一步的优化&lt;br&gt;5.判断在一个链表中是
      
    
    </summary>
    
    
      <category term="面试题" scheme="http://andeper.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题</title>
    <link href="http://andeper.cn/2017/03/14/Android%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://andeper.cn/2017/03/14/Android面试题/</id>
    <published>2017-03-14T12:15:00.000Z</published>
    <updated>2017-05-20T06:57:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>AIDL, Binder，AMS， 启动流程， view绘制， 消息队列，Binder open(), map(),</p><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p><a href="http://blog.csdn.net/chenrushui/article/details/51724506" target="_blank" rel="noopener">http://blog.csdn.net/chenrushui/article/details/51724506</a></p><h4 id="对Android系统了解多少"><a href="#对Android系统了解多少" class="headerlink" title="对Android系统了解多少"></a>对Android系统了解多少</h4><p>我说知道Binder机制和Android系统启动过程<br>答主牛皮，忘这两个方面扯</p><h4 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h4><p>类比TCP协议，从应用层说到了Linux内核驱动<br>Binder通信的四个角色：<br>Client进程：使用服务的进程。<br>Server进程：提供服务的进程。<br>ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。<br>Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。<br>初次接触这些概念可能会觉得难于理解，读者可以把四个角色和熟悉的互联网进行类比：Server是服务器，Client是客户终端，ServiceManager是域名服务器（DNS），驱动是路由器。这样类比，你很容易就能理解下图：<br><img src="http://omjy3y3o5.bkt.clouddn.com/3426a4d163ae99a9f31836e8c7325dd5.png" alt="binder"><br>Binder的运行机制就很好理解了，Server进程向Service Manager进程注册服务（可访问的方法接口），Client进程通过Binder驱动可以访问到Server进程提供的服务。Binder驱动管理着Binder之间的数据传递，这个数据的具体格式由Binder协议定义（可以类比为网络传输的TCP协议）。并且Binder驱动持有每个Server在内核中的Binder实体，并给Client进程提供Binder的引用。<br>Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。</p><ol><li>Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中</li><li>Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server</li><li>Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信</li><li>Client和Server之间的进程间通信通过Binder驱动程序间接实现</li><li>Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力</li></ol><h4 id="Linux中进程A能否直接访问进行进程B？为什么？"><a href="#Linux中进程A能否直接访问进行进程B？为什么？" class="headerlink" title="Linux中进程A能否直接访问进行进程B？为什么？"></a>Linux中进程A能否直接访问进行进程B？为什么？</h4><p>我说不能，因为内存独立。面试官问两个进程会不会内存重叠？然后我就沉默了</p><h4 id="一个应用为什么要开多个进程？"><a href="#一个应用为什么要开多个进程？" class="headerlink" title="一个应用为什么要开多个进程？"></a>一个应用为什么要开多个进程？</h4><p>我说有的应用是流氓，进程间相互保活，有的是处于业务考虑，有的是解决65535方法数问题。</p><h4 id="一个应用中Activity启动另一个Activity和一个应用中Activity启动另一个应用中Acvtivity的差别大吗？"><a href="#一个应用中Activity启动另一个Activity和一个应用中Activity启动另一个应用中Acvtivity的差别大吗？" class="headerlink" title="一个应用中Activity启动另一个Activity和一个应用中Activity启动另一个应用中Acvtivity的差别大吗？"></a>一个应用中Activity启动另一个Activity和一个应用中Activity启动另一个应用中Acvtivity的差别大吗？</h4><p>扯到了Binder机制，任务栈应用的创建以及Activity的创建。</p><h4 id="view，SurfaceView，GLSurfaceView的关系和区别"><a href="#view，SurfaceView，GLSurfaceView的关系和区别" class="headerlink" title="view，SurfaceView，GLSurfaceView的关系和区别"></a>view，SurfaceView，GLSurfaceView的关系和区别</h4><p>SurfaceView和View最本质的区别在于，surfaceView是在一个新起的单独线程中可以重新绘制画面而View必须在UI的主线程中更新画面。<br>那么在UI的主线程中更新画面 可能会引发问题，比如你更新画面的时间过长，那么你的主UI线程会被你正在画的函数阻塞。那么将无法响应按键，触屏等消息。<br>当使用surfaceView 由于是在新的线程中更新画面所以不会阻塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要surfaceView中 thread处理，一般就需要有一个event queue的设计来保存touch event，这会稍稍复杂一点，因为涉及到线程同步。<br>所以基于以上，根据游戏特点，一般分成两类。</p><ol><li>被动更新画面的。比如棋类，这种用view就好了。因为画面的更新是依赖于 onTouch 来更新，可以直接使用 invalidate。 因为这种情况下，这一次Touch和下一次的Touch需要的时间比较长些，不会产生影响。</li><li>主动更新。比如一个人在一直跑动。这就需要一个单独的thread不停的重绘人的状态，避免阻塞main UI thread。所以显然view不合适，需要surfaceView来控制。<br>GLSurfaceView（Android中3D游戏专用画布）中渲染图片的对比中发现GLSurfaceView的效率高于SurfaceView的30倍；GLSurfaceView的效率主要是因为机器硬件的GPU加速，现在flash技术也有了GPU加速技术；<br>下面总结一下：<br>一般2D游戏使用SurfaceView足够，所以不要认为什么都要使用GLSurfaceView（openGL），而且 GLSurfaceView的弊端在于适配能力差，因为很多机型中是没有GPU加速的。<h4 id="各种动画的区别，500张图片怎么使用帧动画实现，怎样避免OOM，平时用什么动画，属性动画和补间动画的区别"><a href="#各种动画的区别，500张图片怎么使用帧动画实现，怎样避免OOM，平时用什么动画，属性动画和补间动画的区别" class="headerlink" title="各种动画的区别，500张图片怎么使用帧动画实现，怎样避免OOM，平时用什么动画，属性动画和补间动画的区别"></a>各种动画的区别，500张图片怎么使用帧动画实现，怎样避免OOM，平时用什么动画，属性动画和补间动画的区别</h4>View动画，帧动画和属性动画<h4 id="对懒加载的理解"><a href="#对懒加载的理解" class="headerlink" title="对懒加载的理解"></a>对懒加载的理解</h4><h4 id="开发过程中整体怎么考虑，注意什么方面"><a href="#开发过程中整体怎么考虑，注意什么方面" class="headerlink" title="开发过程中整体怎么考虑，注意什么方面"></a>开发过程中整体怎么考虑，注意什么方面</h4><h4 id="横竖屏切换生命周期的调用，怎么配置"><a href="#横竖屏切换生命周期的调用，怎么配置" class="headerlink" title="横竖屏切换生命周期的调用，怎么配置"></a>横竖屏切换生命周期的调用，怎么配置</h4><h4 id="有几种广播，怎么配置，有什么区别，自己对粘性广播的理解，系统中有什么用到了粘性广播"><a href="#有几种广播，怎么配置，有什么区别，自己对粘性广播的理解，系统中有什么用到了粘性广播" class="headerlink" title="有几种广播，怎么配置，有什么区别，自己对粘性广播的理解，系统中有什么用到了粘性广播"></a>有几种广播，怎么配置，有什么区别，自己对粘性广播的理解，系统中有什么用到了粘性广播</h4><h4 id="系统异常退出怎么保存数据，调用什么方法，怎么恢复数据，在哪里恢复数据"><a href="#系统异常退出怎么保存数据，调用什么方法，怎么恢复数据，在哪里恢复数据" class="headerlink" title="系统异常退出怎么保存数据，调用什么方法，怎么恢复数据，在哪里恢复数据"></a>系统异常退出怎么保存数据，调用什么方法，怎么恢复数据，在哪里恢复数据</h4><h4 id="fragment-和-fragmentPagerAdapter使用-fragment在哪个方法中初始化的"><a href="#fragment-和-fragmentPagerAdapter使用-fragment在哪个方法中初始化的" class="headerlink" title="fragment 和 fragmentPagerAdapter使用,fragment在哪个方法中初始化的"></a>fragment 和 fragmentPagerAdapter使用,fragment在哪个方法中初始化的</h4><h4 id="什么情况会造成内存泄露，怎么避免，handler为什么会内存泄露，怎么解决，为什么要用弱引用"><a href="#什么情况会造成内存泄露，怎么避免，handler为什么会内存泄露，怎么解决，为什么要用弱引用" class="headerlink" title="什么情况会造成内存泄露，怎么避免，handler为什么会内存泄露，怎么解决，为什么要用弱引用"></a>什么情况会造成内存泄露，怎么避免，handler为什么会内存泄露，怎么解决，为什么要用弱引用</h4><h4 id="各种情况的优化，比如listview加载数据怎么优化，有几种优化的方案，LRCache原理"><a href="#各种情况的优化，比如listview加载数据怎么优化，有几种优化的方案，LRCache原理" class="headerlink" title="各种情况的优化，比如listview加载数据怎么优化，有几种优化的方案，LRCache原理"></a>各种情况的优化，比如listview加载数据怎么优化，有几种优化的方案，LRCache原理</h4><h4 id="如何防止Service被kill"><a href="#如何防止Service被kill" class="headerlink" title="如何防止Service被kill"></a>如何防止Service被kill</h4><h4 id="AIDL使用，源码"><a href="#AIDL使用，源码" class="headerlink" title="AIDL使用，源码"></a>AIDL使用，源码</h4><h4 id="对进程守护的理解"><a href="#对进程守护的理解" class="headerlink" title="对进程守护的理解"></a>对进程守护的理解</h4><h4 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h4><h4 id="滑动冲突解决，事件分发机制"><a href="#滑动冲突解决，事件分发机制" class="headerlink" title="滑动冲突解决，事件分发机制"></a>滑动冲突解决，事件分发机制</h4><h4 id="adapter-和-listview-的工作流程，转换流程，内部原理"><a href="#adapter-和-listview-的工作流程，转换流程，内部原理" class="headerlink" title="adapter 和 listview 的工作流程，转换流程，内部原理"></a>adapter 和 listview 的工作流程，转换流程，内部原理</h4><h4 id="自定义view流程，onMeasure三种模式的区别和应用，对MeasureSpec的理解"><a href="#自定义view流程，onMeasure三种模式的区别和应用，对MeasureSpec的理解" class="headerlink" title="自定义view流程，onMeasure三种模式的区别和应用，对MeasureSpec的理解"></a>自定义view流程，onMeasure三种模式的区别和应用，对MeasureSpec的理解</h4><h4 id="继承ViewGroup，在纸上写出，如何自定义-LinearLayout-和-Relativelayout"><a href="#继承ViewGroup，在纸上写出，如何自定义-LinearLayout-和-Relativelayout" class="headerlink" title="继承ViewGroup，在纸上写出，如何自定义 LinearLayout 和  Relativelayout"></a>继承ViewGroup，在纸上写出，如何自定义 LinearLayout 和  Relativelayout</h4><h4 id="打开手机随便指出一个界面，怎么自定义View实现，流程"><a href="#打开手机随便指出一个界面，怎么自定义View实现，流程" class="headerlink" title="打开手机随便指出一个界面，怎么自定义View实现，流程"></a>打开手机随便指出一个界面，怎么自定义View实现，流程</h4></li></ol><p>1.singleTask是否了解，举一个它的使用场景，后续问到会调用的方法。<br>各个模式的出入栈我能说出，但是singleTask的使用场景一时懵逼，举了个更适合singleTop的场景，果然问我觉得这种使用singleTask是不是最佳选择，自己觉得不是最佳，做了解释。</p><p>2.listView与recycleView常用哪个？(常用listView)问一下listView复用的问题。<br>a.说一下listView是怎么复用view的。<br>描述了listView重新使用已经移出屏幕的view。<br>b.怎么复用view。<br>这个肯定熟悉的，但是自己一来没经验二来太紧张，描述起来乱七八糟。<br>c.不使用viewHolder能不能进行view的复用。<br>这一个我一时也没能想出，大家能不能提供一个思路？还是根本就不行呢？<br>d.描述了一个场景，一个listView共有200项，10项可以占满屏幕，从顶部一直滑到底部，期间不向上滑，使用了复用的情况下，getView方法调用调用多少次，convertView初始化了几次。<br>自己回答gatView是每次都要的，convertView我们使用复用应该是10次。面试官人很好，说提示一下初始化了11或者12次，思考下为什么，我表示懵逼(其实此时大脑早已短路，对这次也没再抱有多大希望)。面试官告诉我，当我们最下方未完全滑入上方为完全滑出，这时也是要初始化的。我再次在心里感叹了自己智商掉线。</p><p>3.考虑这样一个布局怎么实现，就是常见的浏览器搜索框输入的时候，下方会出现搜索热词，各个热词排满一行后进入下一行。<br>我的思维已经完全僵化，也是没get他实际想问的知识，自己思考了使用各种布局利用各种wrapcontent、gravity，但是没有想到。面试官说其实这个比较难了，需要用到自定义viewGroup，我不肯放过机会机会表示自定义viewGroup我是写过的，实现这一个的话可以在layout方法操作，超过一行后布局到下一行。面试官紧接着问layout方法是什么作用，我只回答了确定各个子view的位置，此处需要大家帮助解答。</p><p>4.说一下view和viewGroup的事件传递机制吧，dispatchTouchEvent、onTouch和onTouchEvent先后先后顺序，还有onInterceptTouchEvent。<br>这一个自己其实当天还是仔细看过的，但是太紧张了，说的乱七八糟，尤其是拦截的部分，表述太差，也的确是了解不够，面试官表示了解的比较浅显。</p><p>5.contentprovider是否只能是数据库的数据，别的程序怎样读取。<br>自己只说出了contentResolver和uri，定义权限没说清楚。</p><p>6.描述了一个场景，微博中点击一个淘宝的链接，打开了淘宝应用，这是怎么完成的。</p><p>7.说一下fragment和activity的通信。<br>自己说到自定义接口，在fragment初始化时判定是否实现了接口，面试官紧接着问在哪个生命周期函数可以判断，我回答onAttach是双方绑定，onActivityCreated是activity的onCreate已经返回，我都是在onActivityCreated里判断的。面试官没有评价，此处求解。</p><p>8.fragment内部怎样嵌套fragment。<br>这个地方的好多函数我忘记了，所以自然说不出……事后自己查看是getChildFragmentManger，但是记成了getChildFragmentContext。面试官紧接着问，内层frag调用getContext获取的是哪一个context，自己之前就已经记错，回答是获取外层的，面试官无奈说回去自己写一下代码试下。</p><p>8.java的问题<br>a.静态内部类与非静态内部类区别。<br>b.因为前一个问题提到了内存泄漏，紧接着问你是怎么理解内存泄漏的。<br>c.什么样的对象是应该回收的呢？<br>bc两个问题自己答的乱七八糟，应该说我是懂得基本的道理的，但是叙述太差，说不准确也说不到要点。<br>d.匿名内部类有没有构造方法。<br>e.匿名内部类使用局部变量的要求。为什么要是final的。<br>为什么是final的表示不知道，其实自己查过多次，但是好像这里处理的很模糊？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AIDL, Binder，AMS， 启动流程， view绘制， 消息队列，Binder open(), map(),&lt;/p&gt;
&lt;h4 id=&quot;数字签名&quot;&gt;&lt;a href=&quot;#数字签名&quot; class=&quot;headerlink&quot; title=&quot;数字签名&quot;&gt;&lt;/a&gt;数字签名&lt;/h4
      
    
    </summary>
    
    
      <category term="面试题" scheme="http://andeper.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-事件分发</title>
    <link href="http://andeper.cn/2017/03/14/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>http://andeper.cn/2017/03/14/Android开发艺术探索-事件分发/</id>
    <published>2017-03-14T05:00:00.000Z</published>
    <updated>2017-04-14T05:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h3><h4 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h4><h5 id="public-boolean-dispatchTouchEvent-MotionEvent-event"><a href="#public-boolean-dispatchTouchEvent-MotionEvent-event" class="headerlink" title="public boolean dispatchTouchEvent(MotionEvent event)"></a>public boolean dispatchTouchEvent(MotionEvent event)</h5><p>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗此事件</p><h5 id="public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="public boolean onInterceptTouchEvent(MotionEvent ev)"></a>public boolean onInterceptTouchEvent(MotionEvent ev)</h5><p>用来判断是否拦截某个时间，如果事件能够传递给当前View，那么此方法一定会被调用，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件</p><h5 id="public-boolean-onTouchEvent-MotionEvent-event"><a href="#public-boolean-onTouchEvent-MotionEvent-event" class="headerlink" title="public boolean onTouchEvent(MotionEvent event)"></a>public boolean onTouchEvent(MotionEvent event)</h5><p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接受到事件<br>这三个方法的关系可以用下面伪代码来表示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;</span><br><span class="line">      consume = onTouchEvent(event);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      consume = child.dispatchTouchEvent(event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> consume;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><p>对一个ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，如果过这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用。如果onInterceptTouchEvent方法返回false就表示他不拦截当前事件，此时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用<br>当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTo uchListener中的onTouch方法会被回调。此时事件如何处理还要看onTouch的返回值，如果返回false，则当前onTouchEvent方法会被调用，返回true那么onTouchEvent方法不会被调用<br>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View，即事件总是先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View。如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，如果所有元素都不处理这个事件，那么这个事件最终传递给Activity</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="Activity对点击事件的分发过程"><a href="#Activity对点击事件的分发过程" class="headerlink" title="Activity对点击事件的分发过程"></a>Activity对点击事件的分发过程</h4><p>源码Activity#dispatchTouchEvent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>事件开始首先交给Activity所附属的Window进行分发，如果返回true,整个事件循环就结束了，如果返回了false，那么Activity的onTouchEvent就会被调用<br>接下来看Window是如何将事件传递给ViewGroup的，Window的superDispatchTouchEvent方法也是个抽象方法<br>Window类可以控制顶级View的外观和行为策略，它的实现类是PhoneWindow<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递给decorView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击事件直接传递到了DecorView，DecorView继承自FrameLayout且是父View，我们通过setContentView设置的View就是它的一个子View</p><h4 id="顶级View的分发过程"><a href="#顶级View的分发过程" class="headerlink" title="顶级View的分发过程"></a>顶级View的分发过程</h4><p>直接上ViewGroup的dispatchTouchEvent方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于辅助功能事件的处理</span></span><br><span class="line">    <span class="comment">// If the event targets the accessibility focused view and this is it, start</span></span><br><span class="line">    <span class="comment">// normal event dispatch. Maybe a descendant is what will handle the click.</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">        <span class="comment">//处理原始的down事件</span></span><br><span class="line">        <span class="comment">// Handle an initial down.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">//在新事件开始时处理完上一个事件</span></span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            <span class="comment">//这个方法会重置FLAG_DISALLOW_INTERCEPT</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查事件拦截</span></span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//ViewGroup在如下两种情况会判断是否拦截当前事件，事件类型为Down或者mFirstTouchTarget!=null</span></span><br><span class="line">            <span class="comment">//当事件由ViewGroup的子元素成功处理时，mFirstTouchTarget会被赋值并指向子元素</span></span><br><span class="line">            <span class="comment">//View调用request——DisallowInterceptTouchEvent并不能影响ViewGroup对ACTION_DOWN的处理，</span></span><br><span class="line">            <span class="comment">//而且onInterceptTouchEvent不是每次事件都会被调用</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed，恢复事件防止其改变</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If intercepted, start normal event dispatch. Also if there is already</span></span><br><span class="line">        <span class="comment">// a view that is handling the gesture, do normal event dispatch.</span></span><br><span class="line">        <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查事件是否取消</span></span><br><span class="line">        <span class="comment">// Check for cancelation.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="comment">//如果有必要的话，为所有down事件检查所有的目标对象</span></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果事件未被取消未被拦截</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">//如果有辅助功能的参与，则直接将事件投递到对应的View，否则事件分发给所有的子View</span></span><br><span class="line">            <span class="comment">// If the event is targeting accessiiblity focus we give it to the</span></span><br><span class="line">            <span class="comment">// view that has accessibility focus and if it does not handle it</span></span><br><span class="line">            <span class="comment">// we clear the flag and dispatch the event to all children as usual.</span></span><br><span class="line">            <span class="comment">// We are looking up the accessibility focused host to avoid keeping</span></span><br><span class="line">            <span class="comment">// state since these events are very rare.</span></span><br><span class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                    ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果事件为起始事件</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line">                <span class="comment">//如果TouchTarget为空且子元素不为0</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">//自上而下去寻找一个可以就收该事件的子View</span></span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="comment">//遍历子元素</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">                        <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">                        <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">                        <span class="comment">// safer given the timeframe.</span></span><br><span class="line">                        <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">//实际上是调用子元素的dispatchTouchEvent</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看看dispatchTransformedTouchEvent是如何调度子元素dispatchTouchEvent<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">        <span class="comment">//如果事件被取消</span></span><br><span class="line">        <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></span><br><span class="line">        <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            <span class="comment">//如果没有子元素</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//调用父类的dispatchTouchEvent</span></span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果有子元素传递cancel事件</span></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算将被传递的点的数量</span></span><br><span class="line">        <span class="comment">// Calculate the number of pointers to deliver.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line">        <span class="comment">//如果没有相应的点，那么就丢弃该事件</span></span><br><span class="line">        <span class="comment">// If for some reason we ended up in an inconsistent state where it looks like we</span></span><br><span class="line">        <span class="comment">// might produce a motion event with no pointers in it, then drop the event.</span></span><br><span class="line">        <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//声明临时变量保存坐标转换后的MotionEvent</span></span><br><span class="line">        <span class="comment">// If the number of pointers is the same and we don't need to perform any fancy</span></span><br><span class="line">        <span class="comment">// irreversible transformations, then we can reuse the motion event for this</span></span><br><span class="line">        <span class="comment">// dispatch as long as we are careful to revert any changes we make.</span></span><br><span class="line">        <span class="comment">// Otherwise we need to make a copy.</span></span><br><span class="line">        <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">        <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//尝试获取xy方向上的偏移量</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                    <span class="comment">//将MotionEvent进行坐标变换</span></span><br><span class="line">                    event.offsetLocation(offsetX, offsetY);</span><br><span class="line">                    <span class="comment">//将变换后的MotionEvent传递给子元素</span></span><br><span class="line">                    handled = child.dispatchTouchEvent(event);</span><br><span class="line">                    <span class="comment">//复位MotionEvent之后再次使用</span></span><br><span class="line">                    event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handled;</span><br><span class="line">            &#125;</span><br><span class="line">            transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">            transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">            <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">                transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Done.</span></span><br><span class="line">        transformedEvent.recycle();</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;View的事件分发机制&quot;&gt;&lt;a href=&quot;#View的事件分发机制&quot; class=&quot;headerlink&quot; title=&quot;View的事件分发机制&quot;&gt;&lt;/a&gt;View的事件分发机制&lt;/h3&gt;&lt;h4 id=&quot;点击事件的传递规则&quot;&gt;&lt;a href=&quot;#点击事件的传递规
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://andeper.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索-IPC机制</title>
    <link href="http://andeper.cn/2017/03/13/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-IPC%E6%9C%BA%E5%88%B6/"/>
    <id>http://andeper.cn/2017/03/13/Android开发艺术探索-IPC机制/</id>
    <published>2017-03-13T06:23:00.000Z</published>
    <updated>2017-03-20T06:56:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android-IPC简介"><a href="#Android-IPC简介" class="headerlink" title="Android IPC简介"></a>Android IPC简介</h3><p>IPC是Inter-Process Communication的缩写，含义为进程间通信</p><h3 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h3><h4 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h4><p>在Android中只能在AndroidMenifest中指定android:process属性，除此之外就是通过JNI在native层去fork一个新的进程<br>在指定进程时，“:”的含义是指要在当前进程名前面附加上当前的包名，而且“:”开头的进程属于私有进程，其他应用的组建不能和他泡在同一个进程里，不以“:”开头的属于全局进程，其他应用可以通过ShareUID方式和它泡在同一个进程里<br>Android系统会为每个应用分配唯一一个UID，具有相同UID的应用才能共享数据</p><h4 id="多进程模式的运行机制"><a href="#多进程模式的运行机制" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h4><p>Android为每个应用分配了一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间，导致在不同虚拟机访问同一个类的对象会产生多份副本。<br>使用多进程会造成如下几个方面的问题<br>（1）静态成员和单例模式完全失效<br>（2）线程同步机制完全失效<br>（3）SharePreferences可靠性下降<br>（4）Application会多次创建<br><strong>SharePreferences底层通过读写xml来实现</strong></p><h3 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h3><h4 id="Serializable接"><a href="#Serializable接" class="headerlink" title="Serializable接"></a>Serializable接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.text"</span>));</span><br><span class="line">User user1 = (User) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h4 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h4><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th><th>标记位</th></tr></thead><tbody><tr><td>createFromParcel(Parcel in)</td><td>从序列化的对象中创建原始对象</td><td></td></tr><tr><td>newArray(int size)</td><td>创建指定长度的原始对象爱那个数组</td><td></td></tr><tr><td>User(Parcel in)</td><td>从序列化后的对象中创建原始对象</td><td></td></tr><tr><td>writeToParcel(Paecel out,int flag)</td><td>将当前对象写入序列化结构中，其中flags标识由两种值：0或者1.为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0</td><td>PARCEABLE_WRITE_RETURN_VALUE</td></tr><tr><td>describeContents</td><td>返回当前对象的内容描述，如果含有文件描述符，返回1，否则返回0，几乎所有情况都返回0</td><td>CONTENTS_FILE_DESCRIPTOR</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line">    <span class="keyword">public</span> Book book;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String username, <span class="keyword">boolean</span> isMale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.isMale = isMale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        userId = in.readInt();</span><br><span class="line">        username = in.readString();</span><br><span class="line">        isMale = in.readByte() != <span class="number">0</span>;</span><br><span class="line">        book = in.readParcelable(Book.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Creator&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel parcel, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        parcel.writeInt(userId);</span><br><span class="line">        parcel.writeString(username);</span><br><span class="line">        parcel.writeByte((<span class="keyword">byte</span>) (isMale ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">        parcel.writeParcelable(book, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Serializable使用简单但io开销大，Parcelable使用麻烦但效率很高，无所谓反正实际都不会用到</p><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>Binder是一种跨进程通信的方式<br>Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁<br>Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端就返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务或者基于AIDL的服务<br>我们写好三个文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Book.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel parcel, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        parcel.writeInt(bookId);</span><br><span class="line">        parcel.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                <span class="string">"bookId="</span> + bookId +</span><br><span class="line">                <span class="string">", bookName='"</span> + bookName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.project.andeper.aidl;</span><br><span class="line">parcelable Book;</span><br><span class="line"><span class="comment">//IBookManager</span></span><br><span class="line"><span class="keyword">package</span> com.project.andeper.aidl;</span><br><span class="line"><span class="keyword">import</span> com.project.andeper.aidl.Book;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span></span>&#123;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>.aidl文件要放在aidl文件夹下<br>然后系统就生成下面这个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有可以在Binder中传输的接口都需要继承IInterface接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">project</span>.<span class="title">andeper</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Binder的唯一标识，一般由当前类名表示</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.project.andeper.aidl.IBookManager"</span>;</span><br><span class="line">        <span class="comment">//Stub是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，当两者位于不同进程，方法调用需要走transact过程，这个逻辑由Stub的内部代理类Proxy来完成，这个接口的核心实现就是它的内部类Stub和Stub的代理类Proxy</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，如果客户端与服务端位于同一进程，那么此方法返回的是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.project.andeper.aidl.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.project.andeper.aidl.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.project.andeper.aidl.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.project.andeper.aidl.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回当前Binder对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个方法运行在Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数，然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值，onTransace方法的执行过程就是这样的，需要注意的是，如果此方法返回false，那么客户端的请求就会失败，因此可以利用这个特性来做权限验证</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    java.util.List&lt;com.project.andeper.aidl.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    com.project.andeper.aidl.Book _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.project.andeper.aidl.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">project</span>.<span class="title">andeper</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//aidl中申明的方法</span></span><br><span class="line">            <span class="comment">//这个方法运行在客户端，当客户端远程调用此方法时，它的内部实现是这样的，首先创建该方法所需要的输入型Parcel对象_data、输出型Parcel对象_reply和返回值对象list；然后把该方法的参数信息写入_data中；接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，知道RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果；最后返回_reply中的数据</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.project.andeper.aidl.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.project.andeper.aidl.Book&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.project.andeper.aidl.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//aidl中申明的方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.project.andeper.aidl.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.project.andeper.aidl.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.project.andeper.aidl.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Android中的IPC方式"><a href="#Android中的IPC方式" class="headerlink" title="Android中的IPC方式"></a>Android中的IPC方式</h3><h4 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h4><h4 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h4><h4 id="使用Messenger"><a href="#使用Messenger" class="headerlink" title="使用Messenger"></a>使用Messenger</h4><h4 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，降暴露给客户端的接口在这个AIDL文件中声明。最后在Service中实现这个AIDL接口即可</p><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>首先绑定服务端的Service，绑定成功后，把服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法</p><h5 id="AIDL接口的创建"><a href="#AIDL接口的创建" class="headerlink" title="AIDL接口的创建"></a>AIDL接口的创建</h5><p>在AIDL文件中，只能使用指定的数据类型，基本数据类型，String和CharSequence、List只支持ArrayList、Map只支持HashMap，和所有实现了Parcelable接口的对象、AIDL.<br>除此之外，AIDL中除了基本数据类型其他类型的参数必须标上方向</p><h5 id="远程服务端Service的实现"><a href="#远程服务端Service的实现" class="headerlink" title="远程服务端Service的实现"></a>远程服务端Service的实现</h5><h5 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h5><h4 id="使用ContentProvider"><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h4><h4 id="使用Socket"><a href="#使用Socket" class="headerlink" title="使用Socket"></a>使用Socket</h4><h3 id="Binder连接池"><a href="#Binder连接池" class="headerlink" title="Binder连接池"></a>Binder连接池</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android-IPC简介&quot;&gt;&lt;a href=&quot;#Android-IPC简介&quot; class=&quot;headerlink&quot; title=&quot;Android IPC简介&quot;&gt;&lt;/a&gt;Android IPC简介&lt;/h3&gt;&lt;p&gt;IPC是Inter-Process Communic
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://andeper.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp框架解析</title>
    <link href="http://andeper.cn/2017/03/11/OkHttp%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://andeper.cn/2017/03/11/OkHttp框架解析/</id>
    <published>2017-03-11T12:29:00.000Z</published>
    <updated>2017-03-30T02:09:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文基本出自<a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="noopener">BlackSwift的简书</a><br>OkHttp是一个高效的Http客户端，有如下的特点：</p><ol><li>支持HTTP2/SPDY黑科技</li><li>socket自动选择最好路线，并支持自动重连</li><li>拥有自动维护的socket连接池，减少握手次数</li><li>拥有队列线程池，轻松写并发</li><li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）</li><li>基于Headers的缓存策略</li></ol><h4 id="主要对象"><a href="#主要对象" class="headerlink" title="主要对象"></a>主要对象</h4><p>Connections: 对JDK中的socket进行了引用计数封装，用来控制socket连接<br>Streams: 维护HTTP的流，用来对Requset/Response进行IO操作<br>Calls: HTTP请求任务封装<br>StreamAllocation: 用来控制Connections/Streams的资源分配与释放</p><h4 id="工作流程概述"><a href="#工作流程概述" class="headerlink" title="工作流程概述"></a>工作流程概述</h4><p>当我们用OkHttpClient.newCall(request)进行execute/enenqueue时，实际是将请求Call放到了Dispatcher中，okhttp使用Dispatcher进行线程分发，它有两种方法，一个是普通的同步单线程；另一种是使用了队列进行并发任务的分发(Dispatch)与回调，我们下面主要分析第二种，也就是队列这种情况，这也是okhttp能够竞争过其它库的核心功能之一</p><h4 id="Dispatcher结构"><a href="#Dispatcher结构" class="headerlink" title="Dispatcher结构"></a>Dispatcher结构</h4><p>Dispatcher维护了如下变量，用于控制并发的请求</p><h6 id="maxRequests-64-最大并发请求数为64"><a href="#maxRequests-64-最大并发请求数为64" class="headerlink" title="maxRequests = 64: 最大并发请求数为64"></a>maxRequests = 64: 最大并发请求数为64</h6><h6 id="maxRequestsPerHost-5-每个主机最大请求数为5"><a href="#maxRequestsPerHost-5-每个主机最大请求数为5" class="headerlink" title="maxRequestsPerHost = 5: 每个主机最大请求数为5"></a>maxRequestsPerHost = 5: 每个主机最大请求数为5</h6><h6 id="Dispatcher-分发者，也就是生产者（默认在主线程）"><a href="#Dispatcher-分发者，也就是生产者（默认在主线程）" class="headerlink" title="Dispatcher: 分发者，也就是生产者（默认在主线程）"></a>Dispatcher: 分发者，也就是生产者（默认在主线程）</h6><h6 id="AsyncCall-队列中需要处理的Runnable（包装了异步回调接口）"><a href="#AsyncCall-队列中需要处理的Runnable（包装了异步回调接口）" class="headerlink" title="AsyncCall: 队列中需要处理的Runnable（包装了异步回调接口）"></a>AsyncCall: 队列中需要处理的Runnable（包装了异步回调接口）</h6><h6 id="ExecutorService：消费者池（也就是线程池）"><a href="#ExecutorService：消费者池（也就是线程池）" class="headerlink" title="ExecutorService：消费者池（也就是线程池）"></a>ExecutorService：消费者池（也就是线程池）</h6><h6 id="Deque：缓存（用数组实现，可自动扩容，无大小限制）"><a href="#Deque：缓存（用数组实现，可自动扩容，无大小限制）" class="headerlink" title="Deque：缓存（用数组实现，可自动扩容，无大小限制）"></a>Deque<readyasynccalls>：缓存（用数组实现，可自动扩容，无大小限制）</readyasynccalls></h6><h6 id="Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存"><a href="#Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存" class="headerlink" title="Deque：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存"></a>Deque<runningasynccalls>：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存</runningasynccalls></h6><p>在下面的的代码中我们能看到线程池的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><h6 id="int-corePoolSize-最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。"><a href="#int-corePoolSize-最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。" class="headerlink" title="int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。"></a>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。</h6><h6 id="int-maximumPoolSize-最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理"><a href="#int-maximumPoolSize-最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理" class="headerlink" title="int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理"></a>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</h6><h6 id="long-keepAliveTime-当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive"><a href="#long-keepAliveTime-当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive" class="headerlink" title="long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive"></a>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</h6><h6 id="TimeUnit-unit-时间单位，一般用秒"><a href="#TimeUnit-unit-时间单位，一般用秒" class="headerlink" title="TimeUnit unit: 时间单位，一般用秒"></a>TimeUnit unit: 时间单位，一般用秒</h6><h6 id="BlockingQueue-workQueue-工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。"><a href="#BlockingQueue-workQueue-工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。" class="headerlink" title="BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。"></a>BlockingQueue<runnable> workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列。</runnable></h6><h6 id="ThreadFactory-threadFactory-单个线程的工厂，可以打Log，设置Daemon-即当JVM退出时，线程自动结束-等"><a href="#ThreadFactory-threadFactory-单个线程的工厂，可以打Log，设置Daemon-即当JVM退出时，线程自动结束-等" class="headerlink" title="ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等"></a>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</h6><h5 id="反向代理模式"><a href="#反向代理模式" class="headerlink" title="反向代理模式"></a>反向代理模式</h5><p>在Nginx中，用户通过Http访问前置的服务器，服务器也会添加Header并自动转发请求给后端集群，接着返回数据结果给用户。通过将工作分配给多个后台服务器并共享Session，可以提高服务的负载均衡，实现<strong>非阻塞、高可用、高并发连接</strong>。<br>在OkHttp中，使用Dispatcher作为任务的派发器，线程池对应多台后置服务器，用AsyncCall对应Socket请求，用Deque<readyasynccalls>对应Socket内部缓存<br><img src="http://omjy3y3o5.bkt.clouddn.com/a150a71fea0f337dea91ba2ae1a209b9.png" alt="Dispatcher"><br>当我们用OkHttp的异步请求时，实际上是Dispather进行了入队操作</readyasynccalls></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果正在进行的异步操作小于最大并发请求数并且请求某个主机的请求书小雨每个主机最大请求数<br>那么把请求添加到正在运行的任务队列<br>否则添加到缓存队列</p><p>当任务执行完之后，会在finally代码块中调用Dispatcher的finish函数，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!runningAsyncCalls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"AsyncCall wasn't running!"</span>);</span><br><span class="line">    promoteCalls();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        i.remove();</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用在一个任务完成之后，把缓存等待区的最后一个移动到运行区中并执行</p><h4 id="Socket管理-StreamAllocation"><a href="#Socket管理-StreamAllocation" class="headerlink" title="Socket管理(StreamAllocation)"></a>Socket管理(StreamAllocation)</h4><p>经过上一步的分配，我们现在需要进行连接了。我们目前有封装好的Request，而进行HTTP连接需要进行Socket握手，Socket握手的前提是根据域名或代理确定Socket的ip与端口。这个环节主要讲了http的握手过程与连接池的管理，分析的对象主要是StreamAllocation</p><h5 id="选择路线与自动重连-RouteSelector"><a href="#选择路线与自动重连-RouteSelector" class="headerlink" title="选择路线与自动重连(RouteSelector)"></a>选择路线与自动重连(RouteSelector)</h5><p>此步骤用于获取socket的ip与端口,各位请欣赏源码中next()的迷之缩进与递归，代码进行了如下事情：<br>如果Proxy为null:<br>在构造函数中设置代理为Proxy.NO_PROXY<br>如果缓存中的lastInetSocketAddress为空，就通过DNS（默认是Dns.SYSTEM，包装了jdk自带的lookup函数）查询，并保存结果，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源<br>如果还没有查询到就递归调用next查询，直到查到为止<br>一切next都没有枚举到，抛出NoSuchElementException，退出(这个几乎见不到)<br>如果Proxy为HTTP&#x3A;<br>设置socket的ip为代理地址的ip<br>设置socket的端口为代理地址的端口<br>一切next都没有枚举到，抛出NoSuchElementException，退出<br>HTTP代理是不安全的，本文附录有介绍<br>HTTP代理会帮你在远程服务器进行DNS查询<br>至于socket代理这里就不分析了，它已经不属于应用层了</p><h5 id="连接socket链路-RealConnection"><a href="#连接socket链路-RealConnection" class="headerlink" title="连接socket链路(RealConnection)"></a>连接socket链路(RealConnection)</h5><p>当地址，端口准备好了，就可以进行TCP连接了（也就是我们常说的TCP三次握手），步骤如下：</p><p>如果连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步<br>根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手<br>将建立成功的RealConnection放入(put)连接池缓存<br>如果存在TLS，就根据SSL版本与证书进行安全握手<br>构造HttpStream并维护刚刚的socket连接，管道建立完成</p><h5 id="释放socket链路-release"><a href="#释放socket链路-release" class="headerlink" title="释放socket链路(release)"></a>释放socket链路(release)</h5><p>如果不再需要（比如通信完成，连接失败等）此链路后，释放连接（也就是TCP断开的握手）<br>尝试从缓存的连接池中删除(remove)<br>如果没有命中缓存,就直接调用jdk的socket关闭</p><h4 id="复用连接池"><a href="#复用连接池" class="headerlink" title="复用连接池"></a>复用连接池</h4><p>在进行http连接时，首先进行tcp握手，然后传输数据，最后释放，但是在复杂的网络中，创建Socket需要进行三次五首，释放socket需要2次握手或者4次，在http中有一种叫做keeplive connection的机制，它可以在传输数据后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手<br>Okhttp支持5个并发的keepAlive,默认链路生命为5分钟。</p><h5 id="keepAlive的缺点"><a href="#keepAlive的缺点" class="headerlink" title="keepAlive的缺点"></a>keepAlive的缺点</h5><p>1.根据TCP的拥塞机制，当总水管大小固定时，如果存在大量空闲的keepalive connections（我们可以称作僵尸连接或者泄漏连接），其它客户端们的正常连接速度也会受到影响，这也是运营商为何限制P2P连接数的道理<br>2.服务器/防火墙上有并发限制，比如apache服务器对每个请求都开线程，导致只支持150个并发连接（数据来源于nginx官网），不过这个瓶颈随着高并发server软硬件的发展（golang/分布式/IO多路复用）将会越来越少<br>3.大量的DDOS产生的僵尸连接可能被用于恶意攻击服务器，耗尽资源</p><h5 id="连接池关键对象"><a href="#连接池关键对象" class="headerlink" title="连接池关键对象"></a>连接池关键对象</h5><h6 id="Call-对http的请求封装，属于程序员能够接触的上层高级代码"><a href="#Call-对http的请求封装，属于程序员能够接触的上层高级代码" class="headerlink" title="Call: 对http的请求封装，属于程序员能够接触的上层高级代码"></a>Call: 对http的请求封装，属于程序员能够接触的上层高级代码</h6><h6 id="Connection-对jdk的socket物理连接的包装，它内部有List-lt-WeakReference-gt-的引用"><a href="#Connection-对jdk的socket物理连接的包装，它内部有List-lt-WeakReference-gt-的引用" class="headerlink" title="Connection: 对jdk的socket物理连接的包装，它内部有List&lt;WeakReference&gt;的引用"></a>Connection: 对jdk的socket物理连接的包装，它内部有List&lt;WeakReference<streamallocation>&gt;的引用</streamallocation></h6><h6 id="StreamAllocation-表示Connection被上层高级代码的引用次数"><a href="#StreamAllocation-表示Connection被上层高级代码的引用次数" class="headerlink" title="StreamAllocation: 表示Connection被上层高级代码的引用次数"></a>StreamAllocation: 表示Connection被上层高级代码的引用次数</h6><h6 id="ConnectionPool-Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计"><a href="#ConnectionPool-Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计" class="headerlink" title="ConnectionPool: Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计"></a>ConnectionPool: Socket连接池，对连接缓存进行回收与管理，与CommonPool有类似的设计</h6><h6 id="Deque-Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础"><a href="#Deque-Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础" class="headerlink" title="Deque: Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础"></a>Deque: Deque也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是java基础</h6><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><p>在源码中，我们先找ConnectionPool实例化的位置，它是直接new出来的，而它的各种操作却在OkHttpClient的static区实现了Internal.instance接口作为ConnectionPool的包装。<br>至于为什么需要这么多此一举的分层包装，主要是为了让外部包的成员访问非public方法</p><h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><p>1.连接池内部维护了一个叫做OkHttp ConnectionPool的ThreadPool，专门用来淘汰末位的socket，当满足以下条件时，就会进行末位淘汰，非常像GC<br>并发socket空闲连接超过5个<br>某个socket的keepalive时间大于5分钟<br>2.维护着一个Deque<connection>，提供get/put/remove等数据结构的功能<br>3.维护着一个RouteDatabase，它用来记录连接失败的Route的黑名单，当连接失败的时候就会把失败的线路加进去（本文不讨论）</connection></p><h5 id="put-get操作"><a href="#put-get操作" class="headerlink" title="put/get操作"></a>put/get操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从连接池中获取</span></span><br><span class="line"><span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (connection.allocations.size() &lt; connection.allocationLimit</span><br><span class="line">          &amp;&amp; address.equals(connection.route().address)</span><br><span class="line">          &amp;&amp; !connection.noNewStreams) &#123;</span><br><span class="line">        streamAllocation.acquire(connection);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//放入连接池</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">      cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">      executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    connections.add(connection);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//线程变的空闲，并调用清理线程池</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">connectionBecameIdle</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (connection.noNewStreams || maxIdleConnections == <span class="number">0</span>) &#123;</span><br><span class="line">      connections.remove(connection);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      notifyAll(); <span class="comment">// Awake the cleanup thread: we may have exceeded the idle connection limit.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>随着上述操作被更高级的对象调用，Connection中的StreamAllocation被不断的aquire与release，也就是List&lt;WeakReference<streamallocation>&gt;的大小将时刻变化</streamallocation></p><h5 id="Connection自动回收的实现"><a href="#Connection自动回收的实现" class="headerlink" title="Connection自动回收的实现"></a>Connection自动回收的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">//遍历Deque所有的RealConnection，标记遗漏的连接</span></span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line">        <span class="comment">// 查询此连接内部StreamAllocation引用的数量</span></span><br><span class="line">        <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idleConnectionCount++;</span><br><span class="line">        <span class="comment">//标记出空闲的连接</span></span><br><span class="line">        <span class="comment">// If the connection is ready to be evicted, we're done.</span></span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">          <span class="comment">//如果(`空闲socket连接超过5个`</span></span><br><span class="line">          <span class="comment">//且`keepalive时间大于5分钟`)</span></span><br><span class="line">          <span class="comment">//就将此泄漏连接从`Deque`中移除</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//返回此连接即将到期的时间，供下次清理</span></span><br><span class="line">        <span class="comment">//这里依据是在上文`connectionBecameIdle`中设定的计时</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 全都是活跃的连接</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有任何连接，跳出循环</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>找到不活跃连接的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似于引用计数法，如果引用全部为空，返回立刻清理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//虚引用列表</span></span><br><span class="line">    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">      <span class="comment">//遍历弱引用列表</span></span><br><span class="line">      Reference&lt;StreamAllocation&gt; reference = references.get(i);</span><br><span class="line">      <span class="comment">//如果正在被使用，跳过，接着循环</span></span><br><span class="line">      <span class="comment">//是否置空是在上文`connectionBecameIdle`的`release`控制的</span></span><br><span class="line">      <span class="keyword">if</span> (reference.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//非常明显的引用计数</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// We've discovered a leaked allocation. This is an application bug.</span></span><br><span class="line">      Platform.get().log(WARN, <span class="string">"A connection to "</span> + connection.route().address().url()</span><br><span class="line">          + <span class="string">" was leaked. Did you forget to close a response body?"</span>, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//否则移除引用</span></span><br><span class="line">      references.remove(i);</span><br><span class="line">      connection.noNewStreams = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//如果所有分配的流均没了，标记为已经距离现在空闲了5分钟</span></span><br><span class="line">      <span class="comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span></span><br><span class="line">      <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">        connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> references.size();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过判断弱引用是是否为null来判断这个连接是否遗漏</p><p>根据生产者消费者模型的模型理论，当入队(enqueue)请求时，如果满足(runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行。如果消费者缓存满了，就放入readyAsyncCalls进行缓存等待。<br>当任务执行完成后,调用finished的promoteCalls()函数，手动移动缓存区（可以看出这里是主动清理的，因此不会发生死锁）</p><h4 id="HTTP请求序列化-反序列化"><a href="#HTTP请求序列化-反序列化" class="headerlink" title="HTTP请求序列化/反序列化"></a>HTTP请求序列化/反序列化</h4><p>本段主要分析从拼装HTTP套接字到读取的步骤，用垠神的话说，就是实现了一个Parser。分析的对象是HttpStream接口，在HTTP/1.1下是Http1xStream实现的</p><h5 id="获取Http流-HttpStream"><a href="#获取Http流-HttpStream" class="headerlink" title="获取Http流(HttpStream)"></a>获取Http流(HttpStream)</h5><p>我们已经在上文的RealConnection通过connectSocket构造HttpStream对象并建立套接字连接<br>在connect()有非常重要的一步，它通过okio库和远程socket建立了I/O连接，为了更好的理解，我们可以把它看成管道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//source 用于获取response</span></span><br><span class="line">source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line"><span class="comment">//sink 用于write buffer 到server</span></span><br><span class="line">sink = Okio.buffer(Okio.sink(rawSocket));</span><br></pre></td></tr></table></figure><p>Okhttp的I/O使用的是Okio库，它是java中最好用的I/O API，本人曾经写NFC对这个用的就非常顺手。<br>Buffer: Buffer是可变字节，类似于byte[]，相当于传输介质<br>source: source是okio库中的输入组件，类似于inputstream，经常在下载中用到。它的重要方法是read(Buffer sink, long byteCount)，从流中读取数据。<br>Sink: sink是okio库中的io输出组件，类似于outputstream，经常用于写到file/Socket，它的最重要方法是void write(Buffer source, long byteCount)，写数据到Buffer中<br>如果把连接看成管道，-&gt;为管道的方向，如下图，这里借鉴了go语言的描述</p><h5 id="拼装Raw请求与Headers-writeRequestHeaders"><a href="#拼装Raw请求与Headers-writeRequestHeaders" class="headerlink" title="拼装Raw请求与Headers(writeRequestHeaders)"></a>拼装Raw请求与Headers(writeRequestHeaders)</h5><p>我们通过Request.Builder构建了简陋的请求后，可能需要进行一些修饰，这时需要使用Interceptors对Request进行进一步的拼装了。<br>拦截器是okhttp中强大的流程装置，它可以用来监控log，修改请求，修改结果，甚至是对用户透明的GZIP压缩。类似于脚本语言中的map操作。在okhttp中，内部维护了一个Interceptors的List，通过InterceptorChain进行多次拦截修改操作。<br>请求的代码如下，详细代码在这里，源代码中是自增递归(recursive)调用Chain.process()，直到interceptors().size()中的拦截器全部调用完。这里代码维护性估计看着头大，大神们以后可能把它改成for等更简单的循环，主要做了两件事：<br>1.递归调用Interceptors，依次入栈对response进行处理<br>2.当全部递归出栈完成后，移交给网络模块(getResponse)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &lt; client.interceptors().size()) &#123;</span><br><span class="line"></span><br><span class="line">   Interceptor.Chain chain = <span class="keyword">new</span> ApplicationInterceptorChain(index + <span class="number">1</span>, request, forWebSocket);</span><br><span class="line">   Interceptor interceptor = client.interceptors().get(index);</span><br><span class="line">   <span class="comment">//递归调用Chain.process()</span></span><br><span class="line">   Response interceptedResponse = interceptor.intercept(chain);</span><br><span class="line">   <span class="keyword">if</span> (interceptedResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"application interceptor "</span> + interceptor</span><br><span class="line">         + <span class="string">" returned null"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> interceptedResponse;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// No more interceptors. Do HTTP.</span></span><br><span class="line"> <span class="keyword">return</span> getResponse(request, forWebSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是正式的网络请求getResponse()，此步骤通过http协议规范将对象中的数据信息序列化为Raw文本：<br>1.在okhttp中，通过RequestLine，Requst，HttpEngine，Header等参数进行序列化操作，也就是拼装参数为socketRaw数据。拼装方法也比较暴力，直接按照RFC协议要求的格式进行concat输出就实现了<br>2.通过sink写入write到socket连接。</p><h5 id="获得响应-readResponseHeaders-Body"><a href="#获得响应-readResponseHeaders-Body" class="headerlink" title="获得响应(readResponseHeaders/Body)"></a>获得响应(readResponseHeaders/Body)</h5><p>此步骤根据获取到的Socket纯文本，解析为Response对象，我们可以看成是一个反序列化（通过http协议将Raw文本转成对象）的过程：</p><p>拦截器的设计:<br>1.自定义网络拦截器请求进行递归入栈<br>2.在自定义网络拦截器的intercept中，调用NetworkInterceptorChain的proceed(request),进行真正的网络请求(readNetworkResponse)<br>3.接自定义请求递归出栈<br>网络读取(readNetworkResponse)分析:<br>1.读取Raw的第一行，并反序列化为StatusLine对象<br>2.以Transfer-Encoding: chunked的模式传输并组装Body<br>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(RawData &lt;- RemoteChannel(www.xx.com, <span class="number">80</span>))<span class="comment">//读取远程的Raw</span></span><br><span class="line">    map(<span class="function">func <span class="title">NetworkInterceptorChains</span><span class="params">()</span>)<span class="comment">//预处理</span></span></span><br><span class="line"><span class="function">    <span class="comment">//这里的source引用了HttpEngine，并重写了read方法</span></span></span><br><span class="line"><span class="function">    .<span class="title">map</span><span class="params">(func getTransferStream()</span></span>&#123;&#125;)</span><br><span class="line">    <span class="comment">//根据source拼装body对象</span></span><br><span class="line">    .map(<span class="function">func <span class="title">RealResponseBody</span><span class="params">()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>接下来进行释放socket连接，上文已经介绍过了。现在我们就获得到response对象，可以进行进一步的Gson等操作了。</p><h4 id="Http缓存基本知识"><a href="#Http缓存基本知识" class="headerlink" title="Http缓存基本知识"></a>Http缓存基本知识</h4><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>表示到期时间，一般用在response报文中，当超过此事件后响应将被认为是无效的而需要网络连接，反之而是直接使用缓存</p><h6 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h6><p>相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。</p><h6 id="修订文件名-Reving-Filenames"><a href="#修订文件名-Reving-Filenames" class="headerlink" title="修订文件名(Reving Filenames)"></a>修订文件名(Reving Filenames)</h6><p>如果我们通过设置header保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？我们这时可以通过修改url中的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery</p><h6 id="条件GET请求-Conditional-GET-Requests-与304"><a href="#条件GET请求-Conditional-GET-Requests-与304" class="headerlink" title="条件GET请求(Conditional GET Requests)与304"></a>条件GET请求(Conditional GET Requests)与304</h6><p>如缓存果过期或者强制放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送条件get请求即可，如果缓存是有效的，则返回304 Not Modifiled，否则直接返回body。<br>请求的方式有两种：<br>4.1. Last-Modified-Date:<br>客户端第一次网络请求时，服务器返回了<br>Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT<br>客户端再次请求时，通过发送<br>If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT<br>交给服务器进行判断，如果仍然可以缓存使用，服务器就返回304<br>4.2. ETag<br>ETag是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一请求时，服务器返回了<br>ETag: “5694c7ef-24dc”<br>客户端再次请求时，通过发送<br>If-None-Match:”5694c7ef-24dc”<br>交给服务器进行判断，如果仍然可以缓存使用，服务器就返回304<br>如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。</p><h6 id="其它标签"><a href="#其它标签" class="headerlink" title="其它标签"></a>其它标签</h6><p>no-cache/no-store: 不使用缓存，no-cache指令的目的是防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令的话，表示客户端将不会接受缓存过的相应，于是缓存服务器必须把客户端请求转发给源服务器。服务器端返回的相应中包含no-cache指令的话那么缓存服务器不能对资源进行缓存。<br>only-if-cached: 只使用缓存<br>Date: The date and time that the message was sent<br>Age: The Age response-header field conveys the sender’s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. 说人话就是CDN反代服务器到原始服务器获取数据延时的缓存时间<br><img src="http://omjy3y3o5.bkt.clouddn.com/78357eee1a7414813f7a1777729fd198.png" alt="缓存"></p><h4 id="缓存源码"><a href="#缓存源码" class="headerlink" title="缓存源码"></a>缓存源码</h4><p>OkHttp中使用了CacheStrategy实现了上文的流程图，它根据之前的缓存结果与当前将要发送Request的header进行策略分析，并得出是否进行请求的结论。<br>Request:<br>开发者手动编写并在Interceptor中递归加工而成的对象（如果读者需要调试分析的话，可以用logging-interceptor进行log操作），我们只需要知道了目前传入的Request中并没有任何关于缓存的Header<br>cacheCandidate:<br>也就是上次与服务器交互缓存的Response，可能为null。这里的缓存全部是基于文件系统的Map，key是请求中url的md5，value是在文件中查询到的缓存，页面置换基于LRU算法，我们现在只需要知道它是一个可以读取缓存Header的Response即可。<br>当被CacheStrategy加工输出后，输出networkRequest与cacheResponse，根据是否为空执行不同的请求</p><div class="table-container"><table><thead><tr><th>networkRequest</th><th style="text-align:center">cacheResponse</th><th>result</th></tr></thead><tbody><tr><td>null</td><td style="text-align:center">null</td><td>only-if-cached(表明不进行网络请求，且缓存不存在或者过期，一定会返回503错误)</td></tr><tr><td>null</td><td style="text-align:center">non-null</td><td>不进行网络请求，而且缓存可以使用，直接返回缓存，不用请求网络</td></tr><tr><td>non-null</td><td style="text-align:center">null</td><td>需要进行网络请求，而且缓存不存在或者过期，直接访问网络</td></tr><tr><td>non-null</td><td style="text-align:center">non-null</td><td>Header中含有ETag/Last-Modified标签，需要在条件请求下使用，还是需要访问网络</td></tr></tbody></table></div><p>CacheStrategy使用Factory模式进行构造，参数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InternalCache responseCache = Internal.instance.internalCache(client);</span><br><span class="line"><span class="comment">//cacheCandidate从disklurcache中获取</span></span><br><span class="line"><span class="comment">//request的url被md5序列化为key,进行缓存查询</span></span><br><span class="line">Response cacheCandidate = responseCache != <span class="keyword">null</span> ? responseCache.get(request) : <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//请求与缓存</span></span><br><span class="line">factory = <span class="keyword">new</span> CacheStrategy.Factory(now, request, cacheCandidate);</span><br><span class="line">cacheStrategy = factory.get();</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">networkRequest = cacheStrategy.networkRequest;</span><br><span class="line">cacheResponse = cacheStrategy.cacheResponse;</span><br><span class="line"><span class="comment">//进行一大堆的if判断，内容同上表格</span></span><br></pre></td></tr></table></figure><p>可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果缓存没有命中(即null),网络请求也不需要加缓存Header了</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//`没有缓存的网络请求,查上文的表可知是直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果缓存的TLS握手信息丢失,返回进行直接连接</span></span><br><span class="line">  <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检测response的状态码,Expired时间,是否有no-cache标签</span></span><br><span class="line">  <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">    <span class="comment">//直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CacheControl requestCaching = request.cacheControl();</span><br><span class="line">  <span class="comment">//如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)</span></span><br><span class="line">  <span class="comment">//或者有ETag/Since标签(也就是条件GET请求)</span></span><br><span class="line">  <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">    <span class="comment">//直接连接,把缓存判断交给服务器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据RFC协议计算</span></span><br><span class="line">  <span class="comment">//计算当前age的时间戳</span></span><br><span class="line">  <span class="comment">//now - sent + age (s)</span></span><br><span class="line">  <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">  <span class="comment">//大部分情况服务器设置为max-age</span></span><br><span class="line">  <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//大部分情况下是取max-age</span></span><br><span class="line">    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//大部分情况下设置是0</span></span><br><span class="line">    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//ParseHeader中的缓存控制信息</span></span><br><span class="line">  CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">  <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//设置最大过期时间,一般设置为0</span></span><br><span class="line">    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缓存在过期时间内,可以使用</span></span><br><span class="line">  <span class="comment">//大部分情况下是进行如下判断</span></span><br><span class="line">  <span class="comment">//now - sent + age + 0 &lt; max-age + 0</span></span><br><span class="line">  <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">    <span class="comment">//返回上次的缓存</span></span><br><span class="line">    Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缓存失效, 如果有etag等信息</span></span><br><span class="line">  <span class="comment">//进行发送`conditional`请求,交给服务器处理</span></span><br><span class="line">  Request.Builder conditionalRequestBuilder = request.newBuilder();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionalRequestBuilder.header(<span class="string">"If-None-Match"</span>, etag);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionalRequestBuilder.header(<span class="string">"If-Modified-Since"</span>, lastModifiedString);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionalRequestBuilder.header(<span class="string">"If-Modified-Since"</span>, servedDateString);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//下面请求实质还说网络请求</span></span><br><span class="line">  Request conditionalRequest = conditionalRequestBuilder.build();</span><br><span class="line">  <span class="keyword">return</span> hasConditions(conditionalRequest) ? <span class="keyword">new</span> CacheStrategy(conditionalRequest,</span><br><span class="line">      cacheResponse) : <span class="keyword">new</span> CacheStrategy(conditionalRequest, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。<br>1.Okhttp的缓存是自动完成的，完全由服务器Header决定的，自己没有必要进行控制。网上热传的文章在Interceptor中手工添加缓存代码控制，它固然有用，但是属于Hack式的利用，违反了RFC文档标准，不建议使用，OkHttp的官方缓存控制在注释中。如果读者的需求是对象持久化，建议用文件储存或者数据库即可（比如realm）。<br>2.服务器的配置非常重要，如果你需要减小请求次数，建议直接找对接人员对max-age等头文件进行优化；服务器的时钟需要严格NTP同步<br>3.充分利用Idea的findUsage的功能，源码的各个跳转条件可以很快分析完成<br>4.使用CMD + Y可以快速预览某个函数，类似于forcetouch功能</p><h4 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h4><h5 id="缓存简介、"><a href="#缓存简介、" class="headerlink" title="缓存简介、"></a>缓存简介、</h5><p>缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，Redis数据库，都可以看作缓存。它有如下的特点：</p><p>1.缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。<br>2.需要实现排序依据，在java中，可以使用Comparable<t>作为排序的的接口<br>3.需要一种页面置换算法(page replacement algorithm)将旧页面去掉换成新的页面，如最久未使用算法（LFU）、先进先出算法（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等<br>4.在OkHttp中，使用FileSystem作为缓存载体（磁盘相对于网络的缓存），使用LRU作为页面置换算法（封装了LinkedHashMap）。</t></p><p>在LinkedHashMap中，除了Node&lt;K,V&gt;[] table，还维护着Entry&lt;K,V&gt; head,tail。当put元素后，调用下列回调函数对链表将元素移动到链尾以及清理旧的元素<br>在get元素时，如果设置accessOrder为true时，通过调用如下回调移动元素到链尾，这里特别强调移动，如果这个元素本身已经在链表中，那它将只会移动，而不是新建<br>综上，当你反复对元素进行get/put操作时，经常使用的元素会被移动到tail中，而长期不用的元素会被移动到head</p><p>最后迭代(Iterator)时，迭代是从旧元素迭代到新元素，这就是LRU的实现</p><p><strong>OkHttp中的关键对象如下：</strong><br>FileSystem: 使用Okio对File的封装，简化了IO操作<br>DiskLruCache.Editor: 添加了同步锁，并对FileSystem进行高度封装<br>DiskLruCache.Entry: 维护着key对应的多个文件<br>Cache.Entry: Responsejava对象与Okio流的序列化/反序列化类<br>DiskLruCache: 维护着文件的创建，清理，读取。内部有清理线程池，LinkedHashMap(也就是LruCache)<br>Cache: 被上级代码调用，提供透明的put/get操作，封装了缓存检查条件与DiskLruCache，开发者只用配置大小即可，不需要手动管理<br>Response/Requset: OkHttp的请求与回应</p><h5 id="文件初级封装-FileSystem"><a href="#文件初级封装-FileSystem" class="headerlink" title="文件初级封装(FileSystem)"></a>文件初级封装(FileSystem)</h5><p>众所周之，文件读写是流操作，是一大堆的令人头痛的try/cache操作，在OkHttp中设计了FileSystem.SYSTEM作为文件层的管理。通过用Okio库中的Source/Sink对File进行包装，而不用更为头痛的InputStream这类东西，使上层调用与管道操作一样简单。<br>File(低级操作，步骤繁琐) -&gt; Okio(封装) －&gt; FileSystem(友好工具类)</p><h5 id="文件高级封装-DiskLruCache-Entry-Editor-Snapshot"><a href="#文件高级封装-DiskLruCache-Entry-Editor-Snapshot" class="headerlink" title="文件高级封装(DiskLruCache.Entry/Editor/Snapshot)"></a>文件高级封装(DiskLruCache.Entry/Editor/Snapshot)</h5><p>本部分进行了如下的转换，进行了实际的put/get操作<br>FileSystem &lt;— DiskLruCache.Entry/Editor —&gt; source/sink(更少参数)<br>DiskLruCache.Entry针对每个请求的url对应的文件进行引用维护（而没有进行创建/读取等操作），它内部维护了2个File数组，一般来说每个url对应2～4个文件。 文件名命名规则是{md5(url)+ {0,1}}，后面的0或1，分别表示ENTRY_METADATA与ENTRY_BODY。<br>DiskLruCache.Editor对工具类FileSystem进行进一步的封装，它以DiskLruCache.Entry作为构造参数，通过操控Entry中维护的数组，对外暴露source/sink，为上层的java对象与文件的转换提供基于okio的流操作，我们可以通过对它的两个方法进行FindUsage查询获得OkHttp关于文件读写的全部场景</p><h5 id="序列化与反序列化-Cache-Entry"><a href="#序列化与反序列化-Cache-Entry" class="headerlink" title="序列化与反序列化(Cache.Entry)"></a>序列化与反序列化(Cache.Entry)</h5><p>文件存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变<br>Resonse(java对象) &lt;—- Cache.Entry —-&gt; source/sink(文件io)<br>代码部分不复杂，与上面的findusage位置相同，可以概括下：<br>如果信息本身就是二进制，就直接写到文件中；如果是文本信息，按照预设的格式写入即可。<br>至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。<br>注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象</p><h5 id="缓存的自动清理"><a href="#缓存的自动清理" class="headerlink" title="缓存的自动清理"></a>缓存的自动清理</h5><p>在DiskLruCache初始化时，将建立线程池，最少零个线程，最大一个线程，线程空闲可以活60s，线程名叫做”OkHttp DiskLruCache”，当JVM退出时，线程自动结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!initialized | closed) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// Nothing to do</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历LRU缓存(从旧到新进行遍历map),并删除文件</span></span><br><span class="line">        <span class="comment">//直到小于MaxSize为止</span></span><br><span class="line">        trimToSize();</span><br><span class="line">        <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">          rebuildJournal();</span><br><span class="line">          redundantOpCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>OkHttp通过对文件进行了多次封装，实现了非常简单的I/O操作<br>OkHttp通过对请求url进行md5实现了与文件的映射，实现写入，删除等操作<br>OkHttp内部维护着清理线程池，实现对缓存文件的自动清理</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h5><p>代理，也就是有个中间服务器帮助你访问不存在的网站，okhttp中使用jdk自带的代理</p><p>You —— Proxy ——- Server<br>HTTP代理的本质是改Header信息，当你访问HTTP/HTTPS服务时，本质是明文向跳板发送如下raw，远程服务器帮你完成dns与请求操作，比如HTTPS请求源码就详细的解释了发送的内容是非加密的，下面是我实际抓包的内容</p><p>//HTTP 请求<br>GET HTTP&#x3A;//www.qq.com HTTP/1.1<br>//HTTPS 请求<br>CONNECT github.com:443 HTTP/1.1<br>上面的抓包过程，廉价的民用上网行为管理交换机就可以把你记录的一清二楚，所以慎用HTTP代理或者尽量使用HTTPS代理，它是“不安全”的。</p><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>DNS也就是域名到ip的映射(mapping)操作，用户向DNS服务器的53端口发送udp包后，会返回域名对应的地址，当然发送udp的细节对用户是透明的，用户直接调用jdk就可以了。我们先试下Unix下的查询</p><p>$ host baidu.com<br>baidu.com has address 111.13.101.208<br>baidu.com has address 123.125.114.144<br>…..<br>在OkHttp中，提供了DNS接口，默认是使用Dns.SYSTEM，它包装了java原生socket包中的InetAddress.getAllByName(hostname)方法。</p><p>参考：DNSPod中HTTP DNS的实现</p><h5 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h5><p>OkHttp的最底层是Socket，而不是URLConnection，它通过Platform的Class.forName()反射获得当前Runtime使用的socket库，调用栈如下（了解即可）</p><p>okhttp//实现HTTP协议<br>    framwork//JRE，实现JDK中Socket封装<br>      jvm//JDK的实现，本质对libc标准库的native封装<br>        bionic//android下的libc标准库<br>          systemcall//用户态切换入内核<br>              kernel//实现下协议栈(L4,L3)与网络驱动(一般是L2,L1)<br>如果你想用蓝牙硬件中Socket的进行HTTP协议开发，尝试重写这个类。</p><p>另外，再说一句废话，自从Android4.4以来，URLConnection在fram的实现也是使用了okhttp</p><p>OkHttp支持非常多平台下的Socket库实现，包括Android, JettyBootPlatform等都是支持的，具体的平台支持可以看这里</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文基本出自&lt;a href=&quot;http://www.jianshu.com/p/aad5aacd79bf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlackSwift的简书&lt;/a&gt;&lt;br&gt;OkHttp是一个高效的Http客户端，有如下的特点：&lt;/p&gt;
      
    
    </summary>
    
      <category term="框架解析" scheme="http://andeper.cn/categories/%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="框架解析" scheme="http://andeper.cn/tags/%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit框架解析</title>
    <link href="http://andeper.cn/2017/03/11/Retrofit%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://andeper.cn/2017/03/11/Retrofit框架解析/</id>
    <published>2017-03-11T06:59:00.000Z</published>
    <updated>2017-03-20T07:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Retrofit的原理"><a href="#Retrofit的原理" class="headerlink" title="Retrofit的原理"></a>Retrofit的原理</h4><p>Retrofit充当了一个适配器的角色，将一个java接口翻译成一个Http请求，然后用Okhttp去发送这个请求<br>它是通过java动态代理实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApiManagerService service = retrofit.create(ApiManagerService.class);</span><br></pre></td></tr></table></figure><p>传给一个ApiManagerService接口的Class对象，返回ApiManagerService的对象<br>进去看下create方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>获取数据的代码是这句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.carReco(descriptionRequest,body)</span><br></pre></td></tr></table></figure><p>上面的service其实就是一个动态代理对象，当service调用carReco方法时会被动态代理拦截，然后调用proxy.newProxyInstance方法中的InvocationHandler对象，他的invoke方法会传入三个对象<br><strong>Object proxy：代理对象</strong><br><strong>Method method：调用的方法</strong><br><strong>Object..args：方法的参数</strong><br>Retrofit关心的时method和他的参数args，接下去Retrofit就会用Java反射获取方法的注解信息，配合args参数，创建一个serviceMethod对象<br>ServiceMethod就像一个中央处理器，传入Retrofit对象和method对象，调用各个接口和解析器，最终生成一个Request,包含api的域名、path、http请求方法、请求头、是否有body、是否是multipart等等，最后返回一个Call对象<br>使用Java动态代理的目的就是拦截被调用的java方法，然后解析这个java方法的注解，最后生成Request由OkHttp发送</p><h4 id="创建ServiceMethod"><a href="#创建ServiceMethod" class="headerlink" title="创建ServiceMethod"></a>创建ServiceMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      callAdapter = createCallAdapter();</span><br><span class="line">      responseType = callAdapter.responseType();</span><br><span class="line">      <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">            + Utils.getRawType(responseType).getName()</span><br><span class="line">            + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      responseConverter = createResponseConverter();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(</span><br><span class="line">              <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"FormUrlEncoded can only be specified on HTTP methods with "</span></span><br><span class="line">              + <span class="string">"request body (e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">        Type parameterType = parameterTypes[p];</span><br><span class="line">        <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">              parameterType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">        <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CallAdapter&lt;?&gt; createCallAdapter() &#123;</span><br><span class="line">      Type returnType = method.getGenericReturnType();</span><br><span class="line">      <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(</span><br><span class="line">            <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Annotation[] annotations = method.getAnnotations();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.callAdapter(returnType, annotations);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到第一步获取CallAdapter，responseType和repositoryConverter三个对象，然后解析method的注解，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Retrofit的原理&quot;&gt;&lt;a href=&quot;#Retrofit的原理&quot; class=&quot;headerlink&quot; title=&quot;Retrofit的原理&quot;&gt;&lt;/a&gt;Retrofit的原理&lt;/h4&gt;&lt;p&gt;Retrofit充当了一个适配器的角色，将一个java接口翻译成一个
      
    
    </summary>
    
      <category term="框架解析" scheme="http://andeper.cn/categories/%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="框架解析" scheme="http://andeper.cn/tags/%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Volley框架解析</title>
    <link href="http://andeper.cn/2017/03/10/Volley%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://andeper.cn/2017/03/10/Volley框架解析/</id>
    <published>2017-03-10T13:52:00.000Z</published>
    <updated>2017-03-20T07:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>来来来，先来看下Volley的设计图<br><img src="http://omjy3y3o5.bkt.clouddn.com/2bd47591a6ea7c0619f5de33c36d2fa0.png" alt="Volley"><br>图中可以看到：<br>请求被添加到缓存队列<br>然后请求被缓存分发器出队<br>如果有缓存直接封装结果回调到主线程<br>如果没有缓存则被添加到网络请求队列<br>进行网络请求后传递response到主线程</p><h4 id="从使用Volley的第一步开始"><a href="#从使用Volley的第一步开始" class="headerlink" title="从使用Volley的第一步开始"></a>从使用Volley的第一步开始</h4><p>首先调用Volley.newRequestQueue来获取RequestQuene对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上是调用下面这个两个构造参数的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">        String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String packageName = context.getPackageName();</span><br><span class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</span><br><span class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">        RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">        queue.start();</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>当stack为空时，会判断手机系统半杯号是否大于9.如果大于9创建一个HurlStack，否则创建HttpClientStack。<br>在这里我们先知道在Android2.2之前HttpClient更好，反之HttpUrlConnection更好，稍后分析他的源码<br>在这个方法里还初始化NetWork类和RequestQueue类，现在我们来看看这两个类的实现。</p><h4 id="RequestQueue类"><a href="#RequestQueue类" class="headerlink" title="RequestQueue类"></a>RequestQueue类</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cache, network, threadPoolSize,<span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">        mCache = cache;</span><br><span class="line">        mNetwork = network;</span><br><span class="line">        mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">        mDelivery = delivery;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到RequestQueue四个参数<br>初始化了Cache、Nerwork、NetworkDispatcher,ExecutorDelivery四个参数</p><h5 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h5><p>下面看下这个类中的关键代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">        <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">        mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">        mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">            NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                    mCache, mDelivery);</span><br><span class="line">            mDispatchers[i] = networkDispatcher;</span><br><span class="line">            networkDispatcher.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在这个类中初始化了一个CacheDispatcher(缓存线程)和四个NetworkDispatcher(网络请求线程)<br>并调用了它们的start的方法</p><h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">        request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">            mCurrentRequests.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Process requests in the order they are added.</span></span><br><span class="line">        request.setSequence(getSequenceNumber());</span><br><span class="line">        request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line">        <span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.</span></span><br><span class="line">        <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">            mNetworkQueue.add(request);</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Insert request into stage if there's already a request with the same cache key in flight.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">            String cacheKey = request.getCacheKey();</span><br><span class="line">            <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">                <span class="comment">// There is already a request in flight. Queue up.</span></span><br><span class="line">                Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">                <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                stagedRequests.add(request);</span><br><span class="line">                mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                    VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></span><br><span class="line">                <span class="comment">// flight.</span></span><br><span class="line">                mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">                mCacheQueue.add(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，在添加请求时，如果请求不能被缓存，直接添加到网络请求队列<br>如果能缓存，被添加到缓存队列</p><h4 id="CacheDispatcher类"><a href="#CacheDispatcher类" class="headerlink" title="CacheDispatcher类"></a>CacheDispatcher类</h4><h5 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        <span class="comment">// Make a blocking call to initialize the cache.</span></span><br><span class="line">        mCache.initialize();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Get a request from the cache triage queue, blocking until</span></span><br><span class="line">                <span class="comment">// at least one is available.</span></span><br><span class="line">                <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">                request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line">                <span class="comment">// If the request has been canceled, don't bother dispatching it.</span></span><br><span class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Attempt to retrieve this item from cache.</span></span><br><span class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                    <span class="comment">// Cache miss; send off to the network dispatcher.</span></span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If it is completely expired, just send it to the network.</span></span><br><span class="line">                <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span></span><br><span class="line">                request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">                    <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span></span><br><span class="line">                    mDelivery.postResponse(request, response);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span></span><br><span class="line">                    <span class="comment">// but we need to also send the request to the network for</span></span><br><span class="line">                    <span class="comment">// refreshing.</span></span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line">                    <span class="comment">// Mark the response as intermediate.</span></span><br><span class="line">                    response.intermediate = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// Post the intermediate response back to the user and have</span></span><br><span class="line">                    <span class="comment">// the delivery then forward the request along to the network.</span></span><br><span class="line">                    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                mNetworkQueue.put(request);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                <span class="comment">// Not much we can do about this.</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死循环方法，这个线程一直会运行，这时候会判断请求是否取消，如果取消直接continue<br>如果没有取消会去查找是否有缓存，如果没有缓存或者缓存已经过期会把请求放到网络请求队列<br>然后判断缓存是否需要刷新，不需要则直接把结果传递回去，否则把结果传递回去后添加请求到网络请求队列<br>添加到网络请求队列，现在看看网络请求分发时怎么进行的</p><h4 id="NetworkDispatcher类"><a href="#NetworkDispatcher类" class="headerlink" title="NetworkDispatcher类"></a>NetworkDispatcher类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</span><br><span class="line">        Request&lt;?&gt; request;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Take a request from the queue.</span></span><br><span class="line">            request = mQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line">            <span class="comment">// If the request was cancelled already, do not perform the</span></span><br><span class="line">            <span class="comment">// network request.</span></span><br><span class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            addTrafficStatsTag(request);</span><br><span class="line">            <span class="comment">// Perform the network request.</span></span><br><span class="line">            NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">            request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line">            <span class="comment">// If the server returned 304 AND we delivered a response already,</span></span><br><span class="line">            <span class="comment">// we're done -- don't deliver a second identical response.</span></span><br><span class="line">            <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Parse the response here on the worker thread.</span></span><br><span class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">            request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line">            <span class="comment">// Write to cache if applicable.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line">            <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Post the response back.</span></span><br><span class="line">            request.markDelivered();</span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">            parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">            VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</span><br><span class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">            mDelivery.postError(request, volleyError);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的逻辑就很清晰了，首先会检查请求是否被取消，如果没有则在Network的performRequest方法中进行网络请求<br>然后构造Response对象准备回传，如果这个请求的结果能被缓存，那么则把这个结果缓存下来<br>出错了则构造VolleyErroy进行回传<br>既然网络请求是在PerformRequest方法进行的，那么我们去看下是怎么实现的<br>然而发现这个方法在Nerwork中，而Network是一个接口，所以我们直接看他的实现类BasicNetwork</p><h4 id="BasicNetwork类"><a href="#BasicNetwork类" class="headerlink" title="BasicNetwork类"></a>BasicNetwork类</h4><h5 id="PerformRequest方法"><a href="#PerformRequest方法" class="headerlink" title="PerformRequest方法"></a>PerformRequest方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">           Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// Gather headers.</span></span><br><span class="line">               Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">               addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">               httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">               StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">               <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</span><br><span class="line">               responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">               <span class="comment">// Handle cache validation.</span></span><br><span class="line">               <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">                   Entry entry = request.getCacheEntry();</span><br><span class="line">                   <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</span><br><span class="line">                               responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">                               SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// A HTTP 304 response does not have all header fields. We</span></span><br><span class="line">                   <span class="comment">// have to use the header fields from the cache entry plus</span></span><br><span class="line">                   <span class="comment">// the new ones from the response.</span></span><br><span class="line">                   <span class="comment">// http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</span></span><br><span class="line">                   entry.responseHeaders.putAll(responseHeaders);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</span><br><span class="line">                           entry.responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">                           SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">               <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">                 <span class="comment">// no-content request.</span></span><br><span class="line">                 responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// if the request is slow, log it.</span></span><br><span class="line">               <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">               logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line">               <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,</span><br><span class="line">                       SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">               attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line">               attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">               NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   statusCode = httpResponse.getStatusLine().getStatusCode();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</span><br><span class="line">               &#125;</span><br><span class="line">               VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</span><br><span class="line">               <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,</span><br><span class="line">                           responseHeaders, <span class="keyword">false</span>, SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">                   <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</span><br><span class="line">                           statusCode == HttpStatus.SC_FORBIDDEN) &#123;</span><br><span class="line">                       attemptRetryOnException(<span class="string">"auth"</span>,</span><br><span class="line">                               request, <span class="keyword">new</span> AuthFailureError(networkResponse));</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// <span class="doctag">TODO:</span> Only throw ServerError for 5xx status codes.</span></span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>大多都是网络请求细节的代码，重要代码在HttpStack.performRequest(request, headers)中<br>然而这个方法里就是网络请求的具体实现了，有时间再解析吧，其实也没啥好解析的<br>另外Request类中有个方法会解析返回的NetworkResponse<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br></pre></td></tr></table></figure></p><p>最后来看看回调怎么实现的吧<br>ResponseDelivery是个接口，实现类为ExexuterDelivery</p><h4 id="ExexuterDelivery"><a href="#ExexuterDelivery" class="headerlink" title="ExexuterDelivery"></a>ExexuterDelivery</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">     request.markDelivered();</span><br><span class="line">     request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">     mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// If this request has canceled, finish it and don't deliver.</span></span><br><span class="line">          <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">              mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Deliver a normal response or error, depending.</span></span><br><span class="line">          <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">              mRequest.deliverResponse(mResponse.result);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mRequest.deliverError(mResponse.error);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">          <span class="comment">// and the request can be finished.</span></span><br><span class="line">          <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">              mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></span><br><span class="line">          <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mRunnable.run();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>可以看到通过deliverResponse或者deliverError把结果发送到ui线程。<br>然后看下本地缓存怎么实现的</p><h4 id="DiskBasedCache类"><a href="#DiskBasedCache类" class="headerlink" title="DiskBasedCache类"></a>DiskBasedCache类</h4><p>由于缓存是写到本地文件夹的，所以缓存空间不能无限制增大<br>解决方法就要看下面这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pruneIfNeeded</span><span class="params">(<span class="keyword">int</span> neededSpace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">            VolleyLog.v(<span class="string">"Pruning old cache entries."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> before = mTotalSize;</span><br><span class="line">        <span class="keyword">int</span> prunedFiles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();</span><br><span class="line">            CacheHeader e = entry.getValue();</span><br><span class="line">            <span class="keyword">boolean</span> deleted = getFileForKey(e.key).delete();</span><br><span class="line">            <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">                mTotalSize -= e.size;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               VolleyLog.d(<span class="string">"Could not delete cache entry for key=%s, filename=%s"</span>,</span><br><span class="line">                       e.key, getFilenameForKey(e.key));</span><br><span class="line">            &#125;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            prunedFiles++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">            VolleyLog.v(<span class="string">"pruned %d files, %d bytes, %d ms"</span>,</span><br><span class="line">                    prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中mMaxCacheSizeInBytes是构造方法传入的一个缓存文件夹的大小，如果不传默认是5M的大小。<br>通过这个方法可以发现，每当被调用时会传入一个neededSpace，也就是需要申请的磁盘大小(即要新缓存的那个文件所需大小)。首先会判断如果这个neededSpace申请成功以后是否会超过最大可用容量，如果会超过，则通过遍历本地已经保存的缓存文件的header(header中包含了缓存文件的缓存有效期、占用大小等信息)去删除文件，直到可用容量不大于声明的缓存文件夹的大小。<br><strong>Volley缓存命中率的优化</strong><br>如果让你去设计Volley的缓存功能，你要如何增大它的命中率。<br>还是上面的代码，在缓存内容可能超过缓存文件夹的大小时，删除的逻辑是直接遍历header删除。这个时候删除的文件有可能是我们上一次请求时刚刚保存下来的，屁股都还没坐稳呢，现在立即删掉，有点舍不得啊。<br>如果遍历的时候，判断一下，首先删除超过缓存有效期的(过期缓存)，其次按照LRU算法，删除最久未使用的，岂不是更合适？<br><strong>Volley缓存文件名的计算</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getFilenameForKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstHalfLength = key.length() / <span class="number">2</span>;</span><br><span class="line">        String localFilename = String.valueOf(key.substring(<span class="number">0</span>, firstHalfLength).hashCode());</span><br><span class="line">        localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());</span><br><span class="line">        <span class="keyword">return</span> localFilename;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>把key分成两部分分别求hash值再把它们拼接起来，为了防止文件名冲突。<br>下面的总结出自<a href="http://blog.csdn.net/yanbober/article/details/45307217" target="_blank" rel="noopener">工匠若水的博文</a><br>当一个RequestQueue被成功申请后会开启一个CacheDispatcher和4个默认的NetworkDispatcher。<br>1.CacheDispatcher缓存调度器最为第一层缓冲，开始工作后阻塞的从缓存序列mCacheQueue中取得请求；对于已经取消的请求，标记为跳过并结束这个请求；新的或者过期的请求，直接放入mNetworkQueue中由N个NetworkDispatcher进行处理；已获得缓存信息（网络应答）却没有过期的请求，由Request的parseNetworkResponse进行解析，从而确定此应答是否成功。然后将请求和应答交由Delivery分发者进行处理，如果需要更新缓存那么该请求还会被放入mNetworkQueue中。<br>2.将请求Request add到RequestQueue后对于不需要缓存的请求（需要额外设置，默认是需要缓存）直接丢入mNetworkQueue交给N个NetworkDispatcher处理；对于需要缓存的，新的请求加到mCacheQueue中给CacheDispatcher处理；需要缓存，但是缓存列表中已经存在了相同URL的请求，放在mWaitingQueue中做暂时处理，等待之前请求完毕后，再重新添加到mCacheQueue中。<br>3.网络请求调度器NetworkDispatcher作为网络请求真实发生的地方，对消息交给BasicNetwork进行处理，同样的，请求和结果都交由Delivery分发者进行处理。<br>4.Delivery分发者实际上已经是对网络请求处理的最后一层了，在Delivery对请求处理之前，Request已经对网络应答进行过解析，此时应答成功与否已经设定；而后Delivery根据请求所获得的应答情况做不同处理；若应答成功，则触发deliverResponse方法，最终会触发开发者为Request设定的Listener；若应答失败，则触发deliverError方法，最终会触发开发者为Request设定的ErrorListener；处理完后，一个Request的生命周期就结束了，Delivery会调用Request的finish操作，将其从mRequestQueue中移除，与此同时，如果等待列表中存在相同URL的请求，则会将剩余的层级请求全部丢入mCacheQueue交由CacheDispatcher进行处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来来来，先来看下Volley的设计图&lt;br&gt;&lt;img src=&quot;http://omjy3y3o5.bkt.clouddn.com/2bd47591a6ea7c0619f5de33c36d2fa0.png&quot; alt=&quot;Volley&quot;&gt;&lt;br&gt;图中可以看到：&lt;br&gt;请求被添加到
      
    
    </summary>
    
      <category term="框架解析" scheme="http://andeper.cn/categories/%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="框架解析" scheme="http://andeper.cn/tags/%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
